---
title: 从输入URL到页面渲染
date: 2020-06-18 10:19:09
tags: http tcp 重绘回流 DNS IP
---

前言：不知道这玩意儿，前端也能干活。但是得进步啊。当学会了这玩意儿，对网络的理解会举头望明月，更上一层楼。
反正百利而无一害。嘿嘿，开始整活～

第一步，手放在键盘上敲出 url，然后回车，咔哒一敲！然后页面就出来了，是不是很简单～ 😁
让我们的学习气氛轻松起来～ 下面正式开始，我敲个 url：

https://onepunchx.github.io/archives/

## 详细解析

输入完这个网址，敲回车！浏览器做的第一件事是 解析这个 url：

1. **通过 _DNS_（domain name system） 把域名（domain name）解析程 _IP_ 地址**

IP 地址这玩意儿，就相当于我们每个人的身份证号码，身份证号可以唯一、精准的匹配到一个人，那么 IP 地址就可以唯一、精准的匹配到对应的计算机。
但是身份证号码这玩意，你能记住几个？能记住自己的就不错了，通常你记住的都是别人的名字，那么这个域名/网址/URL 就相当于计算机的名字
形象一点的对应关系如下：

| 表头          | 表头               |
| ------------- | ------------------ |
| 名字          | 身份证号码         |
| 王昊          | 211232199608135438 |
| 域名          | IP                 |
| www.baidu.com | 220.181.111.188    |

2. **然后应用曾生成 HTTP 请求报文**
   啥是请求报文？
   请求报文 有起始行 首部 和 主体部分，说起来太不形象具体了，直接上代码！

GET https://www.baidu.com/ HTTP/1.1 （起始行）

Host: www.baidu.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,_/_;q=0.8
X-Client-Data: CKm1yQEIhbbJAQijtskBCMG2yQEIqZ3KAQioo8oB
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
（首部）

然后是主体内容，get 请求的主体内容为空，post 的请求主体内容就是请求体，body 里面的内容

这个 http 请求报文说起来里面学问很大，有机会的话单独写一次。这里给自己先挖个坑。。。

3. **传输层建立 TCP 连接**
   3 次握手，4 次挥手。
   这里不细说，等待后续填坑

4. **网络层使用 IP 协议来选择路线**
   处理来自传输层的数据段 segment，将数据段 segment 装入数据包 packet，填充包头，主要就是添加源和目的 IP 地址，然后发送数据。在数据传输的过程中，IP 协议负责选择传送的路线，称为路由功能

5. **数据链路层实现网络相邻结点间可靠的数据通信**
   　　为了保证数据的可靠传输，把数据包 packet 封装成帧(Frame)，并按顺序传送各帧。由于物理线路的不可靠，发出的数据帧有可能在线路上出错或丢失，于是为每个数据分块计算出 CRC(循环冗余检验)，并把 CRC 添加到帧中，这样接收方就可以通过重新计算 CRC 来判断数据接收的正确性。一旦出错就重传

将数据包 packet 封装成帧(Frame)，包括帧头和帧尾。帧尾是添加被称做 CRC 的循环冗余校验部分。帧头主要是添加数据链路层的地址，即数据链路层的源地址和目的地址，即网络相邻结点间的源 MAC 地址和目的 MAC 地址

6. **数据链路层的帧(Frame)转换成二进制形式的比特(Bit)流，从网卡发送出去，再把比特转换成电子、光学或微波信号在网络中传输**
   光纤，电缆啥的这时候就派上用场啦

7. **服务器处理**
   通俗来说，就是先弄清楚浏览器需要什么，然后找到相关数据，然后封装这些数据，然后准备传回去。打个比方，如果我们输入了百度的网址
   www.baidu.com
   那么这里服务器就会把百度的首页的 html 给浏览器传过去

8. **服务器处理完事，给浏览器传回去，跟传过来的时候差不多**

9. **浏览器渲染**
   这时候你的电脑就接收到了服务器传过来的数据，然后经过处理，准备渲染，这个过程里呢就是遇见了 html 里面需要啥，就发请求获取啥。
   比如说
   浏览器开始载入 html 代码，发现<head>标签内有一个<link>标签引用外部 CSS 文件
   浏览器又发出 CSS 文件的请求，服务器返回这个 CSS 文件
   浏览器继续载入 html 中<body>部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了
   浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。
   服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。
   浏览器发现了一个包含一行 Javascript 代码的 script 标签，赶快运行它。
   Javascript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 style（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。
   就这样，浏览器吭呲瘪肚的终于把页面鼓捣出来了！

这就是整个过程啦，大概就是这么回事～

**页面渲染需要做这些事**

- 解析 html，创建 dom 树
- 解析 css ， 给页面美容
- 解析 js ，给页面交互响应

### ext 重绘和回流

#### 回流

回流是指窗口尺寸被修改、发生滚动操作，或者元素位置相关属性被更新时会触发布局过程，在布局过程中要计算所有元素的位置信息。
（尺寸长宽高改变，显隐就会回流啦）
由于 HTML 使用的是流式布局，如果页面中的一个元素的尺寸发生了变化，则其后续的元素位置都要跟着发生变化，也就是重新进行流式布局的过程，所以被称之为回流

#### 重绘

重绘是指当与视觉相关的样式属性值被更新时会触发绘制过程，在绘制过程中要重新计算元素的视觉信息，使元素呈现新的外观
当一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。

回流一定重绘，重绘不一定回流。
只有颜色改变的时候就只会发生重绘而不会引起回流
当页面布局和几何属性改变时就需要回流
比如：添加或者删除可见的 DOM 元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变

下面列举一些减少回流次数的方法（来自百度）

（1）不要一条一条地修改 DOM 样式，而是修改 className 或者修改 style.cssText

（2）在内存中多次操作节点，完成后再添加到文档中去

（3）对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示

（4）在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中

（5）不要使用 table 布局，因为一个小改动可能会造成整个 table 重新布局。而且 table 渲染通常要 3 倍于同等元素时间

## 总结

1. DNS 解析 URL 地址
2. 生成 HTTP 请求报文
3. 构建 TCP 连接
4. 使用 IP 协议选择传输路线
5. 数据链路层保证数据的可靠传输
6. 物理层将数据转换成电子、光学或微波信号进行传输
7. 服务器处理数据，并返回浏览器所需资源
8. 浏览器处理数据
9. 页面渲染

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实现excel的本地预览</title>
    <link href="/2020/08/11/preview-excel/"/>
    <url>/2020/08/11/preview-excel/</url>
    
    <content type="html"><![CDATA[<p>项目是外企的项目，它的线上服务器资源无法在公网访问到，所以无法使用微软公开的接口实现预览<br>由于不能使用微软接口在线预览 office 文件，所以自己实现了一套预览 excel 的方案，代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">'immer'</span>;<span class="hljs-keyword">import</span> XLSX <span class="hljs-keyword">from</span> <span class="hljs-string">'xlsx'</span>;<span class="hljs-keyword">import</span> &#123; Spin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span>;<span class="hljs-keyword">import</span> Tabs <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Enhanced/Tabs'</span>;<span class="hljs-keyword">import</span> &#123; request &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/Enhanced'</span>;<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.less'</span>;<span class="hljs-keyword">const</span> Index = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> &#123; src, ...rest &#125; = props;  <span class="hljs-keyword">const</span> [data, setData] = useState(<span class="hljs-literal">null</span>);  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (src) &#123;      request(src, &#123;        responseType: <span class="hljs-string">'arraybuffer'</span>,      &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (response.success) &#123;          <span class="hljs-keyword">const</span> workbook = XLSX.read(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(response.data), &#123;            type: <span class="hljs-string">'array'</span>,          &#125;);          <span class="hljs-keyword">const</span> newData = produce([], draftState =&gt; &#123;            <span class="hljs-comment">// eslint-disable-next-line</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(workbook.Sheets)) &#123;              draftState.push(&#123;                name: k,                html: XLSX.utils.sheet_to_html(v),              &#125;);            &#125;            <span class="hljs-keyword">return</span> draftState;          &#125;);          setData(newData);        &#125;      &#125;);    &#125;  &#125;, [src]);  <span class="hljs-keyword">return</span> (    &lt;div &#123;...rest&#125;&gt;      &#123;data ? (        &lt;Tabs          tabPanes=&#123;data.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> (&#123;            id: index,            title: item.name,            content: (              &lt;div className=&#123;styles.excel&#125; dangerouslySetInnerHTML=&#123;&#123; <span class="hljs-attr">__html</span>: item.html &#125;&#125; /&gt;            ),          &#125;))&#125;        /&gt;      ) : (        &lt;Spin style=&#123;&#123; <span class="hljs-attr">display</span>: <span class="hljs-string">'block'</span>, <span class="hljs-attr">margin</span>: <span class="hljs-string">'0 auto'</span> &#125;&#125; /&gt;      )&#125;    &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">  );</span><span class="hljs-regexp">&#125;;</span><span class="hljs-regexp"></span><span class="hljs-regexp">Index.displayName = 'ExcelViewer';</span><span class="hljs-regexp">export default Index;</span></code></pre><p><em>几个重点：</em></p><ol><li>xlsx 方法的使用</li><li>immer 的使用</li><li>Object.entries()方法的使用</li><li>dangerouslySetInnerHTML 的使用</li></ol><p>Object.entries() 可以把一个对象的键值以数组的形式遍历出来，结果和 for…in 一致，但不会遍历原型属性。</p><pre><code class="hljs prolog">const arr1 = [&#123; a: <span class="hljs-number">1</span> &#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];console.log(<span class="hljs-symbol">Object</span>.entries(arr1));  // [[<span class="hljs-string">'0'</span>, &#123; a: <span class="hljs-number">1</span> &#125;], [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>], [<span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>]]const arr2 = [&#123; a: <span class="hljs-number">1</span> &#125;, &#123; b: <span class="hljs-number">2</span> &#125;, &#123; c: <span class="hljs-number">3</span> &#125;];console.log(<span class="hljs-symbol">Object</span>.entries(arr2));  // [[<span class="hljs-string">'0'</span>, &#123; a: <span class="hljs-number">1</span> &#125;], [<span class="hljs-string">'1'</span>, &#123; b: <span class="hljs-number">2</span> &#125;], [<span class="hljs-string">'2'</span>, &#123; c: <span class="hljs-number">3</span> &#125;]]</code></pre><p>在 react 中，展示富文本 ，字符串的方法，注意用法！</p><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> dangerouslySetInnerHTML=&#123;&#123; __html: '&lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">123</span>&lt;/<span class="hljs-keyword">div</span>&gt;' &#125;&#125; /&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>预览excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读少有人走的路</title>
    <link href="/2020/08/02/essay0802/"/>
    <url>/2020/08/02/essay0802/</url>
    
    <content type="html"><![CDATA[<p>这是一系列书，现在在读第 4 本《在焦虑的年代获得精神的成长》</p><p>心智成熟的旅程 ——自律，自信<br>勇敢的面对谎言 ——谎言是邪恶的根源<br>与心灵对话 ——人生错综复杂<br>这本书 ——人生没有简单的答案</p><p>所以下面的内容先是第 4 本内容，至于前面几本书写不写，看我心情吧～<br>这本是斯科特*派克在 60 岁的时候写的，相比之下我还是更喜欢他 40 岁写的第一本书叫《心智成熟的旅程》</p><blockquote><p>自我和灵魂常处于交战状态，自我需要拥有，拥有的越多越好，而灵魂需要放弃，放弃的越多越自由。所以前半生要追寻自我，后半生则要放下自我，追随灵魂。</p></blockquote><p>我们喋喋不休，说东道西，<br>却仍旧孤独<br>活着却孤独<br>归宿<br>在哪里？</p><blockquote><p>那些听不见音乐的人认为那些跳舞的人都疯了 ——— 尼采</p></blockquote><p>冲突：利益 偏见</p><blockquote><p>许多人宁愿死，也不愿意思考，事实上他们也确实至死都没有思考过 ——— 罗素</p></blockquote><p>草率思考和盲从心理<br>先入为主与贴标签<br>认为自己无所不知，无所不能，其实才是最大的蠢货。</p><p>自我才有自尊 灵魂没有自尊</p><p>思考最忌讳的是草率，倾听最忌讳的是分心。</p>]]></content>
    
    
    <categories>
      
      <category>读书心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>少有人走的路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读你不知道的javascript</title>
    <link href="/2020/07/30/javascript/"/>
    <url>/2020/07/30/javascript/</url>
    
    <content type="html"><![CDATA[<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是能够储存变量当中的值，并且能在之后对这个 值进行访问或修改。</p><h4 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h4><ul><li>引擎</li></ul><p>从头到尾负责整个 javascript 程序的变异及执行过程</p><ul><li>编译器</li></ul><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活</p><ul><li>作用域</li></ul><p>引擎的另一个好朋友，负责手机并且维护由所有生命的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对撰写标识符的访问权限。</p><p>举个栗子 🌰</p><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(a)</span> <span class="hljs-comment">&#123; console.log( a ); // 2</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">( 2 )</span>;</span></code></pre><p>引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?<br>作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎:哥们太够意思了!好吧，我来执行一下 foo。<br>引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?<br>作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。<br>引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。<br>引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?<br>作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。<br>引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。<br>引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。<br>作用域:放心吧，这个变量没有变动过，拿走，不谢。<br>引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。<br>……</p><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span></code></pre><ol><li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li><li>接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li></ol><p>块级作用域<br>try catch 语句里面 catch 部分是块级作用域<br>let 可以在任意作用域中，通常是函数内部。可以当做块级变量～但是没有声明提升<br>const 也一样</p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>包括变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。</p><p>当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个 声明:var a;和 a = 2;。<br>第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。</p><p>声明变量提升</p><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><pre><code class="hljs javascript">foo(); <span class="hljs-comment">// 1</span><span class="hljs-keyword">var</span> foo;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );&#125;foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );&#125;;<span class="hljs-comment">// 会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );&#125;foo(); <span class="hljs-comment">// 1</span>foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );&#125;;</code></pre><p><strong>小结：</strong><br>我们习惯将 var a = 2;看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a<br>和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的 最顶端，这个过程被称为提升。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>为什么用 this。 简洁 ，复用性好</p><p>我觉得关于 this 真的没什么好总结的，就一句话就完事：<br>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>说实在的 这玩意我在红宝书里看过的</p><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">myObject</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span> <span class="hljs-string">a:2</span><span class="hljs-string">&#125;;</span>     <span class="hljs-string">Object.getOwnPropertyDescriptor(</span> <span class="hljs-string">myObject,</span> <span class="hljs-string">"a"</span> <span class="hljs-string">);</span>     <span class="hljs-string">//</span> <span class="hljs-string">&#123;</span><span class="hljs-string">//</span> <span class="hljs-attr">value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span><span class="hljs-string">//</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span><span class="hljs-string">//</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span><span class="hljs-string">//</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span> <span class="hljs-string">//</span> <span class="hljs-string">&#125;</span><span class="hljs-string">var</span> <span class="hljs-string">myObject</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;&#125;;</span>     <span class="hljs-string">Object.defineProperty(</span> <span class="hljs-string">myObject,</span> <span class="hljs-string">"a"</span><span class="hljs-string">,</span> <span class="hljs-string">&#123;</span>         <span class="hljs-attr">value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span><span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span>     <span class="hljs-string">&#125;</span> <span class="hljs-string">);</span>     <span class="hljs-string">myObject.a;</span> <span class="hljs-string">//</span> <span class="hljs-number">2</span><span class="hljs-string">//</span>  <span class="hljs-string">禁止一个对象添加新属性并且保留已有属性</span>        <span class="hljs-string">Object.preventExtensions(</span> <span class="hljs-string">myObject</span> <span class="hljs-string">);</span>     <span class="hljs-string">myObject.b</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span><span class="hljs-string">;</span>     <span class="hljs-string">myObject.b;</span> <span class="hljs-string">//</span> <span class="hljs-string">undefined</span></code></pre><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false</p><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>药</title>
    <link href="/2020/07/14/essay0714/"/>
    <url>/2020/07/14/essay0714/</url>
    
    <content type="html"><![CDATA[<p>药医不死病，死病无药医。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020全国2卷作文随笔</title>
    <link href="/2020/07/07/essay0707/"/>
    <url>/2020/07/07/essay0707/</url>
    
    <content type="html"><![CDATA[<p>全国 Ⅱ 卷作文解析+阅读下面的材料，根据要求写作。<br>墨子说：“视人之国，若视其国；视人之家，若视其家；视人之身，若视其身。”<br>英国诗人约翰多恩说：“没有人是自成一体、与世隔绝的孤岛，每一个人都是广袤大陆的一部分。”<br>“青山一道同云雨，明月何曾是两乡。”“同气连枝，共盼春来。”……2020 年的春天，这些寄言印在国际社会援助中国的物资上，表达了世界人民对中国的支持。<br>“山和山不相遇，人和人要相逢。”“消失吧，黑夜！黎明时我们将获胜！”……这些话语印在中国援助其他国家的物资上，寄托着中国人民对世界的祝福。<br>“世界青年与社会发展论坛”邀请你作为中国青年代表参会，发表以“携手同一世界，青年共创未来”为主题的中文演讲。请完成一篇演讲稿。<br>要求：结合材料内容及含意完成写作任务；选好角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于 800 字。</p><p>2020 年的全国 2 卷作文，看完这个并没有想写作文的冲动。<br>不过我喜欢这句 山和山不相遇，人和人要相逢</p><p>山和山不会相遇吗？<br>你可曾看过连绵的山脉，<br>那一山挨着一山，<br>就好比一山爱着一山，<br>还可能有很多小山，哈哈<br>这世界上有很多山啊，天生就是在一起的<br>相互依偎，不曾分离，坚定的心就像石头一样。<br>奥对，山，本来就是石头。<br>坚定的石头的心，守在身边一动不动<br>主要它想动也没办法啊<br>它没有腿啊<br>哈哈哈哈哈哈哈哈<br>其实严谨来说啊<br>那些连绵依偎的山<br>也不是天生就在一起的<br>只不过从我的生命周期来说<br>从我的生到死的时间里<br>在一起的山脉还是在一起<br>多好<br>多让人羡慕<br>但是地球板块是会移动的鸭<br>在一起的山脉<br>在板块移动过程中<br>可能会拥抱的更加紧密<br>也可能会默默分离<br>不在一起的山<br>也可能一步步的靠近<br>我喜欢那一座山<br>我要走去它那里<br>只要是有一颗愿意接近的心<br>我的每一步<br>每一厘米<br>就都有意义<br>然后<br>在相遇的那一刻<br>谁还在乎是不是已经天荒地老<br>谁还在乎经历了多少春秋更替<br>就在那一刻<br>它们拉住彼此的手<br>都会产生一种异常激动的情绪<br>用了三千万年<br>终于来到了这里<br>怎么他妈的你也是个男的！</p><p>人和人需要相逢吗<br>需要<br>我需要你<br>这世界的每一个人你听好<br>我需要你<br>你来吧<br>来跟我相逢吧<br>我在<br>北纬 41°48′11.75″<br>东经 123°25′31.18<br>你来吧<br>来跟我相逢吧<br>见面记得给我一块钱<br>如果每个人都给我一块钱<br>那我就能买点肉留着过年<br>奥对了<br>路费火车票啥的我可不报销</p><p>相逢这个字眼<br>总是能给人憧憬或者希望<br>在对未知的好奇和幻想中<br>莫名的就对相逢这件事产生了好感<br>不过比起相逢<br>我更喜欢重逢<br>经历分离<br>经历时间<br>经历别人<br>经历了很多以后<br>还是想再见你<br>如果刚好你也这样想<br>那重逢对于我们就有了意义<br>也许是儿时嬉戏的玩伴<br>也许是一生所爱的情人<br>也许是刀山火海的兄弟<br>也许是阴阳两隔的亲人<br>让我们重逢吧！<br>让我们重逢吧。<br>我会告诉你我有多么的想你<br>一个字一个字的说给你听<br>在你的耳边<br>或者<br>在我的梦里</p><p>山和山也许相遇<br>人和人未必相逢<br>如果有幸曾与你相逢<br>那就让我们重逢吧<br>火车票我会给你报了</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>读深入浅出React和Redux</title>
    <link href="/2020/07/06/reactandredux/"/>
    <url>/2020/07/06/reactandredux/</url>
    
    <content type="html"><![CDATA[<p>开始读书～<br>程墨编著<br>下面的内容比较随性，暂时自己写给自己看的，不建议阅读。</p><ul><li>react 不支持 ie8 以下</li></ul><p>“scripts”:{<br>“start”:”react-scripts start”,</p><p>“eject”:”react-scripts eject”<br>}</p><p>eject 弹射<br>会把潜藏在 react-scripts 重的一系列技术栈配置都弹射到应用的顶层。<br>然后我们就可以研究这些配置细节了，而且可以更灵活的定制应用的配置。<br>⚠️ 注意啊 eject 命令不可逆 ，在执行 npm run eject 之前最好备份一下。</p><hr><p>如果用 jq 写组件，<br>先写个 index.html<br>然后写 html dom 节点 然后是 js 绑定点击逻辑啥的<br>jq 会让事件和 dom 造成纠缠代码结构</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="react-总结公式为"><a href="#react-总结公式为" class="headerlink" title="react 总结公式为"></a>react 总结公式为</h3><p>UI = render（data）<br>响应式编程 （Reactive programming）<br>一看这个名字，就知道为啥 react 框架名字的由来了</p><h3 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h3><p>说是第五章具体说虚拟 dom</p><h3 id="设计高质量的-React-组件"><a href="#设计高质量的-React-组件" class="headerlink" title="设计高质量的 React 组件"></a>设计高质量的 React 组件</h3><h4 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h4><p>把问题分解为多个小问题，必要的时候可以拆分大组件，分为小组件。<br>组件划分要满足 高内聚 低耦合</p><blockquote><p>高内聚 ：把逻辑紧密的内容放在一个组件中<br>低耦合 ：不同组件之间的依赖关系要尽量弱化</p></blockquote><h4 id="state-props"><a href="#state-props" class="headerlink" title="state props"></a>state props</h4><p>对外用 props<br>内部用 state</p><h5 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h5><p>counter(这是个组件名).proptypes = {<br>a:PropTypes.string.isRequired<br>B:PropTypes.number<br>}</p><p>规定了 a 属性这个必须是字符串类型，并且必须有值，不能 undefined 啥的<br>但是这个 B 因为没有 isRequired 所以没有 B 也无所谓</p><p>这个 propTypes 是个辅助开发的功能，可以不写的<br>如果写了这玩意，要在产品上线发布的时候，用 babel-react-optimize 去掉这个东西，理由如下：</p><ol><li>占用代码空间</li><li>消耗 cpu 计算资源</li><li>对用户输出报错无意义</li></ol><h5 id="state-不用-setState-方法"><a href="#state-不用-setState-方法" class="headerlink" title="state 不用 setState 方法"></a>state 不用 setState 方法</h5><p>如果不用这个方法，会野蛮的修改 state 的值，不过并不会触发驱动组件更新。所以页面上没有效果。</p><h5 id="不要直接修改传染源的-props-对象的值"><a href="#不要直接修改传染源的-props-对象的值" class="headerlink" title="不要直接修改传染源的 props 对象的值"></a>不要直接修改传染源的 props 对象的值</h5><p>如果一个子组件改了 props 的值，其他子组件就会陷入程序混乱了。所以不行不允许这样处理</p><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><h4 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h4><p>constructon<br>getInitalState<br>getDefaultProps<br>componentWillMount<br>render<br>componentDidMount</p><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>使用这个适用于下面目的：</p><ul><li>初始化 state</li><li>绑定成员函数的 this 环境</li></ul><p>this.onClickButton = this.onClickButton.bind(this)</p><p>这样写，会用过 bind 方法，让当前实例中 onClickButton 函数被调用的时候，this 指向始终都是当前组件实例。</p><p>this.foo = ::this.foo;<br>等同于：<br>this.foo = this.foo.bind(this);<br>这里:: 两个冒号的操作符叫做 bind 操作符。<br>不知道是不是 ES 标准语法，暂时不推荐使用</p><h5 id="render"><a href="#render" class="headerlink" title="render"></a>render</h5><p>render 函数只是返回一个 JSX 描述的结构，最终由 React 来操作渲染的过程<br>render 函数应该是一个纯函数，不要产生任何的副作用，<br>在 render 函数中去调用 this.setState 是错误的，因为一个纯函数不应该引起状态的改变</p><h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h5><p>render 调用完以后，componentDidmount 并不会被立刻调用，当他调用的时候，render 函数返回的东西已经引发了渲染，<br>组件已经被“装载”到 DOM 树上。<br>render 函数本身并不王 DOM 树上渲染或者装载内容，它只是返回一个 JSX 对象，然后由 React 库决定如何渲染。<br>而 React 库要把所有的组件都返回结果综合起来以后，才能做出对应 dom 修改，所以，在所有组件都 render 完事了以后，<br>才会开始进行调用各个组件的 componentDidMount<br>componentDidMount 只在浏览器端执行</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><p>componentWillReceiveProps<br>shouldComponentUpdate<br>componentWillUpdate<br>render<br>componentDidUpdate</p><h5 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h5><p>只要是副组件的 render 被调用，在 render 里渲染的子组件就会经历更新的过程，逗号<br>不管父组件传给子组件的 props 有没有改变，都会触发上面这个生命生命周期<br>⚠️ 注意：子组件内通过 this.setState 方法触发的更新过程不会调用这个函数。理由如下：<br>这个生命周期函数适合根据新的 props 值，也就是参数 nextProps 来计算出是不是要更新内部状态 state，<br>更新组件内部方法就是 this.setState，如果 setState 会导致这个生命周期调用，就死循环了鸭</p><h5 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)"></a>shouldComponentUpdate(nextProps,nextState)</h5><p>决定一个组件什么时候不需要渲染<br>和 render 是 React 生命周期中唯二要求有返回结果的函数；<br>这个函数要返回一个布尔值，告诉 React 这个组件这次是否要继续更新</p><pre><code class="hljs kotlin">shouldComponentUpdata(nextProps,nextStates)&#123;  <span class="hljs-keyword">return</span> (nextProps.caption !== <span class="hljs-keyword">this</span>.props.Caption) ||   (nextState.count !== <span class="hljs-keyword">this</span>.state.count)&#125;</code></pre><h4 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h4><h5 id="conponentWillUnmount"><a href="#conponentWillUnmount" class="headerlink" title="conponentWillUnmount"></a>conponentWillUnmount</h5><p>conponentWillUnmount 往往与 componnetDidMount 有关，比如用了非 React 的方法创造了一些 DOM 元素，<br>如果不管理的话会可能造成内存泄漏，就需要在这里处理掉</p><h3 id="state-和-prop-的局限"><a href="#state-和-prop-的局限" class="headerlink" title="state 和 prop 的局限"></a>state 和 prop 的局限</h3><ol><li>父组件 子组件 孙子组件什么的会有重复的数据</li><li>包含 3 级或者以上的组件结构，可能中间那一层根本就用不上这个 prop，但是却还要传递<blockquote><p>简称为数据的冗余和重复</p></blockquote></li></ol><h2 id="从-Flux-到-Redux"><a href="#从-Flux-到-Redux" class="headerlink" title="从 Flux 到 Redux"></a>从 Flux 到 Redux</h2><h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p>单向数据流</p><h4 id="MVC-框架的缺陷"><a href="#MVC-框架的缺陷" class="headerlink" title="MVC 框架的缺陷"></a>MVC 框架的缺陷</h4><p>Model 模型 大部分业务逻辑应该放在这里<br>View 视图 这里应该尽量避免业务逻辑<br>Controller 控制器 负责接受用户输入，根据用户输入调用对应的 Model 逻辑，产生的结果给 View 层</p><p>但是各个不用模块之间的依赖关系让系统变得脆弱且不可预测<br>model 和 view 之间的通信让局面变得烂七八糟</p><p>所以就整出这个 Flux<br>action 到 dispatch 到 store 到 view<br>view 通过 action 调用 dispatch</p><p>存在于 Flux 框架中的 React 组件需要实现以下功能：</p><ul><li>创建时要读取 Store 上的状态来初始化组件内部形态</li><li>当 Store 上状态发生变化的时候，组件要立刻同步更新内部状态保持一致</li><li>view 如果要改变 Store 状态，必须且只能派发 action</li></ul><h4 id="Flux-的不足"><a href="#Flux-的不足" class="headerlink" title="Flux 的不足"></a>Flux 的不足</h4><ul><li>在 Flux 体系中，如果两个 Store 之间有逻辑依赖关系，就必须用上 Dispatcher 的 waitFor 函数。依赖关系处理不够优雅</li><li>难以进行服务器端的渲染</li><li>stroe 混杂了逻辑和状态</li></ul><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>redux 是 flux 的一种实现。</p><p>redux 的基本原则</p><ul><li>唯一数据源<br>应用的状态数据置存储在唯一的一个 store 上</li><li>保持状态只读<br>要修改 store 状态，必须通过派发一个 action 对象完成。但是改变状态的方法不是去修改状态上的值，而是创建一个新的状态对象返回给 Redux</li><li>数据改变只能通过纯函数完成<br>reducer 必须是纯函数<br>reducer 只负责计算状态，不负责存储状态。</li></ul><h4 id="redux-实例"><a href="#redux-实例" class="headerlink" title="redux 实例"></a>redux 实例</h4><p>我们创造一个 src/Store.js 文件，这个文件输出全局唯一的那个 Store，代码如下:</p><pre><code class="hljs routeros">import &#123;createStore&#125; <span class="hljs-keyword">from</span> ’redux’import reducer <span class="hljs-keyword">from</span> ’. /Reducer.js ’;const initValues = &#123; ’First’: 0, ’Second’: 10, ’Third’: 20 &#125;const store= createStore (reducer, initValues);<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>store;</code></pre><p>想记点什么 又无从下手 。。这段知识，，，我不知道怎么表达</p><p>在 redux 框架下，一个 react 组件基本上就是要完成以下：</p><ol><li>和 redux store 打交道，读取 store 状态，用于初始化组件的状态，同时还要监听 store 的状态改变<br>当 store 状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新 store 状态时，就要派发 action 对象</li><li>根据当前 props 和 state，渲染出用户界面。</li></ol><p>所以把 react 组件拆分为两个，第一个组件负责跟 redux store 打交道，处于外层，称为<strong>容器组件</strong> （聪明组件）<br>负责渲染界面的组件在内层，称为<strong>展示组件</strong> （傻瓜组件）</p><h4 id="组件-Context"><a href="#组件-Context" class="headerlink" title="组件 Context"></a>组件 Context</h4><p>上下文环境<br>搜先上级组件要宣称自己支持 context，并且提供一个函数来返回代表 Context 的 对象<br>然后，这个上级组件之下的所有子孙组件，只要宣称自己需要这个 context，就可以 通过 this.context 访问到这个共同的环境对象。</p><h4 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h4><pre><code class="hljs scala"><span class="hljs-keyword">import</span> &#123;<span class="hljs-type">PropTypes</span>, <span class="hljs-type">Component</span>&#125; from ’react’;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123; getChildContext&#123;) &#123;<span class="hljs-keyword">return</span> &#123;store: <span class="hljs-keyword">this</span>.props.storerender() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.children;  &#125;&#125;</code></pre><p>就是在每个组件外层都套上</p><pre><code class="hljs apache"><span class="hljs-section">&lt;Provider&gt;</span>  <span class="hljs-section">&lt;Children/&gt;</span><span class="hljs-section">&lt;/Provider&gt;</span></code></pre><p>除了吧渲染工作完全交给子组件，Provider 还要提供一个函数 getChildContext ，这个函数返回的就是代表 Context 的对象。<br>为了让 Provider 能够被 React 认可为一个 Context 的提供者，还需要指定 Provider 的 childContextTypes 属性， 代码如下:</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Provider</span>.</span></span>childContextTypes = &#123;   store: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropTypes</span>.</span></span>ob]ect&#125;</code></pre><p>Provider 只是把渲染工作完全交给子组件，它扮演的角色只是提供 Context，包住了最顶层的 组件，也就让 context 覆盖了整个应用中所有组件。</p><p>为了让 CounterContainer 能够访问到 context，必须给 CounterContainer 类的 context­<br>Types 赋值和 Provider.childContextTypes 一样的值，两者必须一致，不然就无法访问到 context，代码如下:<br><code>CounterContainer.contextTypes = { store: PropTypes.。bject</code><br>在 CounterContainer 中，所有对 store 的访问，都是通过 this.context.store 完成，因 为 this.context 就是 Provider 提供的 context 对象，所以 getOwnState 函数代码如下:</p><pre><code class="hljs kotlin">getOwnState() &#123;  <span class="hljs-keyword">return</span> &#123;    value: <span class="hljs-keyword">this</span> .context. store .getState () [<span class="hljs-keyword">this</span>. props .caption]  &#125;&#125;</code></pre><p>还有一点，因为我们自己定义了构造函数，所以要用上第二个参数 context，代码<br>如下:<br>constructor (props, context) { super(props, context);<br>在调用 super 的时候，一定要带上 context 参数，这样才能让 React 组件初始化实例<br>中的 context，不然组件的其他部分就无法使用 this.context。</p><h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><p>connect : 链接容器组件和傻瓜组件，<br>把 store 伤的状态转化为内层傻瓜组件的 prop，把内层傻瓜组件中的用户动作转化为派送给 store 的动作</p><p>Provider：提供包含 store 的 context</p><hr><p>export default connect(mapStateToProps, mapDispatchToProps) (Cunter)</p><p>一个状态节点只属于一个模块，这里的“拥有权”指的是“修改权”，而不是“读取权”，<br>实际上，Redux Store 上的全部状态，在任何时候，对任何模块都是可以读取的，但是更新修改只能上跟自己相关的那一部分模块的数据</p><p>在设计 redux store 的状态树时，要尽量保持树形结构的扁平。一个很复杂的状态树是难以管理的。</p><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><h4 id="操纵-prop"><a href="#操纵-prop" class="headerlink" title="操纵 prop"></a>操纵 prop</h4><p>高阶组件可以增减/删除/修改传递给包裹组件的 props 列表</p><pre><code class="hljs scala">const addNewProps = (<span class="hljs-type">WrappedComponent</span>, newProps) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrappingComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    render()&#123;      <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">WrappedComponent</span> &#123;...<span class="hljs-keyword">this</span>.props&#125; &#123;...newProps &#125;&gt;    &#125;  &#125;&#125;</code></pre><h4 id="访问-ref"><a href="#访问-ref" class="headerlink" title="访问 ref"></a>访问 ref</h4><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> refsHOC =(WrappedComponent) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOCComponent</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>()&#123;      <span class="hljs-keyword">super</span>(...arguments)      <span class="hljs-keyword">this</span>.linkRef = <span class="hljs-keyword">this</span>.linkRef.bind(<span class="hljs-keyword">this</span>)    &#125;    linkRef(wrappedInstance)&#123;      <span class="hljs-keyword">this</span>._root = wrappedInstance;    &#125;    render()&#123;      <span class="hljs-keyword">const</span> props = &#123;...<span class="hljs-keyword">this</span>.props, ref: <span class="hljs-keyword">this</span>.linkRef&#125;      <span class="hljs-keyword">return</span> &lt;WrappedComponent &#123;...props&#125;&gt;    &#125;  &#125;&#125;</code></pre><h4 id="抽取状态"><a href="#抽取状态" class="headerlink" title="抽取状态"></a>抽取状态</h4><p>比如 react-redux 的 connect 函数<br>在傻瓜组件通常不要管理自己的状态，所有状态的管理都交给外面 的容器组件，这个模式就是“抽取状态”</p><pre><code class="hljs scala">const doNothing = () =&gt; (&#123;&#125;);function connect(mapStateToProps=doNothing,mapDispatchToProps=doNothing)&#123;  <span class="hljs-keyword">return</span> function(<span class="hljs-type">WrappedComponent</span>)&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOCComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;      <span class="hljs-comment">// 在这里定义HOCComponent的生命周期函数</span>    &#125;    <span class="hljs-type">HOCComponent</span>.contextTypes = &#123;      store: <span class="hljs-type">React</span>.<span class="hljs-type">PropTypes</span><span class="hljs-class">.<span class="hljs-keyword">object</span></span><span class="hljs-class">    &#125;</span><span class="hljs-class">    <span class="hljs-title">return</span> <span class="hljs-title">HOCComponent</span></span>;  &#125;&#125;</code></pre><h4 id="包装组件"><a href="#包装组件" class="headerlink" title="包装组件"></a>包装组件</h4><pre><code class="hljs scala">const styleHOC = (<span class="hljs-type">WrappedComponent</span>, style) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOCComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    render()&#123;      <span class="hljs-keyword">return</span> (        &lt;div style=&#123;style&#125;&gt;          &lt;<span class="hljs-type">WrappedComponent</span> &#123;...<span class="hljs-keyword">this</span>.props&#125;&gt;        &lt;/div&gt;      )    &#125;  &#125;&#125;</code></pre><h3 id="继承方式的高阶组件"><a href="#继承方式的高阶组件" class="headerlink" title="继承方式的高阶组件"></a>继承方式的高阶组件</h3><p>暂时不理解 ，不写了</p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>polyfill 指的是“用于实现浏览器不支持原生功能的代码”，比如，现代浏览器应<br>该支持 fetch 函数，对于不支持的浏览器，网页中引入对应 fetch 的 polyfill 后， 这个 polyfill 就给全局的 window 对象上增加一个 fetch 函数，让这个网页中的 JavaScript 可以直接使用 fetch 函数了，就好像浏览器本来就支持 fetch 一样 。 在 这个链接上<a href="https://github.com/github/fetch可以找到fetchpolyfill的一个实现。" target="_blank" rel="noopener">https://github.com/github/fetch可以找到fetchpolyfill的一个实现。</a></p><p>react 你本地调试的时候,你直接请求接口肯定是跨域了，你的网页应用域名 localhost，你对应的服务器域名也是这玩意，所以你跨域啊<br>但是不慌，creat react app 有代理功能 proxy （来跟我发音，抛克西）</p><p>creat react-app 陌生成应用的 proxy 功能只是方便开发，在实际的生产环境中，使<br>用这个 proxy 功能就不合适了，应该要开发出自己的代理服务器来满足生产环境 的需要 。</p><h4 id="redux-thunk-中间件"><a href="#redux-thunk-中间件" class="headerlink" title="redux-thunk 中间件"></a>redux-thunk 中间件</h4><p>在 reducer 调用前调用的玩意儿<br>action =&gt; 中间件（比如 thunk）=&gt; reducer =&gt; state</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单测有一堆框架。<br>看了一遍。。。还是不想写单测</p><h3 id="扩展-REDUX"><a href="#扩展-REDUX" class="headerlink" title="扩展 REDUX"></a>扩展 REDUX</h3><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-react -redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http请求方方面面安排一波</title>
    <link href="/2020/07/01/request/"/>
    <url>/2020/07/01/request/</url>
    
    <content type="html"><![CDATA[<p>前言：下边的内容是从 XMLHttpRequest，到封装 XMLHttpRequest，再到 axios。<br>弄了很久啊，查资料，查官网信息，整理各种文档，输出各种观点。巨佬们慢慢看吧～</p><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="-XMLHttpRequest"></a>-XMLHttpRequest</h2><p>XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。<br>咱们硬核一点，直接上代码</p><h4 id="简单例子-🌰"><a href="#简单例子-🌰" class="headerlink" title="简单例子 🌰"></a>简单例子 🌰</h4><pre><code class="hljs pgsql">let xhr = <span class="hljs-built_in">new</span> XMLHttpRequest();xhr.<span class="hljs-keyword">open</span>(<span class="hljs-string">'GET'</span>,<span class="hljs-string">'https://www.baidu.com'</span>,<span class="hljs-keyword">true</span>,username,<span class="hljs-keyword">password</span>); // 解释一下参数。<span class="hljs-keyword">GET</span>释请求方法，必须得有，http请求方法有很多，常用post/<span class="hljs-keyword">get</span> ，这里的参数写法不区分大小写，写成‘<span class="hljs-keyword">get</span>’也是可以的。 // 第二个参数是请求的url，必须得有。 // 第三个参数这里的<span class="hljs-keyword">true</span> 代表是否异步 ，如果是<span class="hljs-keyword">true</span>就异步，<span class="hljs-keyword">false</span>就同步 。默认为异步。 // username：可选参数，如果服务器需要验证，该参数指定用户名，如果未指定，当服务器需要验证时，会弹出验证窗口。 // <span class="hljs-keyword">password</span>：可选参数，验证信息中的密码部分，如果用户名为空，则该值将被忽略。xhr.send(body) // body是通过该请求发送的参数数据啥的，不传就不用填写。</code></pre><p>这里插播一下请求失败的错误码，想了一下，还是放在这篇文里边吧，反正发请求就会有请求失败的可能嘛。<br>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。常见状态代码、状态描述的说明如下。<br>200 OK：客户端请求成功。<br>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。<br>401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。<br>403 Forbidden：服务器收到请求，但是拒绝提供服务。<br>404 Not Found：请求资源不存在，举个例子：输入了错误的 URL。<br>500 Internal Server Error：服务器发生不可预期的错误。<br>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</p><p><strong>通常报 400 多的时候，咱们前端就偷偷自己找找原因，报 500 多的时候，直接找后端就行。</strong></p><p>上边是个简单的栗子 🌰，让我们一点一点的往上加东西～</p><h3 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.open(<span class="hljs-string">'GET'</span>,<span class="hljs-string">'https://www.baidu.com'</span>,<span class="hljs-literal">true</span>,username,password);xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.readyState === <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-keyword">this</span>.status === <span class="hljs-string">'200'</span>)&#123;    <span class="hljs-comment">// 这里this就是xhr this.readyState 就是 xhr.readyState</span>    <span class="hljs-keyword">do</span> something  &#125;&#125;xhr.send(body)</code></pre><p>这个栗子里 xhr 多了一个属性 onreadystatechange 。onreadystatechange 是一个事件句柄。后边是事件触发的回调函数。当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。状态从 0 (uninitialized) 到 4 (complete) 进行变化。仅在状态为 4 时，我们才执行代码。</p><p><em>补充一下 readyState 的知识，看看知道有这么个事就行。</em><br><em>0 未初始化。表示对象已经建立，但是尚未初始化，尚未调用 open() 方法</em><br><em>1 初始化。表示对象已经建立，尚未调用 send() 方法</em><br><em>2 发送数据。表示 send() 方法已经调用，但是当前的状态及 HTTP 头未知</em><br><em>3 数据传送中。已经接收部分数据，因为响应及 HTTP 头不安全，这时通过 responseBody 和 responseText 获取部分数据会出现错误</em><br><em>4 完成。数据接收完毕，此时可以通过 responseBody 和 responseText 获取完整的响应数据</em></p><h3 id="如何设置-request-header"><a href="#如何设置-request-header" class="headerlink" title="如何设置 request header"></a>如何设置 request header</h3><p>setRequestHeader(name, value)</p><p>name 参数是要设置的头部的名称。这个参数不应该包括空白、冒号或换行。<br>value 参数是头部的值。这个参数不应该包括换行。</p><pre><code class="hljs vhdl">let xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.<span class="hljs-keyword">open</span>(<span class="hljs-symbol">'GET</span>',<span class="hljs-symbol">'https</span>://www.baidu.com',<span class="hljs-literal">true</span>,username,password);xhr.setRequestHeader(<span class="hljs-symbol">'Content</span>-<span class="hljs-keyword">Type</span>', <span class="hljs-symbol">'one</span>');xhr.setRequestHeader(<span class="hljs-symbol">'Content</span>-<span class="hljs-keyword">Type</span>', <span class="hljs-symbol">'two</span>');// 最终request header中<span class="hljs-string">"Content-Type"</span>为: one, twoxhr.send(<span class="hljs-keyword">body</span>)</code></pre><p>方法的第一个参数 header 大小写不敏感，即可以写成 content-type，也可以写成 Content-Type，甚至写成 content-Type。</p><p>Content-Type 的默认值与具体发送的数据类型有关。</p><p>setRequestHeader 必须在 open()方法之后，send()方法之前调用，否则会抛错。</p><p>setRequestHeader 可以调用多次，最终的值不会采用覆盖 override 的方式，而是采用追加 append 的方式。</p><h3 id="如何指定-xhr-response-的数据类型"><a href="#如何指定-xhr-response-的数据类型" class="headerlink" title="如何指定 xhr.response 的数据类型"></a>如何指定 xhr.response 的数据类型</h3><p>xhr.overrideMimeType(‘text/plain; charset=utf-8’) // xhr level 1 使用的方法。</p><p>xhr.responseType = ‘blob’ // xhr level 2 可以用的，比上面简单很多，但是说是兼容性稍微差一点点。不过我没发现过任何问题，推荐用下边的写法</p><h3 id="如何设置请求的超时时间"><a href="#如何设置请求的超时时间" class="headerlink" title="如何设置请求的超时时间"></a>如何设置请求的超时时间</h3><p>如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest 提供了 timeout 属性来允许设置请求的超时时间。<br>xhr.timeout = 0<br>单位：milliseconds 毫秒<br>默认值：0，即不设置超时</p><p>⚠️ 注意：<strong>当 xhr 为一个 sync 同步请求时</strong>，xhr.timeout 必须置为 0，否则会抛错。并且 xhr.withCredentials 必须为 false</p><p>xhr.responseType 必须为””（注意置为”text”也不允许）</p><h3 id="如何获取上传、下载的进度"><a href="#如何获取上传、下载的进度" class="headerlink" title="如何获取上传、下载的进度"></a>如何获取上传、下载的进度</h3><p>在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。<br>我们可以通过 onprogress 事件来实时显示进度，默认情况下这个事件每 50ms 触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的 onprogress 事件：</p><p>上传触发的是 xhr.upload 对象的 onprogress 事件</p><p>下载触发的是 xhr 对象的 onprogress 事件</p><pre><code class="hljs cs">xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;<span class="hljs-function">function <span class="hljs-title">updateProgress</span>(<span class="hljs-params"><span class="hljs-keyword">event</span></span>)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.lengthComputable) &#123;      <span class="hljs-keyword">var</span> completedPercent = <span class="hljs-keyword">event</span>.loaded / <span class="hljs-keyword">event</span>.total;    &#125; &#125;</code></pre><h3 id="如何才能中止请求"><a href="#如何才能中止请求" class="headerlink" title="如何才能中止请求"></a>如何才能中止请求</h3><p>xhr.onreadystatechange = function () {}; //清理事件响应函数<br>xhr.abort(); //中止请求</p><p>在调用 abort() 方法前，应先清除 onreadystatechange 事件处理函数，因为 IE 和 Mozilla 在请求中止后也会激活这个事件处理函数。如果给 onreadystatechange 属性设置为 null，则 IE 会发生异常，所以为它设置一个空函数。</p><h3 id="请求成功的回调"><a href="#请求成功的回调" class="headerlink" title="请求成功的回调"></a>请求成功的回调</h3><p>前面写过，就是在 onreadystatechange 判断 readyState == 4 。。。。。去上面看哈<br>当然啦 ，还有一种方法，也是我比较推荐的，</p><pre><code class="hljs lua">xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &#123;   //如果请求成功   <span class="hljs-keyword">if</span>((xhr.<span class="hljs-built_in">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-built_in">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-built_in">status</span> == <span class="hljs-number">304</span>)&#123;     //<span class="hljs-keyword">do</span> successCallback   &#125; &#125;</code></pre><h3 id="比较完整的-http-请求，方便大家用的时候复制粘贴，嘿嘿"><a href="#比较完整的-http-请求，方便大家用的时候复制粘贴，嘿嘿" class="headerlink" title="比较完整的 http 请求，方便大家用的时候复制粘贴，嘿嘿"></a>比较完整的 http 请求，方便大家用的时候复制粘贴，嘿嘿</h3><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<span class="hljs-comment">// 请求成功回调函数</span>xhr.onload = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request success'</span>);&#125;;<span class="hljs-comment">// 请求结束</span>xhr.onloadend = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request loadend'</span>);&#125;;<span class="hljs-comment">// 请求出错</span>xhr.onerror = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request error'</span>);&#125;;<span class="hljs-comment">// 请求超时</span>xhr.ontimeout = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request timeout'</span>);&#125;;<span class="hljs-comment">// 请求回调函数.XMLHttpRequest标准又分为Level 1和Level 2,这是Level 1和的回调处理方式</span><span class="hljs-comment">// xhr.onreadystatechange = () =&gt; &#123;</span><span class="hljs-comment">//  if (xhr.readyState !== 4) &#123;</span><span class="hljs-comment">//  return;</span><span class="hljs-comment">//  &#125;</span><span class="hljs-comment">//  const status = xhr.status;</span><span class="hljs-comment">//  if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status === 304) &#123;</span><span class="hljs-comment">//  console.log('request success');</span><span class="hljs-comment">//  &#125; else &#123;</span><span class="hljs-comment">//  console.log('request error');</span><span class="hljs-comment">//  &#125;</span><span class="hljs-comment">//  &#125;;</span>xhr.timeout = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置超时时间,0表示永不超时</span><span class="hljs-comment">// 初始化请求</span>xhr.open(<span class="hljs-string">'GET/POST/DELETE/...'</span>, <span class="hljs-string">'/url'</span>, <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>);<span class="hljs-comment">// 设置期望的返回数据类型 'json' 'text' 'document' ...</span>xhr.responseType = <span class="hljs-string">''</span>;<span class="hljs-comment">// 设置请求头</span>xhr.setRequestHeader(<span class="hljs-string">''</span>, <span class="hljs-string">''</span>);<span class="hljs-comment">// 发送请求</span>xhr.send(<span class="hljs-literal">null</span> || <span class="hljs-keyword">new</span> FormData || <span class="hljs-string">'a=1&amp;b=2'</span> || <span class="hljs-string">'json字符串'</span>);</code></pre><h2 id="封装-XMLHttpRequest"><a href="#封装-XMLHttpRequest" class="headerlink" title="-封装 XMLHttpRequest"></a>-封装 XMLHttpRequest</h2><h3 id="初步封装"><a href="#初步封装" class="headerlink" title="初步封装"></a>初步封装</h3><p>下面的代码有点多，不爱看可以不看，没什么难点。大体思路我这里告诉你：<br>先写一个默认的请求需要的一些参数啥的，比如默认 get 方法，默认异步请求等。<br>如果是 get 请求，把请求参数放进 url 里面格式为 <a href="https://www.wanghaojvlao.com?wanghao=jvlao&amp;wanghao=shadiao这样" target="_blank" rel="noopener">https://www.wanghaojvlao.com?wanghao=jvlao&amp;wanghao=shadiao这样</a><br>如果是 post，转化请求体中的 date 类型为字符串类型<br>大概思路就是这样，是不是很简单～</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> http = &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * js封装ajax请求</span><span class="hljs-comment">   * &gt;&gt;使用new XMLHttpRequest 创建请求对象,所以不考虑低端IE浏览器(IE6及以下不支持XMLHttpRequest)</span><span class="hljs-comment">   * &gt;&gt;使用es6语法,如果需要在正式环境使用,则可以用babel转换为es5语法 https://babeljs.cn/docs/setup/#installation</span><span class="hljs-comment">   *  @param settings 请求参数模仿jQuery ajax</span><span class="hljs-comment">   *  调用该方法,data参数需要和请求头Content-Type对应</span><span class="hljs-comment">   *  Content-Type                        data                                     描述</span><span class="hljs-comment">   *  application/x-www-form-urlencoded   'name=哈哈&amp;age=12'或&#123;name:'哈哈',age:12&#125;  查询字符串,用&amp;分割</span><span class="hljs-comment">   *  application/json                     name=哈哈&amp;age=12'                        json字符串</span><span class="hljs-comment">   *  multipart/form-data                  new FormData()                           FormData对象,当为FormData类型,不要手动设置Content-Type</span><span class="hljs-comment">   *  注意:请求参数如果包含日期类型.是否能请求成功需要后台接口配合</span><span class="hljs-comment">   */</span>  ajax: <span class="hljs-function">(<span class="hljs-params">settings = &#123;&#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 初始化请求参数</span>    <span class="hljs-keyword">let</span> _s = <span class="hljs-built_in">Object</span>.assign(&#123;      url: <span class="hljs-string">''</span>, <span class="hljs-comment">// string</span>      <span class="hljs-keyword">type</span>: <span class="hljs-string">'GET'</span>, <span class="hljs-comment">// string 'GET' 'POST' 'DELETE'</span>      dataType: <span class="hljs-string">'json'</span>, <span class="hljs-comment">// string 期望的返回数据类型:'json' 'text' 'document' ...</span>      <span class="hljs-keyword">async</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//  boolean true:异步请求 false:同步请求 required</span>      data: <span class="hljs-literal">null</span>, <span class="hljs-comment">// any 请求参数,data需要和请求头Content-Type对应</span>      headers: &#123;&#125;, <span class="hljs-comment">// object 请求头</span>      timeout: <span class="hljs-number">1000</span>, <span class="hljs-comment">// string 超时时间:0表示不设置超时</span>      beforeSend: <span class="hljs-function">(<span class="hljs-params">xhr</span>) =&gt;</span> &#123;      &#125;,      success: <span class="hljs-function">(<span class="hljs-params">result, status, xhr</span>) =&gt;</span> &#123;      &#125;,      error: <span class="hljs-function">(<span class="hljs-params">xhr, status, error</span>) =&gt;</span> &#123;      &#125;,      complete: <span class="hljs-function">(<span class="hljs-params">xhr, status</span>) =&gt;</span> &#123;      &#125;    &#125;, settings);    <span class="hljs-comment">// 参数验证</span>    <span class="hljs-keyword">if</span> (!_s.url || !_s.type || !_s.dataType || !_s.async) &#123;      alert(<span class="hljs-string">'参数有误'</span>);      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 创建XMLHttpRequest请求对象</span>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();    <span class="hljs-comment">// 请求开始回调函数</span>    xhr.addEventListener(<span class="hljs-string">'loadstart'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      _s.beforeSend(xhr);    &#125;);    <span class="hljs-comment">// 请求成功回调函数</span>    xhr.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> status = xhr.status;      <span class="hljs-keyword">if</span> ((status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>) || status === <span class="hljs-number">304</span>) &#123;        <span class="hljs-keyword">let</span> result;        <span class="hljs-keyword">if</span> (xhr.responseType === <span class="hljs-string">'text'</span>) &#123;          result = xhr.responseText;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xhr.responseType === <span class="hljs-string">'document'</span>) &#123;          result = xhr.responseXML;        &#125; <span class="hljs-keyword">else</span> &#123;          result = xhr.response;        &#125;        <span class="hljs-comment">// 注意:状态码200表示请求发送/接受成功,不表示业务处理成功</span>        _s.success(result, status, xhr);      &#125; <span class="hljs-keyword">else</span> &#123;        _s.error(xhr, status, e);      &#125;    &#125;);    <span class="hljs-comment">// 请求结束</span>    xhr.addEventListener(<span class="hljs-string">'loadend'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      _s.complete(xhr, xhr.status);    &#125;);    <span class="hljs-comment">// 请求出错</span>    xhr.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      _s.error(xhr, xhr.status, e);    &#125;);    <span class="hljs-comment">// 请求超时</span>    xhr.addEventListener(<span class="hljs-string">'timeout'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      _s.error(xhr, <span class="hljs-number">408</span>, e);    &#125;);    <span class="hljs-keyword">let</span> useUrlParam = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">let</span> sType = _s.type.toUpperCase();    <span class="hljs-comment">// 如果是"简单"请求,则把data参数组装在url上</span>    <span class="hljs-keyword">if</span> (sType === <span class="hljs-string">'GET'</span> || sType === <span class="hljs-string">'DELETE'</span>) &#123;      useUrlParam = <span class="hljs-literal">true</span>;      _s.url += http.getUrlParam(_s.url, _s.data);    &#125;    <span class="hljs-comment">// 初始化请求</span>    xhr.open(_s.type, _s.url, _s.async);    <span class="hljs-comment">// 设置期望的返回数据类型</span>    xhr.responseType = _s.dataType;    <span class="hljs-comment">// 设置请求头</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key of <span class="hljs-built_in">Object</span>.keys(_s.headers)) &#123;      xhr.setRequestHeader(key, _s.headers[key]);    &#125;    <span class="hljs-comment">// 设置超时时间</span>    <span class="hljs-keyword">if</span> (_s.async &amp;&amp; _s.timeout) &#123;      xhr.timeout = _s.timeout;    &#125;    <span class="hljs-comment">// 发送请求.如果是简单请求,请求参数应为null.否则,请求参数类型需要和请求头Content-Type对应</span>    xhr.send(useUrlParam ? <span class="hljs-literal">null</span> : http.getQueryData(_s.data));  &#125;,  <span class="hljs-comment">// 把参数data转为url查询参数</span>  getUrlParam: <span class="hljs-function">(<span class="hljs-params">url, data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!data) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;    &#125;    <span class="hljs-keyword">let</span> paramsStr = data <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? http.getQueryString(data) : data;    <span class="hljs-keyword">return</span> (url.indexOf(<span class="hljs-string">'?'</span>) !== <span class="hljs-number">-1</span>) ? paramsStr : <span class="hljs-string">'?'</span> + paramsStr;  &#125;,  <span class="hljs-comment">// 获取ajax请求参数</span>  getQueryData: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!data) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'string'</span>) &#123;      <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> FormData) &#123;      <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-keyword">return</span> http.getQueryString(data);  &#125;,  <span class="hljs-comment">// 把对象转为查询字符串</span>  getQueryString: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> paramsArr = [];    <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) &#123;      <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;        <span class="hljs-keyword">let</span> val = data[key];        <span class="hljs-comment">// todo 参数Date类型需要根据后台api酌情处理</span>        <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) &#123;          <span class="hljs-comment">// val = dateFormat(val, 'yyyy-MM-dd hh:mm:ss');</span>        &#125;        paramsArr.push(<span class="hljs-built_in">encodeURIComponent</span>(key) + <span class="hljs-string">'='</span> + <span class="hljs-built_in">encodeURIComponent</span>(val));      &#125;);    &#125;    <span class="hljs-keyword">return</span> paramsArr.join(<span class="hljs-string">'&amp;'</span>);  &#125;&#125;</code></pre><p>这时候调用的代码应该是这样的：</p><pre><code class="hljs coffeescript">http.ajax(&#123;  url: url,  type: <span class="hljs-string">'POST'</span>,  data: &#123;name: <span class="hljs-string">'哈哈'</span>, age: <span class="hljs-number">12</span>&#125;, <span class="hljs-regexp">//</span>或 data: <span class="hljs-string">'name=哈哈&amp;age=12'</span>,  headers: &#123;    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>  &#125;,  beforeSend: <span class="hljs-function"><span class="hljs-params">(xhr)</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request show loading...'</span>);  &#125;,  success: function (result, status, xhr) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request success...'</span>);  &#125;,  error: <span class="hljs-function"><span class="hljs-params">(xhr, status, error)</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request error...'</span>);  &#125;,  complete: <span class="hljs-function"><span class="hljs-params">(xhr, status)</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request hide loading...'</span>);  &#125;&#125;);</code></pre><p>可以看出来哈，还是比较麻烦的，你总不能每次请求都整真么一大堆代码吧，所以我们继续封装！</p><h3 id="进一步封装"><a href="#进一步封装" class="headerlink" title="进一步封装"></a>进一步封装</h3><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 根据实际业务情况装饰 ajax 方法</span><span class="hljs-comment">   * 如:统一异常处理,添加http请求头,请求展示loading等</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">settings</span></span></span><span class="hljs-comment">   */</span>  request: <span class="hljs-function">(<span class="hljs-params">settings = &#123;&#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 统一异常处理函数</span>    <span class="hljs-keyword">let</span> errorHandle = <span class="hljs-function">(<span class="hljs-params">xhr, status</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request error...'</span>);      <span class="hljs-keyword">if</span> (status === <span class="hljs-number">401</span>) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request 没有权限...'</span>);      &#125;      <span class="hljs-keyword">if</span> (status === <span class="hljs-number">408</span>) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request timeout'</span>);      &#125;    &#125;;    <span class="hljs-comment">// 使用before拦截参数的 beforeSend 回调函数</span>    settings.beforeSend = (settings.beforeSend || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    &#125;).before(<span class="hljs-function"><span class="hljs-params">xhr</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request show loading...'</span>);    &#125;);    <span class="hljs-comment">// 保存参数success回调函数</span>    <span class="hljs-keyword">let</span> successFn = settings.success;    <span class="hljs-comment">// 覆盖参数success回调函数</span>    settings.success = <span class="hljs-function">(<span class="hljs-params">result, status, xhr</span>) =&gt;</span> &#123;      <span class="hljs-comment">// todo 根据后台api判断是否请求成功</span>      <span class="hljs-keyword">if</span> (result &amp;&amp; result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> &amp;&amp; result.code !== <span class="hljs-number">1</span>) &#123;        errorHandle(xhr, status);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request success'</span>);        successFn &amp;&amp; successFn(result, status, xhr);      &#125;    &#125;;    <span class="hljs-comment">// 拦截参数的 error</span>    settings.error = (settings.error || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    &#125;).before(<span class="hljs-function">(<span class="hljs-params">result, status, xhr</span>) =&gt;</span> &#123;      errorHandle(xhr, status);    &#125;);    <span class="hljs-comment">// 拦截参数的 complete</span>    settings.complete = (settings.complete || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    &#125;).after(<span class="hljs-function">(<span class="hljs-params">xhr, status</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request hide loading...'</span>);    &#125;);    <span class="hljs-comment">// 请求添加权限头,然后调用http.ajax方法</span>    (http.ajax.before(http.addAuthorizationHeader))(settings);  &#125;,  <span class="hljs-comment">// 添加权限请求头</span>  addAuthorizationHeader: <span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> &#123;    settings.headers = settings.headers || &#123;&#125;;    <span class="hljs-keyword">const</span> headerKey = <span class="hljs-string">'Authorization'</span>; <span class="hljs-comment">// todo 权限头名称</span>    <span class="hljs-comment">// 判断是否已经存在权限header</span>    <span class="hljs-keyword">let</span> hasAuthorization = <span class="hljs-built_in">Object</span>.keys(settings.headers).some(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> key === headerKey;    &#125;);    <span class="hljs-keyword">if</span> (!hasAuthorization) &#123;      settings.headers[headerKey] = <span class="hljs-string">'test'</span>; <span class="hljs-comment">// todo 从缓存中获取headerKey的值</span>    &#125;  &#125;&#125;;<span class="hljs-built_in">Function</span>.prototype.before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">beforeFn</span>) </span>&#123; <span class="hljs-comment">// eslint-disable-line</span>  <span class="hljs-keyword">let</span> _self = <span class="hljs-keyword">this</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    beforeFn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);    _self.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);  &#125;;&#125;;<span class="hljs-built_in">Function</span>.prototype.after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">afterFn</span>) </span>&#123; <span class="hljs-comment">// eslint-disable-line</span>  <span class="hljs-keyword">let</span> _self = <span class="hljs-keyword">this</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    _self.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);    afterFn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);  &#125;;&#125;;</code></pre><p>好极了，这时候我们调用的代码更简洁些了，大概是这样的：</p><pre><code class="hljs javascript">http.request(&#123;  url: url,  type: <span class="hljs-string">'POST'</span>,  data: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'哈哈'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>&#125;, <span class="hljs-comment">// data: 'name=哈哈&amp;age=12',</span>  headers: &#123;    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>  &#125;,  success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, status, xhr</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'就可以操作一波啦'</span>);  &#125;&#125;);<span class="hljs-comment">//对比下刚刚的</span>http.ajax(&#123;  url: url,  type: <span class="hljs-string">'POST'</span>,  data: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'哈哈'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>&#125;, <span class="hljs-comment">//或 data: 'name=哈哈&amp;age=12',</span>  headers: &#123;    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>  &#125;,  beforeSend: <span class="hljs-function">(<span class="hljs-params">xhr</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request show loading...'</span>);  &#125;,  success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, status, xhr</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request success...'</span>);  &#125;,  error: <span class="hljs-function">(<span class="hljs-params">xhr, status, error</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request error...'</span>);  &#125;,  complete: <span class="hljs-function">(<span class="hljs-params">xhr, status</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request hide loading...'</span>);  &#125;&#125;);</code></pre><p>嘿嘿，不要停，让我们继续封装一下～ 😏</p><h3 id="终极封装"><a href="#终极封装" class="headerlink" title="终极封装"></a>终极封装</h3><pre><code class="hljs lasso">const http = &#123;  get: (url, <span class="hljs-built_in">data</span>, successCallback, dataType = <span class="hljs-string">'json'</span>) =&gt; &#123;    http.request(&#123;      url: url,      <span class="hljs-keyword">type</span>: <span class="hljs-string">'GET'</span>,      dataType: dataType,      <span class="hljs-built_in">data</span>: <span class="hljs-built_in">data</span>,      success: successCallback    &#125;);  &#125;,  delete: (url, <span class="hljs-built_in">data</span>, successCallback, dataType = <span class="hljs-string">'json'</span>) =&gt; &#123;    http.request(&#123;      url: url,      <span class="hljs-keyword">type</span>: <span class="hljs-string">'DELETE'</span>,      dataType: dataType,      <span class="hljs-built_in">data</span>: <span class="hljs-built_in">data</span>,      success: successCallback    &#125;);  &#125;,  <span class="hljs-comment">// 调用此方法,参数data应为查询字符串或普通对象</span>  post: (url, <span class="hljs-built_in">data</span>, successCallback, dataType = <span class="hljs-string">'json'</span>) =&gt; &#123;    http.request(&#123;      url: url,      <span class="hljs-keyword">type</span>: <span class="hljs-string">'POST'</span>,      dataType: dataType,      <span class="hljs-built_in">data</span>: <span class="hljs-built_in">data</span>,      headers: &#123;        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>      &#125;,      success: successCallback    &#125;);  &#125;,  <span class="hljs-comment">// 调用此方法,参数data应为json字符串</span>  postBody: (url, <span class="hljs-built_in">data</span>, successCallback, dataType = <span class="hljs-string">'json'</span>) =&gt; &#123;    http.request(&#123;      url: url,      <span class="hljs-keyword">type</span>: <span class="hljs-string">'POST'</span>,      dataType: dataType,      <span class="hljs-built_in">data</span>: <span class="hljs-built_in">data</span>,      headers: &#123;        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json; charset=UTF-8'</span>      &#125;,      success: successCallback    &#125;);  &#125;&#125;;</code></pre><p>此时，此时此刻，right now ！ let us see see 😂</p><pre><code class="hljs coffeescript">http.get(url + <span class="hljs-string">'?name=哈哈&amp;age=12'</span>, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-params">(result, status, xhr)</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'你随便干啥都行哈哈哈哈哈哈哈'</span>);&#125;);</code></pre><p>神似 jquery 的 $.ajax() 对不对？很开心了解了这么多东西吧～，ok 那么我们接着看下一个玩意儿～</p><h2 id="axios"><a href="#axios" class="headerlink" title="-axios"></a>-axios</h2><h3 id="axios-简介"><a href="#axios-简介" class="headerlink" title="axios 简介"></a>axios 简介</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p><strong>特性：</strong></p><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><p>那么 axios 和 ajax 的区别在哪里呢？axios 和 XMLHttpRequest 关联又在哪里呢？<br>Axios 在 NPM 上的描述是：Promise based HTTP client for the browser and node.js，是一种基于 Promise 封装的 HTTP 客户端。<br>AJAX 完整是 Asynchronous Javascript And XML . 异步 js 和 xml，是一种异步请求的技术。</p><p>啥意思？Axios 是通过 Promise 实现 XHR 封装，其中 Promise 是控制手段，XHR 是实际发送 Http 请求的客户端。就像$.ajax 是通过 callback+XHR 实现一样就像我们刚刚在上面封装的那个一个意思的，都是 AJAX 技术的一种运用。 AJAX 技术是实现网页的局部数据刷新，你可以通过 XHR、Fetch、WebSocket 等 API 实现。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>硬核一点，直接上官网代码，一目了然～</p><pre><code class="hljs scilab"><span class="hljs-comment">// get</span>axios.get(<span class="hljs-string">'/user'</span>, &#123;    params: &#123;      ID: <span class="hljs-number">12345</span>    &#125;  &#125;)  .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> &#123;</span>    console.<span class="hljs-built_in">log</span>(response);  &#125;)  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> &#123;</span>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">error</span>);  &#125;);<span class="hljs-comment">// post</span>axios.post(<span class="hljs-string">'/user'</span>, &#123;    firstName: <span class="hljs-string">'Fred'</span>,    lastName: <span class="hljs-string">'Flintstone'</span>  &#125;)  .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> &#123;</span>    console.<span class="hljs-built_in">log</span>(response);  &#125;)  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> &#123;</span>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">error</span>);  &#125;);<span class="hljs-comment">// 并发</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserAccount</span><span class="hljs-params">()</span> &#123;</span>  <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">'/user/12345'</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserPermissions</span><span class="hljs-params">()</span> &#123;</span>  <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">'/user/12345/permissions'</span>);&#125;axios.all([getUserAccount(), getUserPermissions()])  .<span class="hljs-keyword">then</span>(axios.spread(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acct, perms)</span> &#123;</span>    <span class="hljs-comment">// 两个请求现在都执行完成</span>  &#125;));</code></pre><h3 id="axios-的请求配置"><a href="#axios-的请求配置" class="headerlink" title="axios 的请求配置"></a>axios 的请求配置</h3><p>1、可以通过 axios.defaults 设置全局默认值，在所有请求中都生效。</p><pre><code class="hljs stylus">axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.common</span>[<span class="hljs-string">"token"</span>] = <span class="hljs-string">""</span>axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.post</span>[<span class="hljs-string">"Content-type"</span>] = <span class="hljs-string">"application/json"</span>axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.baseURL</span> = <span class="hljs-string">'https://zhujun.zhenhao.com; //设置统一路径前缀</span></code></pre><p>2、也可以自定义实例的默认值，以及修改实例的配置</p><pre><code class="hljs cs"><span class="hljs-keyword">let</span> zhujun = axios.create(&#123;  baseURL: <span class="hljs-string">'http://zhujun.zhenbang.com'</span>,  <span class="hljs-keyword">params</span>: &#123; name: <span class="hljs-string">'朱军'</span> &#125;&#125;);<span class="hljs-comment">// 修改配置后，超时设置为4秒</span>zhujun.defaults.timeout = <span class="hljs-number">4000</span>;</code></pre><p>3、也可以在每个请求中设置相关的配置。</p><pre><code class="hljs less"><span class="hljs-selector-tag">axios</span>(<span class="hljs-string">'/app/mock/zhujun'</span>, &#123;  <span class="hljs-attribute">params</span>: &#123;    <span class="hljs-attribute">name</span>: <span class="hljs-string">'朱军'</span>  &#125;,  <span class="hljs-attribute">baseURL</span>: <span class="hljs-string">'http://zhujun.zhenshuai.com'</span>&#125;)</code></pre><pre><code class="hljs actionscript">&#123;   <span class="hljs-comment">// `url` 是用于请求的服务器 URL</span>  url: <span class="hljs-string">'/user'</span>,  <span class="hljs-comment">// `method` 是创建请求时使用的方法</span>  method: <span class="hljs-string">'get'</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>  <span class="hljs-comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>  baseURL: <span class="hljs-string">'https://some-domain.com/api/'</span>,  <span class="hljs-comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span>  <span class="hljs-comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span>  <span class="hljs-comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span>  transformRequest: [<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, headers)</span> </span>&#123;    <span class="hljs-comment">// 对 data 进行任意转换处理</span>    <span class="hljs-keyword">return</span> data;  &#125;],  <span class="hljs-comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>  transformResponse: [<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>&#123;    <span class="hljs-comment">// 对 data 进行任意转换处理</span>    <span class="hljs-keyword">return</span> data;  &#125;],  <span class="hljs-comment">// `headers` 是即将被发送的自定义请求头</span>  headers: &#123;<span class="hljs-string">'X-Requested-With'</span>: <span class="hljs-string">'XMLHttpRequest'</span>&#125;,  <span class="hljs-comment">// `params` 是即将与请求一起发送的 URL 参数</span>  <span class="hljs-comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span>  params: &#123;    ID: <span class="hljs-number">12345</span>  &#125;,   <span class="hljs-comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span>  <span class="hljs-comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>  paramsSerializer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(params)</span> </span>&#123;    <span class="hljs-keyword">return</span> Qs.stringify(params, &#123;arrayFormat: <span class="hljs-string">'brackets'</span>&#125;)  &#125;,  <span class="hljs-comment">// `data` 是作为请求主体被发送的数据</span>  <span class="hljs-comment">// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span>  <span class="hljs-comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span>  <span class="hljs-comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>  <span class="hljs-comment">// - 浏览器专属：FormData, File, Blob</span>  <span class="hljs-comment">// - Node 专属： Stream</span>  data: &#123;    firstName: <span class="hljs-string">'Fred'</span>  &#125;,  <span class="hljs-comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span>  <span class="hljs-comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span>  timeout: <span class="hljs-number">1000</span>,   <span class="hljs-comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span>  withCredentials: <span class="hljs-literal">false</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span>  <span class="hljs-comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span>  adapter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(config)</span> </span>&#123;    <span class="hljs-comment">/* ... */</span>  &#125;, <span class="hljs-comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span>  <span class="hljs-comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span>  auth: &#123;    username: <span class="hljs-string">'janedoe'</span>,    password: <span class="hljs-string">'s00pers3cret'</span>  &#125;,   <span class="hljs-comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span>  responseType: <span class="hljs-string">'json'</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `responseEncoding` indicates encoding to use for decoding responses</span>  <span class="hljs-comment">// Note: Ignored for `responseType` of 'stream' or client-side requests</span>  responseEncoding: <span class="hljs-string">'utf8'</span>, <span class="hljs-comment">// default</span>   <span class="hljs-comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span>  xsrfCookieName: <span class="hljs-string">'XSRF-TOKEN'</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span>  xsrfHeaderName: <span class="hljs-string">'X-XSRF-TOKEN'</span>, <span class="hljs-comment">// default</span>   <span class="hljs-comment">// `onUploadProgress` 允许为上传处理进度事件</span>  onUploadProgress: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(progressEvent)</span> </span>&#123;    <span class="hljs-comment">// Do whatever you want with the native progress event</span>  &#125;,  <span class="hljs-comment">// `onDownloadProgress` 允许为下载处理进度事件</span>  onDownloadProgress: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(progressEvent)</span> </span>&#123;    <span class="hljs-comment">// 对原生进度事件的处理</span>  &#125;,   <span class="hljs-comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span>  maxContentLength: <span class="hljs-number">2000</span>,  <span class="hljs-comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span>  validateStatus: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(status)</span> </span>&#123;    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-comment">// default</span>  &#125;,  <span class="hljs-comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span>  <span class="hljs-comment">// 如果设置为0，将不会 follow 任何重定向</span>  maxRedirects: <span class="hljs-number">5</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span>  <span class="hljs-comment">// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span>  <span class="hljs-comment">// Only either `socketPath` or `proxy` can be specified.</span>  <span class="hljs-comment">// If both are specified, `socketPath` is used.</span>  socketPath: <span class="hljs-literal">null</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span>  <span class="hljs-comment">// `keepAlive` 默认没有启用</span>  httpAgent: <span class="hljs-keyword">new</span> http.Agent(&#123; keepAlive: <span class="hljs-literal">true</span> &#125;),  httpsAgent: <span class="hljs-keyword">new</span> https.Agent(&#123; keepAlive: <span class="hljs-literal">true</span> &#125;),  <span class="hljs-comment">// 'proxy' 定义代理服务器的主机名称和端口</span>  <span class="hljs-comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span>  <span class="hljs-comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span>  proxy: &#123;    host: <span class="hljs-string">'127.0.0.1'</span>,    port: <span class="hljs-number">9000</span>,    auth: &#123;      username: <span class="hljs-string">'mikeymike'</span>,      password: <span class="hljs-string">'rapunz3l'</span>    &#125;  &#125;,  <span class="hljs-comment">// `cancelToken` 指定用于取消请求的 cancel token</span>  <span class="hljs-comment">// （查看后面的 Cancellation 这节了解更多）</span>  cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cancel)</span> </span>&#123;  &#125;)&#125;</code></pre><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>可以分别设置请求拦截和响应拦截，在发出请求和响应到达 then 之前进行判断处理。</p><pre><code class="hljs typescript">axios.interceptors.response.use(  res =&gt; &#123;    <span class="hljs-keyword">if</span> (res) &#123;      <span class="hljs-keyword">return</span> res;    &#125;  &#125;,  err =&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);  &#125;);</code></pre><p>把上面的 response 换成 request 就是请求发出前的拦截器～<br>拦截器是可以移除的，在特殊的情况下，会用到移除拦截器。（我其实也不知道啥情况需要如此莫名其妙的操作）</p><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> clearInterceptors = axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125;);axios.interceptors.request.eject(clearInterceptors);<span class="hljs-comment">// 移除拦截器，和移除js定时器一样。</span></code></pre><h3 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h3><pre><code class="hljs less"><span class="hljs-attribute">proxy</span>: &#123;  <span class="hljs-string">'/api'</span>: &#123;    <span class="hljs-attribute">target</span>: <span class="hljs-string">'https://www.xxx.com'</span>, <span class="hljs-comment">//目标路径，别忘了加http和端口号</span>    <span class="hljs-attribute">changeOrigin</span>: true, <span class="hljs-comment">//是否跨域</span>    <span class="hljs-attribute">ws</span>: true,    <span class="hljs-attribute">pathRewrite</span>: &#123;      <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span> <span class="hljs-comment">//重写路径</span>    &#125;  &#125;&#125;</code></pre><h3 id="EXTRA"><a href="#EXTRA" class="headerlink" title="EXTRA"></a>EXTRA</h3><p>整点额外的惊喜，硬核起来上代码！</p><pre><code class="hljs php">import axios from <span class="hljs-string">'axios'</span>;import &#123; getLocale &#125; from <span class="hljs-string">'umi-plugin-react/locale'</span>;import &#123; getToken &#125; from <span class="hljs-string">'../token'</span>;<span class="hljs-comment">// Add a request interceptor 这是加个拦截器，在 request 发出请求之前，可以做一些操作的～</span>axios.interceptors.request.<span class="hljs-keyword">use</span>(<span class="hljs-title">function</span>(<span class="hljs-title">config</span>) &#123;// <span class="hljs-title">Do</span> <span class="hljs-title">something</span> <span class="hljs-title">before</span> <span class="hljs-title">request</span> <span class="hljs-title">is</span> <span class="hljs-title">sent</span><span class="hljs-title">return</span> <span class="hljs-title">config</span>;&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>&#123;<span class="hljs-comment">// Do something with request error</span><span class="hljs-keyword">return</span> Promise.reject(error);&#125;);<span class="hljs-comment">// Add a response interceptor 这也是个拦截，在响应到达 then 之前也可以操作一波，这里做了个如果请求失败，自动重新请求的操作</span>axios.interceptors.response.<span class="hljs-keyword">use</span>(<span class="hljs-title">function</span>(<span class="hljs-title">response</span>) &#123;// <span class="hljs-title">Do</span> <span class="hljs-title">something</span> <span class="hljs-title">with</span> <span class="hljs-title">response</span> <span class="hljs-title">data</span><span class="hljs-title">return</span> <span class="hljs-title">response</span>;&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>&#123;<span class="hljs-comment">// Do something with response error</span><span class="hljs-keyword">const</span> &#123; config, response &#125; = error;<span class="hljs-keyword">if</span> (config) &#123;<span class="hljs-keyword">if</span> (config.retry &amp;&amp;[<span class="hljs-string">'get'</span>, <span class="hljs-string">'put'</span>, <span class="hljs-string">'delete'</span>].includes(config.method) &amp;&amp;(!response || (response.status &gt;= <span class="hljs-number">500</span> &amp;&amp; response.status &lt;= <span class="hljs-number">599</span>))) &#123;<span class="hljs-keyword">const</span> &#123; headers &#125; = config;<span class="hljs-keyword">const</span> retryCountHeaderKey = <span class="hljs-string">'X-Retry-Count'</span>;<span class="hljs-keyword">const</span> retryCountHeaderValue = parseInt(headers[retryCountHeaderKey] || <span class="hljs-string">'0'</span>, <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (retryCountHeaderValue &lt;= <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">// 如果失败，自动请求 3 次</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(resolve =&gt; &#123;setTimeout(() =&gt;resolve(axios(&#123;...config,headers: &#123;...headers,[retryCountHeaderKey]: `$&#123;retryCountHeaderValue&#125;`,&#125;,&#125;)),<span class="hljs-number">1000</span> \* retryCountHeaderValue);&#125;);&#125;&#125; <span class="hljs-comment">// 重发“安全请求”</span>&#125;<span class="hljs-keyword">return</span> Promise.reject(error);&#125;);/\*\*- request 方法，axios 的简单封装  \*/  export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span><span class="hljs-params">(url, config = &#123;&#125;)</span> </span>&#123;  axios.defaults.headers.common.Authorization = getToken(); <span class="hljs-comment">// 获取 token</span>  axios.defaults.headers.common[<span class="hljs-string">'Accept-Language'</span>] = `$&#123;getLocale()&#125;;q=<span class="hljs-number">0.9</span>`; <span class="hljs-comment">// 国际化“Accept-Language:zh-CN,zh;q=0.9” =&gt; zh-CN 或 en-US</span><span class="hljs-keyword">const</span> &#123;method = <span class="hljs-string">'get'</span>,responseType,body = &#123;&#125;,headers = &#123;&#125;,cache = <span class="hljs-keyword">false</span>,download = <span class="hljs-keyword">false</span>,retry = <span class="hljs-keyword">true</span>, <span class="hljs-comment">// eslint-disable-line</span>...rest&#125; = config;<span class="hljs-keyword">const</span> newBody = /(put|post|patch)/i.test(method) ? &#123; data: body &#125; : &#123; params: body &#125;; <span class="hljs-comment">// data 参数，在以下“请求类型”中可用：put, post, patch</span><span class="hljs-keyword">const</span> newResponseType = responseType || (download ? <span class="hljs-string">'arraybuffer'</span> : <span class="hljs-string">'json'</span>);<span class="hljs-keyword">return</span> axios.request(&#123;url, <span class="hljs-comment">// URL 地址</span>method, <span class="hljs-comment">// 请求类型，get, post, put, delete...</span>responseType: newResponseType, <span class="hljs-comment">// 响应数据类型</span>      headers: &#123;        ...headers,        ...(cache          ? &#123; <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'public, max-age=86400'</span> &#125;          : &#123; <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'no-cache, no-store, must-revalidate'</span>, Pragma: <span class="hljs-string">'no-cache'</span> &#125;),      &#125;,      ...newBody, <span class="hljs-comment">// 请求参数</span>      ...rest, <span class="hljs-comment">// 剩余参数</span>    &#125;)    .then(response =&gt; (&#123;      success: <span class="hljs-keyword">true</span>,      response,    &#125;))    .<span class="hljs-keyword">catch</span>(error =&gt; &#123;      <span class="hljs-keyword">const</span> &#123; response &#125; = error;      <span class="hljs-keyword">const</span> &#123; status &#125; = response;      <span class="hljs-keyword">const</span> errorName = `Error$&#123;status&#125; - $&#123;response.config.url&#125;`;      <span class="hljs-keyword">const</span> errorMessage = response.statusText;      console.log(errorName);      console.log(errorMessage);<span class="hljs-comment">// 如果不是登陆页，但是状态码 401 那么跳转页面到登陆页</span><span class="hljs-keyword">if</span> (window.location.href.indexOf(<span class="hljs-string">'login'</span>) === <span class="hljs-number">-1</span> &amp;&amp; status === <span class="hljs-number">401</span>) &#123;window.location.href = `/g/login?redirect=$&#123; window.location.href.split(window.location.host)[<span class="hljs-number">1</span>] &#125;`;&#125;      <span class="hljs-keyword">return</span> &#123;        success: <span class="hljs-keyword">false</span>,        response: &#123; ...response, data: response.data || &#123; message: <span class="hljs-string">'504 Gateway Timeout'</span> &#125; &#125;,      &#125;;    &#125;);&#125;```<span class="hljs-comment">#### 在项目中的用法</span>```         onClick=&#123;() =&gt; &#123;              this.setState(&#123;                spinning: <span class="hljs-keyword">true</span>,              &#125;);              request(`/server/api/declarationfiles/$&#123;record.id&#125;`, &#123;                method: <span class="hljs-string">'get'</span>,                download: <span class="hljs-keyword">true</span>,                onDownloadProgress: e =&gt; &#123;                  <span class="hljs-keyword">if</span> (e.loaded / e.total === <span class="hljs-number">1</span>) &#123;                    this.setState(&#123;                      spinning: <span class="hljs-keyword">false</span>,                    &#125;);                  &#125;                &#125;,              &#125;).then(wrappedResponse =&gt; &#123;                <span class="hljs-keyword">const</span> &#123; response &#125; = wrappedResponse;                download(record.fileName, response.data);              &#125;);            &#125;&#125;                <span class="hljs-comment">//  直接在页面里写请求，适用于调用次数少，独立专属于某个页面使用的情况。比如文件下载等</span>```---```\*retrieveRules(&#123; payload &#125;, &#123; call, put, select &#125;) &#123;<span class="hljs-keyword">const</span> newRules = <span class="hljs-keyword">yield</span> select(models =&gt; &#123;<span class="hljs-keyword">const</span> &#123; pagination, searcher &#125; = models[<span class="hljs-keyword">namespace</span>];<span class="hljs-keyword">return</span> &#123;pagination,searcher,...payload,&#125;;&#125;);<span class="hljs-keyword">const</span> &#123; pagination, searcher &#125; = newRules;<span class="hljs-keyword">const</span> wrappedResponse = <span class="hljs-keyword">yield</span> call(request, `/server/api/projectwarningrules`, &#123;method: <span class="hljs-string">'get'</span>,body: &#123;...pagination,...searcher,&#125;,&#125;);&#125;               <span class="hljs-comment">// 写在model 层的effect里面，适用于调用次数多， 比如请求列表数据，增删改查操作后需要再次调用请求数据</span>``````</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XMLHttpRequest request axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议</title>
    <link href="/2020/06/24/network-protocol/"/>
    <url>/2020/06/24/network-protocol/</url>
    
    <content type="html"><![CDATA[<h3 id="五层协议体系结构-物理层、数据链路层、网络层、运输层、应用层"><a href="#五层协议体系结构-物理层、数据链路层、网络层、运输层、应用层" class="headerlink" title="五层协议体系结构:物理层、数据链路层、网络层、运输层、应用层."></a>五层协议体系结构:物理层、数据链路层、网络层、运输层、应用层.</h3><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>物理层的主要任务是确定与传输媒体接口的特性.如机械特性、电气特性、功能特性、过程特性.</li><li>中继器：又叫转发器，功能是将信号整形放大再转发出去，以消除信号的失真和衰减，扩大网络传输的距离，其原理是信号再生，仅作用于电气部分，不管数据中是否有错误</li><li>集线器(HUB):实质上是多端口的中继器，也工作在物理层。一口接受数据信号，将其整形放大转发到其他所有(输入端除外)处于工作状态的端口上，多口输入，冲突-&gt;无效</li><li>码元:在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形.</li><li>几种通信:单工通信、半双工通信(双方交替)、全双工通信</li><li>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。</li><li>奈氏准则:在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能.</li><li>信道的极限信息传输速率 C : C = W log2(1+S/N) b/s ; W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。 ·</li><li>导引型传播媒体:双绞线(屏蔽、无屏蔽)、同轴电缆、光缆(单模光纤、双模光纤)、非导引型传输媒体:无线传输介质:无线电波、微波、红外线、激光.</li><li>频分复用:所有用户在同样的时间占用频率不同的带宽资源.</li><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙</li><li>波分复用：光的频分复用</li><li>码分复用:各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现</li><li>宽带接入技术:ADSL、HFC、FTTx</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li>数据链路层使用的信道:点对点信道 ppp 协议和广播信道.</li><li>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</li><li>一条链路只是一条通路的一个组成部分。数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li><li>数据链路的基本单位是帧.</li><li>数据链路层解决的三个问题是封装成帧、透明传输、差错控制</li><li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li><li>透明传输:原始数据中出现控制符如何转义.0 比特填充.</li><li>循环冗余检验 CRC:现在 k = 6, M = 101001。设 n = 3, 除数 P = 1101，被除数是 2nM = 101001000。 模 2 运算的结果是：商 Q = 110101，余数 R = 001。把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R 即：101001001，共 (k + n) 位。<br>在数据后面添加上的冗余码称为帧检验序列 FCS . CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法</li><li>CRC 不能实现可靠传输,需要确认和重传机制.</li><li>0 比特填充:连续五个 1 之后加入一个 0.</li><li>数据链路层的两个子层:逻辑链路控制 LLC (Logical Link Control)子层</li><li>媒体接入控制 MAC (Medium Access Control)子层.</li><li>通信适配器,也就是网卡,作用是:进行串行/并行转换。对数据进行缓存。在计算机的操作系统安装设备驱动程序。实现以太网协议。</li><li>CSMA/CD 协议: Carrier Sense Multiple Access with Collision Detection.“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。只能实现半双工通信.</li><li>退避算法:发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</li><li>在局域网中，硬件地址又称为物理地址，或 MAC 地址。</li><li>集线器的优缺点:使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信,扩大了局域网覆盖的地理范围.缺点是碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li><li>网桥:在数据链路层扩展局域网.根据 MAC 帧的目的地址对收到的帧进行转发.具有过滤帧的功能<br>网桥的优缺点: 过滤通信量。 扩大了物理范围。提高了可靠性。可互连不同物理层、不同 MAC 子层和不同速率（如 10 Mb/s 和 100 Mb/s 以太网）的局域网。缺点:存储转发增加了时延。 在 MAC 子层并没有流量控制功能。 具有不同 MAC 子层的网段桥接在一起时时延更大。网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</li><li>网桥和集线器的不同:集线器转发时不进行检查,而网桥会进行 CSMA/CD 算法.</li><li>透明网桥:“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。<br>在网桥的转发表中写入的信息除了地址和接口外，还有帧进入该网桥的时间。<br>避免产生转发的帧在网络中不断地兜圈子的方法是生成树.</li><li>以太网交换机:以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。<br>虚拟局域网:虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。<br>IP 协议.地址解析协议 ARP.(IP 地址-&gt;物理地址)逆地址解析协议 RARP.网际控制报文协议 ICMP.网际组管理协议 IGMP 都是网络层的协议,TCP、UDP 是运输层的协议.</li><li>中间设备又称为中间系统或中继(relay)系统。物理层中继系统：转发器(repeater)。数据链路层中继系统：网桥或桥接器(bridge)。网络层中继系统：路由器(router)。网桥和路由器的混合物：桥路器(brouter)。网络层以上的中继系统：网关(gateway)。</li><li>四类 IP 地址:A 类 0 开头网络号 8 位,主机号 24 位.B 类 10 开头网络号 16 位.C 类 110 开头网络号 24 位.D 类 1110 开头,多播地址.E 类 1111 开头,保留地址.</li><li>IP 分网络号和主机号:第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li><li>ARP:每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</li><li>ICMP:ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告.有两种报文种类:即 ICMP 差错报告报文和 ICMP 询问报文.Ping 和 Traceroute 指令通过 ICMP 协议,不经过 TCP 或者 UDP.</li><li>路由选择协议:内部网关协议 IGP( RIP 和 OSPF)和外部网关协议 EGP( BGP-4)</li><li>RIP:是一种分布式的基于距离向量的路由选择协议,每一个路由器都要维护从它自己到其他每一个目的网络的距离记录.RIP 允许一条路径最多只能包含 15 个路由器.</li><li>RIP 协议三个要点:仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li><li>RIP 的优缺点:优点:实现简单开销小,缺点是故障传输慢、网络规模小.</li><li>OSPF 协议:是分布式的链路状态协议.OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF 的三个要点:向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。<br>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。减少了整个网络上的通信量。<br>OSPF 的五种分组类型:问候、数据库描述、链路状态请求、链路状态更新、链路状态确认.<br>MTU(路径最大传输单元)</li><li>CIDR:无类别域间路由.缓解了地址枯竭的趋势；控制甚至缩减了路由表的开销<br>分配 IP 地址的时候不再以类别来分，而是按照可变长的地址块来分配.基于可变长子网掩码 VLSM.</li><li>拥塞控制:流量感知路由、准入控制、流量调节、负载丢弃、随机早期检测 RED.</li><li>流量整形:漏桶、令牌桶.</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul><li>应用进程之间的通信又称为端到端的通信。 运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。IP 协议提供主机之间的逻辑通信,而 TCP/UDP 提供进程之间的逻辑通信.</li><li>用户数据报协议 UDP 和 传输控制协议 TCP ,TCP 要提供可靠的、面向连接的运输服务.</li><li>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU .</li><li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能,不保证可靠交付，同时也不使用拥塞控制</li><li>TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供全双工通信。面向字节流。</li><li>TCP 连接的端点叫做套接字(socket)或插口。</li><li>ARQ:使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest), ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</li><li>连续 ARQ 和回退 NARQ.</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>DNS:同时使用 TCP 和 UDP:53<br>FTP:TCP:21<br>NFS:UDP<br>TFTP:UDP<br>TELNET:TCP:23<br>RPC:TCP<br>HTTP:TCP:80<br>SMTP:TCP:25,发邮件<br>POP3:TCP:110<br>IMAP:TCP<br>MIME:MIME 类型是一种通知客户端其接收文件的多样性的机制:<br>DHCP:UDP<br>SNMP:UDP<br>POP3 和 IMAP 的区别:POP3 协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的 3 封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。而 IMAP 提供 webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</p>]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试相关</title>
    <link href="/2020/06/23/phone-interview/"/>
    <url>/2020/06/23/phone-interview/</url>
    
    <content type="html"><![CDATA[<p><a href="https://vevlins.github.io/2018/03/14/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">别人的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电话面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域</title>
    <link href="/2020/06/23/scope/"/>
    <url>/2020/06/23/scope/</url>
    
    <content type="html"><![CDATA[<h2 id="作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。"><a href="#作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。" class="headerlink" title="作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。"></a>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</h2><h3 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a>1. 全局作用域</h3><p>任何地方都能访问到的对象拥有全局作用域。<br>1.1 函数外面定义的变量拥有全局作用域<br>1.2 未定义直接赋值的变量自动声明为拥有全局作用域<br>1.3.window 对象的属性拥有全局作用</p><h3 id="2-局部作用域"><a href="#2-局部作用域" class="headerlink" title="2. 局部作用域"></a>2. 局部作用域</h3><p>函数内部的作用域为局部作用域</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。</p><p>1.当执行函数时，总是先从函数内部找寻局部变量</p><p>2.如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上</p><hr><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> bb = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">(bb)</span><span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">  bb = 2 ;</span></span><span class="hljs-function"><span class="hljs-comment">  alert(bb)</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">(bb)</span>;</span>alert(bb)<span class="hljs-comment">//  2,1</span><span class="hljs-keyword">var</span> bb = <span class="hljs-number">1</span> ;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">  alert(bb)</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-comment">// undefined</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>作用域 作用域链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到页面渲染</title>
    <link href="/2020/06/18/hardcore-process/"/>
    <url>/2020/06/18/hardcore-process/</url>
    
    <content type="html"><![CDATA[<p>前言：不知道这玩意儿，前端也能干活。但是得进步啊。当学会了这玩意儿，对网络的理解会举头望明月，更上一层楼。<br>反正百利而无一害。嘿嘿，开始整活～</p><p>第一步，手放在键盘上敲出 url，然后回车，咔哒一敲！然后页面就出来了，是不是很简单～ 😁<br>让我们的学习气氛轻松起来～ 下面正式开始，我敲个 url：</p><p><a href="https://onepunchx.github.io/archives/" target="_blank" rel="noopener">https://onepunchx.github.io/archives/</a></p><h2 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h2><p>输入完这个网址，敲回车！浏览器做的第一件事是 解析这个 url：</p><ol><li><strong>通过 <em>DNS_（domain name system） 把域名（domain name）解析程 _IP</em> 地址</strong></li></ol><p>IP 地址这玩意儿，就相当于我们每个人的身份证号码，身份证号可以唯一、精准的匹配到一个人，那么 IP 地址就可以唯一、精准的匹配到对应的计算机。<br>但是身份证号码这玩意，你能记住几个？能记住自己的就不错了，通常你记住的都是别人的名字，那么这个域名/网址/URL 就相当于计算机的名字<br>形象一点的对应关系如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><ol start="2"><li><strong>然后应用曾生成 HTTP 请求报文</strong><br>啥是请求报文？<br>请求报文 有起始行 首部 和 主体部分，说起来太不形象具体了，直接上代码！</li></ol><p>GET <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> HTTP/1.1 （起始行）</p><p>Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>Connection: keep-alive<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8<br>X-Client-Data: CKm1yQEIhbbJAQijtskBCMG2yQEIqZ3KAQioo8oB<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8<br>（首部）</p><p>然后是主体内容，get 请求的主体内容为空，post 的请求主体内容就是请求体，body 里面的内容</p><p>这个 http 请求报文说起来里面学问很大，有机会的话单独写一次。这里给自己先挖个坑。。。</p><ol start="3"><li><p><strong>传输层建立 TCP 连接</strong><br>3 次握手，4 次挥手。<br>这里不细说，等待后续填坑</p></li><li><p><strong>网络层使用 IP 协议来选择路线</strong><br>处理来自传输层的数据段 segment，将数据段 segment 装入数据包 packet，填充包头，主要就是添加源和目的 IP 地址，然后发送数据。在数据传输的过程中，IP 协议负责选择传送的路线，称为路由功能</p></li><li><p><strong>数据链路层实现网络相邻结点间可靠的数据通信</strong><br>　　为了保证数据的可靠传输，把数据包 packet 封装成帧(Frame)，并按顺序传送各帧。由于物理线路的不可靠，发出的数据帧有可能在线路上出错或丢失，于是为每个数据分块计算出 CRC(循环冗余检验)，并把 CRC 添加到帧中，这样接收方就可以通过重新计算 CRC 来判断数据接收的正确性。一旦出错就重传</p></li></ol><p>将数据包 packet 封装成帧(Frame)，包括帧头和帧尾。帧尾是添加被称做 CRC 的循环冗余校验部分。帧头主要是添加数据链路层的地址，即数据链路层的源地址和目的地址，即网络相邻结点间的源 MAC 地址和目的 MAC 地址</p><ol start="6"><li><p><strong>数据链路层的帧(Frame)转换成二进制形式的比特(Bit)流，从网卡发送出去，再把比特转换成电子、光学或微波信号在网络中传输</strong><br>光纤，电缆啥的这时候就派上用场啦</p></li><li><p><strong>服务器处理</strong><br>通俗来说，就是先弄清楚浏览器需要什么，然后找到相关数据，然后封装这些数据，然后准备传回去。打个比方，如果我们输入了百度的网址<br><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>那么这里服务器就会把百度的首页的 html 给浏览器传过去</p></li><li><p><strong>服务器处理完事，给浏览器传回去，跟传过来的时候差不多</strong></p></li><li><p><strong>浏览器渲染</strong><br>这时候你的电脑就接收到了服务器传过来的数据，然后经过处理，准备渲染，这个过程里呢就是遇见了 html 里面需要啥，就发请求获取啥。<br>比如说<br>浏览器开始载入 html 代码，发现<head>标签内有一个<link>标签引用外部 CSS 文件<br>浏览器又发出 CSS 文件的请求，服务器返回这个 CSS 文件<br>浏览器继续载入 html 中<body>部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了<br>浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。<br>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。<br>浏览器发现了一个包含一行 Javascript 代码的 script 标签，赶快运行它。<br>Javascript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 style（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。<br>就这样，浏览器吭呲瘪肚的终于把页面鼓捣出来了！</p></li></ol><p>这就是整个过程啦，大概就是这么回事～</p><p><strong>页面渲染需要做这些事</strong></p><ul><li>解析 html，创建 dom 树</li><li>解析 css ， 给页面美容</li><li>解析 js ，给页面交互响应</li></ul><h3 id="ext-重绘和回流"><a href="#ext-重绘和回流" class="headerlink" title="ext 重绘和回流"></a>ext 重绘和回流</h3><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><p>回流是指窗口尺寸被修改、发生滚动操作，或者元素位置相关属性被更新时会触发布局过程，在布局过程中要计算所有元素的位置信息。<br>（尺寸长宽高改变，显隐就会回流啦）<br>由于 HTML 使用的是流式布局，如果页面中的一个元素的尺寸发生了变化，则其后续的元素位置都要跟着发生变化，也就是重新进行流式布局的过程，所以被称之为回流</p><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>重绘是指当与视觉相关的样式属性值被更新时会触发绘制过程，在绘制过程中要重新计算元素的视觉信息，使元素呈现新的外观<br>当一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。</p><p>回流一定重绘，重绘不一定回流。<br>只有颜色改变的时候就只会发生重绘而不会引起回流<br>当页面布局和几何属性改变时就需要回流<br>比如：添加或者删除可见的 DOM 元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</p><p>下面列举一些减少回流次数的方法（来自百度）</p><p>（1）不要一条一条地修改 DOM 样式，而是修改 className 或者修改 style.cssText</p><p>（2）在内存中多次操作节点，完成后再添加到文档中去</p><p>（3）对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示</p><p>（4）在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中</p><p>（5）不要使用 table 布局，因为一个小改动可能会造成整个 table 重新布局。而且 table 渲染通常要 3 倍于同等元素时间</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>DNS 解析 URL 地址</li><li>生成 HTTP 请求报文</li><li>构建 TCP 连接</li><li>使用 IP 协议选择传输路线</li><li>数据链路层保证数据的可靠传输</li><li>物理层将数据转换成电子、光学或微波信号进行传输</li><li>服务器处理数据，并返回浏览器所需资源</li><li>浏览器处理数据</li><li>页面渲染</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http tcp 重绘回流 DNS IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 合成事件</title>
    <link href="/2020/06/17/react-syntheticevent/"/>
    <url>/2020/06/17/react-syntheticevent/</url>
    
    <content type="html"><![CDATA[<p>这个不是很重要，而且想真弄懂，得看源码。我看的是一头雾水。但是大概思路可以表达出来</p><h3 id="React-合成事件一套机制：React-并不是将-click-事件直接绑定在-dom-上面，而是采用事件冒泡的形式冒泡到-document-上面，当事件发生并冒泡至-document-处时，React-将事件内容封装交给中间层-SyntheticEvent（负责所有事件合成），然后-React-将事件封装给正式的函数处理运行和处理。"><a href="#React-合成事件一套机制：React-并不是将-click-事件直接绑定在-dom-上面，而是采用事件冒泡的形式冒泡到-document-上面，当事件发生并冒泡至-document-处时，React-将事件内容封装交给中间层-SyntheticEvent（负责所有事件合成），然后-React-将事件封装给正式的函数处理运行和处理。" class="headerlink" title="React 合成事件一套机制：React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SyntheticEvent（负责所有事件合成），然后 React 将事件封装给正式的函数处理运行和处理。"></a>React 合成事件一套机制：React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SyntheticEvent（负责所有事件合成），然后 React 将事件封装给正式的函数处理运行和处理。</h3><p>为啥有这种 react 合成事件 这种东西？ 存在即合理。<br>如果 dom 上绑定了特别多的事件处理函数，那指定会卡。为了不会卡，所以有了这个 react 合成事件，并且对浏览器兼容性，不用担心 ie 的坑了。</p><h3 id="注意：React-事件和原生事件最好不要混用。原生事件中如果执行了-stopPropagation-方法，则会导致其他-React-事件失效。因为所有元素的事件将无法冒泡到-document-上，导致所有的-React-事件都将无法被触发。"><a href="#注意：React-事件和原生事件最好不要混用。原生事件中如果执行了-stopPropagation-方法，则会导致其他-React-事件失效。因为所有元素的事件将无法冒泡到-document-上，导致所有的-React-事件都将无法被触发。" class="headerlink" title="注意：React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。"></a>注意：React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。</h3><p>下面留个链接，是大佬分析源码的东西。<br><a href="https://zhuanlan.zhihu.com/p/25883536" target="_blank" rel="noopener">点击跳转</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react合成事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>event.stopPropagation()和event.preventDefault()</title>
    <link href="/2020/06/17/stoppropagation-preventDefault/"/>
    <url>/2020/06/17/stoppropagation-preventDefault/</url>
    
    <content type="html"><![CDATA[<h3 id="硬核整活。就-3-个玩意儿："><a href="#硬核整活。就-3-个玩意儿：" class="headerlink" title="硬核整活。就 3 个玩意儿："></a>硬核整活。就 3 个玩意儿：</h3><ol><li><p>event.stopPropagation() 阻止冒泡</p></li><li><p>event.preventDefault() 阻止默认事件</p></li><li><p>return false 同时阻止冒泡和默认事件</p></li></ol><h3 id="阻止事件冒泡，能咋滴？"><a href="#阻止事件冒泡，能咋滴？" class="headerlink" title="阻止事件冒泡，能咋滴？"></a>阻止事件冒泡，能咋滴？</h3><p>el.addEventListener(”click“,function(){console.log(‘xxx’)},false) 接受第二个参数是个回调函数吧？函数里有操作吧，有干活吧？<br>这个阻止冒泡，就阻止这个回调函数干活。说的是冒泡奥，捕获不阻止的奥。</p><h3 id="阻止默认事件，能咋滴？"><a href="#阻止默认事件，能咋滴？" class="headerlink" title="阻止默认事件，能咋滴？"></a>阻止默认事件，能咋滴？</h3><p>首先你得知道啥是默认事件，你知不知道？<br>不知道我告诉你呗，反正也是我百度的。职业复制粘贴工程师，给你复制一下：<br>就是浏览器通过 HTML 标签或 DOM 元素提供的一些功能性的默认行为。<br>比如在 a 标签 href 属性上的跳转，右键呼出的菜单，当你在一个 form 表单里点击提交按钮时网页会产生提交行为并刷新网页，当你网页上滚动鼠标滚轮时，网页的滚动条会动。<br>阻止默认事件就能阻止类似这些事</p><h3 id="同时阻止，能咋滴？"><a href="#同时阻止，能咋滴？" class="headerlink" title="同时阻止，能咋滴？"></a>同时阻止，能咋滴？</h3><p>不能咋滴，你 return false 🐂🍺</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就这两行玩意，不总结了奥。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阻止事件冒泡 阻止默认事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dom0-dom2</title>
    <link href="/2020/06/15/dom0-dom2/"/>
    <url>/2020/06/15/dom0-dom2/</url>
    
    <content type="html"><![CDATA[<h2 id="dom0"><a href="#dom0" class="headerlink" title="dom0"></a>dom0</h2><p>或者叫 0 级 dom ，如下</p><pre><code class="hljs scilab">&lt;input id=<span class="hljs-string">"btn"</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> onclick=<span class="hljs-string">"console.log('</span>You clicked the button!<span class="hljs-string">');"</span> value=<span class="hljs-string">"Click"</span> /&gt;<span class="hljs-comment">//  或者js写法</span>document.getElementById(<span class="hljs-string">'btn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;</span>            console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Ｉ　am ｐｒｏｃｅｓｓｅｄ by dom0!'</span>);        &#125;;</code></pre><h3 id="这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。"><a href="#这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。" class="headerlink" title="这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。"></a>这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。</h3><h2 id="dom2"><a href="#dom2" class="headerlink" title="dom2"></a>dom2</h2><p>或者叫 2 级 dom，继续如下呗</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'input'</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert('haha')"</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'fff'</span>)</span><span class="actionscript">     &#125;; <span class="hljs-comment">// 目标阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'mmm'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// 捕获阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'ooooo'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// 捕获阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'pppp'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">false</span>)  <span class="hljs-comment">// 冒泡阶段</span></span><span class="actionscript">     <span class="hljs-comment">// 兼容低版本IE的写法</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).attachEvent(<span class="hljs-string">"onclick"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'pppp'</span>)</span>     &#125;); <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // mmm ooooo fff pppp</code></pre><p>dom2 把事情分为 3 步 ———— 事件捕获阶段、处于目标阶段和事件冒泡阶段</p><pre><code class="hljs actionscript">addEventListener(<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;&#125;,<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>)<span class="hljs-comment">// 第一个参数，表明是啥触发事件</span><span class="hljs-comment">// 第二个参数，事件触发以后的回调函数</span><span class="hljs-comment">// 第三个参数，true或者false ，true是第二个参数那个回调函数在捕获阶段调用 ，false在冒泡阶段 ，默认是false</span><span class="hljs-comment">// 2015年底，扩展了第三个参数</span>el.addEventListener(type, listener, &#123;    capture: <span class="hljs-literal">false</span>, <span class="hljs-comment">// useCapture</span>    once: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// 是否设置单次监听</span>    passive: <span class="hljs-literal">false</span>  <span class="hljs-comment">// 是否让阻止默认行为preventDefault()失效</span>    <span class="hljs-comment">//  由于 touchmove 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止。那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。当设置了passive为true，则会忽略代码中的preventDefault(), 因此页面会变得更流畅</span>&#125;)</code></pre><p>window =&gt; document =&gt; body =&gt; div 捕获</p><p>div =&gt; body =&gt; document =&gt; window 冒泡</p><h3 id="这种写法，不会覆盖，会依次输出所有项"><a href="#这种写法，不会覆盖，会依次输出所有项" class="headerlink" title="这种写法，不会覆盖，会依次输出所有项"></a>这种写法，不会覆盖，会依次输出所有项</h3><p>顺便提一嘴 dom3 ，增加了更多的事件类型，比如：<br>       DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，全部类型如下：</p><p>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</p><p>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</p><p>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</p><p>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</p><p>文本事件，当在文档中输入文本时触发，如：textInput</p><p>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</p><p>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</p><p>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</p><p>同时 DOM3 级事件也允许使用者自定义一些事件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>区别：dom0 会覆盖，dom2 不会覆盖。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dom0 dom2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高阶函数</title>
    <link href="/2020/06/15/higher-order-function/"/>
    <url>/2020/06/15/higher-order-function/</url>
    
    <content type="html"><![CDATA[<h2 id="可以接收另一个参数作为参数的函数，就叫做高阶函数。"><a href="#可以接收另一个参数作为参数的函数，就叫做高阶函数。" class="headerlink" title="可以接收另一个参数作为参数的函数，就叫做高阶函数。"></a>可以接收另一个参数作为参数的函数，就叫做高阶函数。</h2><h3 id="常见高阶函数"><a href="#常见高阶函数" class="headerlink" title="常见高阶函数"></a>常见高阶函数</h3><ol><li>Array.prototype.map,</li><li>Array.prototype.filter,</li><li>Array.prototype.reduce,</li></ol><p>既然提到了这几个数组方法，那也就顺便说一说哈</p><ul><li>map 是啥，就不在这里说了，不知道就百度去。map() 方法的回调函数接受 3 个参数。 item index arraySelf 。 item 是数组的每一个元素 ，index 是该元素的下标（数组中的第几个元素），arraySelf 是调用 map 方法的这个数组，当然了，这些参数不是固定叫 item，index 啥的，这是入参，叫啥都行，位置对的上相应的位置就行。比如：</li></ul><pre><code class="hljs stata">[1,2,3].map((<span class="hljs-keyword">one</span>,<span class="hljs-keyword">two</span>,three)=&gt;&#123;  <span class="hljs-comment">// 这里的one就对应上面我说的item ，two就是index，这样说就能明白吧？</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">one</span> + <span class="hljs-keyword">two</span> + three.length&#125;)</code></pre><p>map 有返回值，会返回一个新的数组，而类似的 forEach（）方法，就没有返回值，所以哟，用 forEach 的时候经常会搭配 Array.push() 😁 还有啊，写 jsx 的时候，map 遍历出来的玩意你得加个 key 值，通常可以是 index，比如哈，我举个栗子 🌰</p><pre><code class="hljs javascript">&lt;ul&gt;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span> = <span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&#123;item&#125;</span> &gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>&#125;)&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><p>这玩意写的好像有点多余。。。好像会 map 的都能知道，不会 map 看了我这也看不懂。😂</p><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].filter(item=&gt;item &gt; <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].reduce((x,y)=&gt;&#123;<span class="hljs-keyword">return</span> x + y&#125;)</code></pre><p>react-redux</p><p>connect 方法 嘻嘻 弄一波这个～</p><p>connect 方法做的事情是将 state 和 dispatch 绑定到 Connect 组件的参数上，然后 Connect 组件将你当前的 App 组件封装起来，使得 App 组件可以通过 props 获取到父组件 Connect 传递的 state 和 props。</p><p>这也就是为什么你可以在自己写的组件上面直接通过 this.props 访问到 state 和 action。有的人是通过 store 去读取 state 和 dispatch action，也是一样的道理。</p><p>从 connect 方法的实现，我们看到了非常多 react 组件的影子，生命周期，props 传递，context 上下文。</p><p>对比 Provider 组件：</p><p>Provider 是顶层组件的作用，将 store 作为上下文提供给全局共享，而 Connect 组件是局部组件，将某个 react 组件包装起来，传递指定的 state 和 props 给该组件访问。</p><h3 id="非常遗憾，我没有彻底看懂-connect-的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解"><a href="#非常遗憾，我没有彻底看懂-connect-的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解" class="headerlink" title="非常遗憾，我没有彻底看懂 connect 的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解"></a>非常遗憾，我没有彻底看懂 connect 的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解</h3><p><a href="https://www.cnblogs.com/williamjie/p/9591826.html" target="_blank" rel="noopener">这是别人博客，connect 解析源码的</a></p><h4 id="发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个-480-行的源码还是不明白具体咋回事。"><a href="#发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个-480-行的源码还是不明白具体咋回事。" class="headerlink" title="发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个 480 行的源码还是不明白具体咋回事。"></a>发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个 480 行的源码还是不明白具体咋回事。</h4><pre><code class="hljs kotlin">export <span class="hljs-keyword">default</span> function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;<span class="hljs-keyword">return</span> function wrapWithConnect(WrappedComponent) &#123;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connect</span> <span class="hljs-title">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props, context) &#123;      <span class="hljs-comment">// 从祖先Component处获得store</span>      <span class="hljs-keyword">this</span>.store = props.store || context.store      <span class="hljs-keyword">this</span>.stateProps = computeStateProps(<span class="hljs-keyword">this</span>.store, props)      <span class="hljs-keyword">this</span>.dispatchProps = computeDispatchProps(<span class="hljs-keyword">this</span>.store, props)      <span class="hljs-keyword">this</span>.state = &#123; storeState: <span class="hljs-literal">null</span> &#125;      <span class="hljs-comment">// 对stateProps、dispatchProps、parentProps进行合并</span>      <span class="hljs-keyword">this</span>.updateState()    &#125;    shouldComponentUpdate(nextProps, nextState) &#123;      <span class="hljs-comment">// 进行判断，当数据发生改变时，Component重新渲染</span>      <span class="hljs-keyword">if</span> (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123;        <span class="hljs-keyword">this</span>.updateState(nextProps)          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;      &#125;      componentDidMount() &#123;        <span class="hljs-comment">// 改变Component的state</span>        <span class="hljs-keyword">this</span>.store.subscribe(() = &#123;          <span class="hljs-keyword">this</span>.setState(&#123;            storeState: <span class="hljs-keyword">this</span>.store.getState()          &#125;)        &#125;)      &#125;      render() &#123;        <span class="hljs-comment">// 生成包裹组件Connect</span>        <span class="hljs-keyword">return</span> (          &lt;WrappedComponent &#123;...<span class="hljs-keyword">this</span>.nextState&#125; /&gt;        )      &#125;    &#125;    Connect.contextTypes = &#123;      store: storeShape    &#125;    <span class="hljs-keyword">return</span> Connect;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高阶函数 react-redux connect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端路由</title>
    <link href="/2020/06/11/router-hash-history/"/>
    <url>/2020/06/11/router-hash-history/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是前端路由？"><a href="#什么是前端路由？" class="headerlink" title="什么是前端路由？"></a>什么是前端路由？</h2><p>路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p><h2 id="如何实现前端路由？"><a href="#如何实现前端路由？" class="headerlink" title="如何实现前端路由？"></a>如何实现前端路由？</h2><p>要实现前端路由，需要解决两个核心问题：</p><p>1.如何改变 URL 却不引起页面刷新？ 2.如何检测 URL 变化了？</p><h3 id="hash-实现"><a href="#hash-实现" class="headerlink" title="hash 实现"></a>hash 实现</h3><p>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新<br>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过标签改变 URL、通过 window.location 改变 URL，这几种情况改变 URL 都会触发 hashchange 事件</p><h3 id="history-实现"><a href="#history-实现" class="headerlink" title="history 实现"></a>history 实现</h3><p>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新<br>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过 pushState/replaceState 或标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState 的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</p><h2 id="hash-实现（简略版）"><a href="#hash-实现（简略版）" class="headerlink" title="hash 实现（简略版）"></a>hash 实现（简略版）</h2><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">ref=""&gt;    <span class="hljs-comment">&lt;!-- 定义路由 --&gt;</span></span><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/home"</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/about"</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>ref=<span class="hljs-string">""</span>&gt;    &lt;!-- 渲染路由对应的 UI --&gt;    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"routeView"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  &lt;/ul&gt;&lt;/body&gt;// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件<span class="hljs-keyword">window</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, onLoad)// 监听路由变化<span class="hljs-keyword">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, onHashChange)// 路由视图var routerView = null<span class="hljs-keyword">function</span> onLoad () &#123;  routerView =<span class="hljs-built_in"> document</span>.querySelector(<span class="hljs-string">'#routeView'</span>)  onHashChange()&#125;// 路由变化时，根据路由渲染对应 UI<span class="hljs-keyword">function</span> onHashChange () &#123;  <span class="hljs-keyword">switch</span> (location.hash) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">'#/home'</span>:      routerView.innerHTML = <span class="hljs-string">'Home'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">case</span> <span class="hljs-string">'#/about'</span>:      routerView.innerHTML = <span class="hljs-string">'About'</span>      <span class="hljs-keyword">return</span>    default:      <span class="hljs-keyword">return</span>  &#125;&#125;</code></pre><h2 id="history-实现（简略版）"><a href="#history-实现（简略版）" class="headerlink" title="history 实现（简略版）"></a>history 实现（简略版）</h2><pre><code class="hljs php">&lt;body&gt;  &lt;ul&gt;    &lt;li&gt;&lt;a href=<span class="hljs-string">'/home'</span>&gt;home&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=<span class="hljs-string">'/about'</span>&gt;about&lt;/a&gt;&lt;/li&gt;    &lt;div id=<span class="hljs-string">"routeView"</span>&gt;&lt;/div&gt;  &lt;/ul&gt;&lt;/body&gt;<span class="hljs-comment">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span>window.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, onLoad)<span class="hljs-comment">// 监听路由变化</span>window.addEventListener(<span class="hljs-string">'popstate'</span>, onPopState)<span class="hljs-comment">// 路由视图</span><span class="hljs-keyword">var</span> routerView = <span class="hljs-keyword">null</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLoad</span> <span class="hljs-params">()</span> </span>&#123;  routerView = document.querySelector(<span class="hljs-string">'#routeView'</span>)  onPopState() href=<span class="hljs-string">""</span>&gt;  <span class="hljs-comment">// 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。</span>  <span class="hljs-keyword">var</span> linkList = document.querySelectorAll(<span class="hljs-string">'a[href]'</span>)  linkList.<span class="hljs-keyword">forEach</span>(el =&gt; el.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>&#123;    e.preventDefault()    history.pushState(<span class="hljs-keyword">null</span>, <span class="hljs-string">''</span>, el.getAttribute(<span class="hljs-string">'href'</span>))    onPopState()  &#125;))&#125;<span class="hljs-comment">// 路由变化时，根据路由渲染对应 UI</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onPopState</span> <span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">switch</span> (location.pathname) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">'/home'</span>:      routerView.innerHTML = <span class="hljs-string">'Home'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">case</span> <span class="hljs-string">'/about'</span>:      routerView.innerHTML = <span class="hljs-string">'About'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span>  &#125;&#125;</code></pre><h2 id="总结：前端路由，在-SPA-单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。"><a href="#总结：前端路由，在-SPA-单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。" class="headerlink" title="总结：前端路由，在 SPA 单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。"></a>总结：前端路由，在 SPA 单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端路由 Hash History</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS模块化的发展历程</title>
    <link href="/2020/06/10/commonjs-amd-cmd/"/>
    <url>/2020/06/10/commonjs-amd-cmd/</url>
    
    <content type="html"><![CDATA[<p><strong>随便写点 js 模块化发展历史，面试有问这玩意的，随便看看到时候能答出来几句就 ok，顺便咱也了解一下 js 的这方面历史。</strong></p><p>1.js 的诞生：由 Brendan Eich 花了不到十天时间发明，用来在网页上进行表单校验、实现简单的动画效果等等，你可以回想一下那个网页上到处有公告块飘来飘去的时代。<br>2.2006 年 ajax 出现，js 开始发展。全局变量开始让人头疼了，函数命名开始冲突了 3.所以 js 需要，也必须要整模块化</p><p>需要解决的问题是：</p><ul><li>如何安全的包装一个模块的代码？（不污染模块外的任何代码）</li><li>如何唯一标识一个模块？</li><li>如何优雅的把模块的 API 暴漏出去？（不能增加全局变量）</li><li>如何方便的使用所依赖的模块？</li></ul><p>2009 年，node.js 诞生，这下模块化必须马上整了，要不然服务端没法弄了 所以 当当当当～ CommonJs 闪亮登场</p><h2 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h2><p>简单来说呢，commonJs 就是，exports 暴露 API，require 引入该 API 的模块，</p><p>缺点，得发请求啊 这玩意就不太好了</p><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>异步加载所需的模块，然后在回调函数中执行主逻辑。</p><p>缺点：预先下载太多东西，而且定义模块的时候写法复杂，最重要的是，它实时下载代码然后触发回调，主体代码运行。用户会有卡顿感。</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>淘宝前端 玉伯 整出来的，融各家所长，没啥缺点</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>2015 年 6 月，es6 来了，export 暴露，import 引入，编译时加载（静态加载）</p><h2 id="总结，就这点内容，还总结啥？告辞～"><a href="#总结，就这点内容，还总结啥？告辞～" class="headerlink" title="总结，就这点内容，还总结啥？告辞～"></a>总结，就这点内容，还总结啥？告辞～</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CommonJs AMD CMD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包，老铁安排上</title>
    <link href="/2020/06/09/bi-bao/"/>
    <url>/2020/06/09/bi-bao/</url>
    
    <content type="html"><![CDATA[<p>呱呱，啥是闭包？<br>天天写闭包，但是让表达出来，还真有点懵住了，<br>这玩意我都记在心里，话说不出口，都在酒里了，干杯～</p><p>—### 闭包是啥？</p><p>来几个官方回答，可以应付面试</p><ul><li>闭包是一个有自己环境的函数，并且在该环境中至少有一个变量。</li><li>闭包是将函数与其引用的周边状态绑定在一起形成（封装）的组合</li><li>闭包函数是声明在一个函数中的函数</li><li>闭包是内部函数总是可以访问其所在的外部函数中生命的参数和变量，即使在其外部函数被返回以后</li></ul><h3 id="闭包特点（优缺点都有哈）"><a href="#闭包特点（优缺点都有哈）" class="headerlink" title="闭包特点（优缺点都有哈）"></a>闭包特点（优缺点都有哈）</h3><ul><li><p>让外部访问函数内部变量成为可能；</p></li><li><p>局部变量会常驻在内存中；</p></li><li><p>可以避免使用全局变量，防止全局变量污染；(不用担心变量名重复，不过都 2020 年了，谁还频繁用 var 声明变量啊。)</p></li><li><p>会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p><p>闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。<strong>每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。</strong>但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。所以啊，当有很多很多闭包的时候，或者闭包被调用很多很多次的时候，那么就会内存泄漏了。</p></li></ul><p><em>然后面试的时候，可能会遇见一些笔试题，面试官整一个函数，让你写输出的值，设计个圈套坑你，怎么办？不慌！有秘诀～</em></p><p><strong>秘诀在此：输出的就是同一个地址中的爸爸函数中的变量值</strong></p><p>如此简单粗暴的秘诀，喜欢吗？</p><p>光说不练假把式，下面我来表演绝活：举个栗子 🌰</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funA</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// funA的活动对象之中;</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//匿名函数的活动对象;</span>        alert(a);  &#125;&#125;<span class="hljs-keyword">var</span> b = funA();b();<span class="hljs-comment">// 10</span></code></pre><p>由浅入深，先从这个简单的开始，套入秘诀，<em>同一个地址中的爸爸函数中的变量值</em> 啥叫同一个地址呢，就是被同一个人调用，在这个栗子里面，就是这个：</p><p>var b = funA（）<br>b()</p><p>这个 b 就是个地址，如果多一个 var c = funA（） 然后调用 c（），那么这个 c 就是另一个地址。</p><p>地址就明白了吧～<br>然后找爸爸，爸爸的爸爸叫什么，爸爸的的爸爸叫爷爷。。。哈哈 ，皮一下</p><p>回到找爹的正事上来，alert（a）是儿子，他爸在外边包住了它，就是这个 funA 是它爸。也可以理解为怀孕的母亲，和肚子里的孩子。（谁在里面谁儿子）</p><p>所以找到了它爸爸里面的变量 a=10 ，所以输出 10</p><p>好的，很开心，我们看下一个栗子 🌰</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zhujunFn</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xcolaFn</span>(<span class="hljs-params"></span>)</span>&#123;      i++;      <span class="hljs-built_in">console</span>.log(i);  &#125;  <span class="hljs-keyword">return</span> xcolaFn;&#125;<span class="hljs-keyword">var</span> aaa = zhujunFn();  <span class="hljs-comment">//每次外部函数执行的时候,外部函数的地址不同，都会重新创建一个新的地址,这个aaa是个新的地址</span>aaa();aaa();aaa();<span class="hljs-keyword">var</span> bbb = zhujunFn();  <span class="hljs-comment">//  所以这也是一个新的地址，aaa和bbb 是两个不同的地址</span>bbb();bbb();bbb();<span class="hljs-comment">// 1 2 3 1 2 3</span></code></pre><p>先重复一下我们的秘诀，然后找爹</p><ul><li><p><em>同一个地址中的爸爸函数中的变量值</em></p><p>aaa 和 bbb 分别是两个地址，是独立的</p><p>然后给这个 <strong>xcolaFn</strong> 找爹，是外边这个 <strong>zhujunFn</strong>，然后找到里面的这个变量 i，每次调用 aaa（）输出 i 为 1，2，3</p><p>每次调用 bbb（）是新的地址，独立的，所以也是一样的道理 输出 i 为 1，2，3</p></li></ul><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>; <span class="hljs-built_in">i</span>&lt;=<span class="hljs-number">5</span>; <span class="hljs-built_in">i</span>++) &#123; (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(j)</span> &#123;</span>setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span><span class="hljs-params">()</span> &#123; <span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">( j )</span>;</span>             &#125;, <span class="hljs-built_in">j</span>*<span class="hljs-number">1000</span> );         &#125;)( <span class="hljs-built_in">i</span> );&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我没啥想总结了，有营养的都在上边了，如果看完了发现还是不太明白，那一定是我没说清楚，不怪你，那就再看看这个人对闭包的理解吧，会有帮助的<br>链接在此：<a href="http://blog.xcola.top/2018/05/23/%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">请点击这里</a></p><p><strong>冲鸭，奥利给</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js事件循环机制</title>
    <link href="/2020/06/08/event-loop/"/>
    <url>/2020/06/08/event-loop/</url>
    
    <content type="html"><![CDATA[<ul><li>js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。</li><li>这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）</li></ul><ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li><li>如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行</li></ul><h5 id="看不懂没关系，先往下看，回过头来就理解这些了，老铁！"><a href="#看不懂没关系，先往下看，回过头来就理解这些了，老铁！" class="headerlink" title="看不懂没关系，先往下看，回过头来就理解这些了，老铁！"></a>看不懂没关系，先往下看，回过头来就理解这些了，老铁！</h5><h3 id="js-中的异步操作"><a href="#js-中的异步操作" class="headerlink" title="js 中的异步操作"></a>js 中的异步操作</h3><ul><li>setTimeOut</li><li>setInterval</li><li>ajax</li><li>promise</li><li>I/O</li></ul><h3 id="同步任务-异步任务"><a href="#同步任务-异步任务" class="headerlink" title="同步任务 - 异步任务"></a>同步任务 - 异步任务</h3><ul><li>同步任务是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务</li><li>异步任务 不进入主线程，而是进入 任务队列 ，只有 任务队列 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务 - 微任务"></a>宏任务 - 微任务</h3><ul><li>宏任务：整体代码 script/setTimeOut 等（new Promise 会进入主线程立刻执行，是主线程任务）</li><li>微任务：promise.then/promise.nextTick (node)</li></ul><hr><p>举个栗子</p><pre><code class="hljs fortran">console.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)setTimeOut(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)&#125;,<span class="hljs-number">0</span>)console.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)</code></pre><p>执行结果 1 3 2</p><p><strong>因为 setTimeOut 是异步任务，所以哪怕是 0 秒等待，也会等主线程任务都完事了以后才执行，下边是详细解析</strong></p><p>1.console.log(1)是同步任务，直接打印 1；</p><p>2.setTimeout 是异步任务，且是宏函数，放到宏函数队列中，等待下次 Event Loop 才会执行；</p><p>3.console.log(3)是同步任务，直接打印 3；</p><p>4.主线程执行完毕，没有微任务，那么执行第二个宏任务 setTimeout，打印 2；</p><p>5.结果：1，3，2</p><p><strong>也就是说，如果有 promise，那是同步任务，等所有同步任务完事，开始执行这个 promise.then，再然后才是 setTimeOut 啥的。</strong></p><hr><p>举个栗子</p><pre><code class="hljs lisp">setTimeout(<span class="hljs-name">function</span>()&#123;    console.log(<span class="hljs-number">1</span>)&#125;)<span class="hljs-comment">;</span>new Promise(<span class="hljs-name">function</span>(<span class="hljs-name">resolve</span>)&#123;    console.log(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>    for(<span class="hljs-name">var</span> i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10000; i++)&#123;</span>        i == <span class="hljs-number">9999</span> <span class="hljs-symbol">&amp;&amp;</span> resolve()<span class="hljs-comment">;</span>    &#125;&#125;).then(<span class="hljs-name">function</span>()&#123;    console.log(<span class="hljs-number">3</span>)&#125;)<span class="hljs-comment">;</span>console.log(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span></code></pre><p>输出 2 ， 4 ， 3， 1</p><p>1.setTimeout 是异步，且是宏函数，放到宏函数队列中；</p><p>2.new Promise 是同步任务，直接执行，打印 2，并执行 for 循环；</p><p>3.promise.then 是微任务，放到微任务队列中；</p><p>4.console。log(4)同步任务，直接执行，打印 4；</p><p>5.此时主线程任务执行完毕，检查微任务队列中，有 promise.then，执行微任务，打印 3，</p><p>6.微任务执行完毕，第一次循环结束；从宏任务队列中取出第一个宏任务到主线程执行，打印 1</p><hr><p><em>再举个厉害的栗子吧</em></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer1</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)  &#125;, <span class="hljs-number">1000</span>)&#125;add();setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer2</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer3</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)  &#125;, <span class="hljs-number">100</span>)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;    i == <span class="hljs-number">99</span> &amp;&amp; resolve()  &#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer4</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)  &#125;, <span class="hljs-number">0</span>)  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>)</code></pre><p>结果 1， 4， 8， 7， 3， 6， 5， 2，<br>这就不解析了，这回弄懂了吧。</p><hr><p><strong>总结：这是个循环，第一次循环先搞定所有主线程任务，完事以后看看有没有微任务，如果有，执行，然后结束第一次循环，如果没有，就直接结束第一次循环，，，然后开始第二次循环，找到宏任务里边最先执行那个，执行，所有都执行完事，然后看有没有微任务，如果有。。。如果没有。。。。你看这句话上面也说过，这就是循环啊，然后继续循环啊，直到没有宏任务，也没有微任务。循环就完事了呗</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js运行循环机制 宏任务 微任务 同步任务 异步任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好的开始，我只是想变强</title>
    <link href="/2020/06/08/my-first/"/>
    <url>/2020/06/08/my-first/</url>
    
    <content type="html"><![CDATA[<h3 id="so-what-can-i-do"><a href="#so-what-can-i-do" class="headerlink" title="so what can i do"></a>so what can i do</h3><p>先写个开头，顺便复习一下 markdown，是的，没错，我又忘记 markdown 怎么用了，为了避免再次忘记，要尽量多的使用，<br>比如</p><ul><li>1 尽量频繁的写博客</li><li>2 尽量频繁的写博客</li><li>3 还是 tmd 尽量频繁的写博客</li></ul><p>无序列表用*<br>有序列表用 1.</p><p>比如</p><ol><li>这是有序的</li><li>我是有头发的</li><li>第三条不重要</li></ol><p>加个大于号 后边是文字 展示效果是引用</p><blockquote><p>这是鲁迅说的 —— 周树人</p></blockquote><p>插入链接 <a href="就当这里有链接">xxx</a> 英文书名号加小括号</p><p>插入图片 前边有个感叹号 <img src="%E5%B0%B1%E5%BD%93%E8%BF%99%E9%87%8C%E6%9C%89%E9%93%BE%E6%8E%A5%E5%90%A7" srcset="/img/loading.gif" alt="假装有图.jpg"> 英文感叹号加书名号加小括号</p><p><strong>左右各两个星号中间夹的会加粗，请给我加粗</strong><br><em>左右各一个星号就倾斜</em></p><p>模版字符串中间可以放代码，比如<br><code>const wanghao = &#39;辣鸡&#39;</code><br>左右各三个这玩意，可以夹住代码块，let me try try<br>···不好意思，整错了···</p><pre><code class="hljs ebnf"><span class="hljs-attribute">let a</span> = 1;<span class="hljs-attribute">a</span> = 2;<span class="hljs-attribute">a</span> = b = 2;</code></pre><p>tab 可以缩进，这就是为啥现在才有缩进，我刚看到。<br>非常开心，再来几个缩进<br>三个星号是分割线</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><p>啊。。。失败的 markdown 表格，为啥表格没好使呢？(之前这里没有展示为表格，后来自动格式化，，，能成功展示了)</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><p>markdown 表格没好使的原因是 我在|后面习惯性的加了空格。导致 markdown 没能识别这种。行那我们继续，上面失败的的就不删除了</p><hr><p><strong>行，这就算复习完事，接下来我随便写写。</strong><br><strong>别问我为啥加粗，我就喜欢粗，并且不缩进，真男人从来不做缩头乌龟</strong></p><h2 id="我还能更粗"><a href="#我还能更粗" class="headerlink" title="我还能更粗"></a>我还能更粗</h2><p>最近经历了好多的事情，事情都是相对的，辩证去看，也无所谓好坏。<br>但是很多事情，我都不喜欢，不如意事常八九，可与人言无二三。<br>敲了很多字，又都删掉了。觉得没有意义。自己和自己的辩论，总归赢的也是自己。<br>自己和自己探讨人生观，价值观，也未免太无趣，还要写在这里记录下来，也未免太他妈的无趣<br>总而言之，我就一句话，我想变强。</p><hr><p><em>我没觉得喜欢这个行业，但是我喜欢自己变强的感觉。</em></p><p>开始整活！<br><strong>奥利给</strong></p>]]></content>
    
    
    <categories>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加油</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/06/05/hello-world/"/>
    <url>/2020/06/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

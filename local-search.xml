<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>antd3/4 组件进阶 嘟嘟嘟</title>
    <link href="/2020/11/12/antd3-4diff/"/>
    <url>/2020/11/12/antd3-4diff/</url>
    
    <content type="html"><![CDATA[<h3 id="ANT-Design3-4-组件对比"><a href="#ANT-Design3-4-组件对比" class="headerlink" title="ANT Design3/4 组件对比"></a>ANT Design3/4 组件对比</h3><p>我写成 ppt 了，哈哈哈哈</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>antd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有趣的cowsay</title>
    <link href="/2020/10/20/cowsay/"/>
    <url>/2020/10/20/cowsay/</url>
    
    <content type="html"><![CDATA[<p>序：<br>好玩的 cowsay，在命令行里整出各种图。</p><p>比如</p><pre><code class="hljs tex">cowsay -f cat2 你好，朱军 ________&lt; 你好，朱军 &gt; --------       <span class="hljs-tag">\</span>        <span class="hljs-tag">\</span>         <span class="hljs-tag">\</span>          <span class="hljs-tag">\</span>          |<span class="hljs-tag">\<span class="hljs-name">_</span></span>__/|         =) oYo (=          <span class="hljs-tag">\<span class="hljs-name"> </span></span> ^  /           )=*=(          /     <span class="hljs-tag">\</span>          |     |         /| | | |<span class="hljs-tag">\</span>         <span class="hljs-tag">\<span class="hljs-name">|</span></span> | |_|/<span class="hljs-tag">\</span>         //_// ___/             <span class="hljs-tag">\<span class="hljs-name">_</span></span>)cowsay 你瞅啥？ ________________&lt; 你瞅啥？ &gt; ----------------        <span class="hljs-tag">\<span class="hljs-name"> </span></span>  ^__^         <span class="hljs-tag">\<span class="hljs-name"> </span></span> (oo)<span class="hljs-tag">\<span class="hljs-name">_</span></span>______            (__)<span class="hljs-tag">\<span class="hljs-name"> </span></span>      )<span class="hljs-tag">\<span class="hljs-name">/</span></span><span class="hljs-tag">\</span>                ||----w |                ||     || cowsay -f dragon-and-cow 巨龙喷火！  ____________&lt; 巨龙喷火！ &gt; ------------                       <span class="hljs-tag">\<span class="hljs-name"> </span></span>                   ^    /^                        <span class="hljs-tag">\<span class="hljs-name"> </span></span>                 / <span class="hljs-tag">\<span class="hljs-name"> </span></span> // <span class="hljs-tag">\</span>                         <span class="hljs-tag">\<span class="hljs-name"> </span></span>  |<span class="hljs-tag">\<span class="hljs-name">_</span></span>__/|      /   <span class="hljs-tag">\<span class="hljs-name">/</span></span>/  .<span class="hljs-tag">\</span>                          <span class="hljs-tag">\<span class="hljs-name"> </span></span> /O  O  <span class="hljs-tag">\<span class="hljs-name">_</span></span>_  /    //  | <span class="hljs-tag">\<span class="hljs-name"> </span></span><span class="hljs-tag">\<span class="hljs-name"> </span></span>          *----*                            /     /  <span class="hljs-tag">\<span class="hljs-name">/</span></span>_/    //   |  <span class="hljs-tag">\<span class="hljs-name"> </span></span> <span class="hljs-tag">\<span class="hljs-name"> </span></span>         <span class="hljs-tag">\<span class="hljs-name"> </span></span>  |                            @___@`    <span class="hljs-tag">\<span class="hljs-name">/</span></span>_   //    |   <span class="hljs-tag">\<span class="hljs-name"> </span></span>  <span class="hljs-tag">\<span class="hljs-name"> </span></span>        <span class="hljs-tag">\<span class="hljs-name">/</span></span><span class="hljs-tag">\<span class="hljs-name"> </span></span><span class="hljs-tag">\</span>                           0/0/|       <span class="hljs-tag">\<span class="hljs-name">/</span></span>_ //     |    <span class="hljs-tag">\<span class="hljs-name"> </span></span>   <span class="hljs-tag">\<span class="hljs-name"> </span></span>        <span class="hljs-tag">\<span class="hljs-name"> </span></span> <span class="hljs-tag">\</span>                       0/0/0/0/|        <span class="hljs-tag">\<span class="hljs-name">/</span></span>//      |     <span class="hljs-tag">\<span class="hljs-name"> </span></span>    <span class="hljs-tag">\<span class="hljs-name"> </span></span>      |  |                    0/0/0/0/0/_|_ /   (  //       |      <span class="hljs-tag">\<span class="hljs-name"> </span></span>    _<span class="hljs-tag">\<span class="hljs-name"> </span></span>    |  /                 0/0/0/0/0/0/`/,_ _ _/  ) ; -.    |    _ _<span class="hljs-tag">\<span class="hljs-name">.</span></span>-~       /   /                             ,-&#125;        _      *-.|.-~-.           .~    ~            <span class="hljs-tag">\<span class="hljs-name"> </span></span>    <span class="hljs-tag">\<span class="hljs-name">_</span></span>_/        `/<span class="hljs-tag">\<span class="hljs-name"> </span></span>     /                 ~-. _ .-~      /             <span class="hljs-tag">\<span class="hljs-name">_</span></span>___(oo)           *.   &#125;            &#123;                   /             (    (--)          .----~-.<span class="hljs-tag">\<span class="hljs-name"> </span></span>       <span class="hljs-tag">\<span class="hljs-name">-</span></span>`                 .~             //__<span class="hljs-tag">\<span class="hljs-name"> </span></span> <span class="hljs-tag">\<span class="hljs-name">_</span></span>_ 金凤娇救我!   ///.----..&lt;        <span class="hljs-tag">\<span class="hljs-name"> </span></span>            _ -~            //    <span class="hljs-tag">\<span class="hljs-name">\</span></span>               ///-._ _ _ _ _ _ _&#123;^ - - - - ~</code></pre><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>npm install -g cowsay</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在命令行敲： cowsay 随便文字字母啥的</p><ul><li><p>cowsay -l ： 查看其他动物</p></li><li><p>cowsay -f 其他动物代号 动物说的话 ：使用其他动物</p></li></ul><p>在代码注释里秀：</p><pre><code class="hljs groovy">var cowsay = require(<span class="hljs-string">"cowsay"</span>);console.log(cowsay.say(&#123;<span class="hljs-string">text :</span> <span class="hljs-string">"I'm a moooodule"</span>,<span class="hljs-string">e :</span> <span class="hljs-string">"oO"</span>,<span class="hljs-string">T :</span> <span class="hljs-string">"U "</span>&#125;));<span class="hljs-comment">// or cowsay.think()</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大奶牛哈哈哈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node</title>
    <link href="/2020/10/20/node/"/>
    <url>/2020/10/20/node/</url>
    
    <content type="html"><![CDATA[<p>序言<br>准备学习 node<br>多学几个框架</p><p>注：node 官网有对 package.json 的指南</p><h3 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h3><p>基于 Node.js 平台的下一代 web 开发框架</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<span class="hljs-comment">// x-response-time</span>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();  <span class="hljs-keyword">await</span> next();  <span class="hljs-keyword">const</span> ms = <span class="hljs-built_in">Date</span>.now() - start;  ctx.set(<span class="hljs-string">'X-Response-Time'</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;ms&#125;</span>ms`</span>);&#125;);<span class="hljs-comment">// logger</span>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();  <span class="hljs-keyword">await</span> next();  <span class="hljs-keyword">const</span> ms = <span class="hljs-built_in">Date</span>.now() - start;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;ctx.method&#125;</span> <span class="hljs-subst">$&#123;ctx.url&#125;</span> - <span class="hljs-subst">$&#123;ms&#125;</span>`</span>);&#125;);<span class="hljs-comment">// response</span>app.use(<span class="hljs-keyword">async</span> ctx =&gt; &#123;  ctx.body = <span class="hljs-string">'Hello World'</span>;&#125;);app.listen(<span class="hljs-number">3000</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟我一起学习缓存吧</title>
    <link href="/2020/10/14/cache/"/>
    <url>/2020/10/14/cache/</url>
    
    <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>尝试用新的学习方法，学习缓存。<br>一直对缓存的了解都比较少，开始学习</p><h2 id="前端缓存"><a href="#前端缓存" class="headerlink" title="前端缓存"></a>前端缓存</h2><p>通过缓存可以让性能——将相应数据存储起来以避免数据的重复创建、处理和传输，可有效提高性能。比如将不改变的数据缓存起来，例如国家列表等，这样能明显提高 web 程序的反应速度；</p><p>· 稳定性——同一个应用中，对同一数据、逻辑功能和用户界面的多次请求时经常发生的。当用户基数很大时，如果每次请求都进行处理，消耗的资源是很大的浪费，也同时造成系统的不稳定。例如，web 应用中，对一些静态页面的呈现内容进行缓存能有效的节省资源，提高稳定性。而缓存数据也能降低对数据库的访问次数，降低数据库的负担和提高数据库的服务能力；</p><p>· 可用性——有时，提供数据信息的服务可能会意外停止，如果使用了缓存技术，可以在一定时间内仍正常提供对最终用户的支持，提高了系统的可用性。</p><p>·减少交互的通讯量——缓存数据能有效减少在进程和机器间的传输量；</p><p>·降低系统中的处理量——减少处理次数；</p><p>·降低需要做的磁盘访问次数——比如缓存在内存中的数据。</p><h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><ul><li>值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据；</li><li>到期时间是由服务端生成的，客户端时间跟服务端时间可能存在误差，这就会导致缓存命中的误差；</li><li>被 Cache-Control 替代</li></ul><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><pre><code class="hljs yaml"><span class="hljs-attr">Accept:</span> <span class="hljs-string">*/*</span><span class="hljs-attr">Accept-Encoding:</span> <span class="hljs-string">gzip,</span> <span class="hljs-string">deflate,</span> <span class="hljs-string">br</span><span class="hljs-attr">Accept-Language:</span> <span class="hljs-string">zh-CN,zh;q=0.9</span><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal">no</span><span class="hljs-string">-cache</span><span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">7298</span><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/plain;charset=UTF-8</span><span class="hljs-attr">Host:</span><span class="hljs-attr">Origin: https:</span><span class="hljs-attr">Pragma:</span> <span class="hljs-literal">no</span><span class="hljs-string">-cache</span><span class="hljs-attr">Referer:</span> <span class="hljs-string">https://</span><span class="hljs-attr">Sec-Fetch-Dest:</span> <span class="hljs-string">empty</span><span class="hljs-attr">Sec-Fetch-Mode:</span> <span class="hljs-string">cors</span><span class="hljs-attr">Sec-Fetch-Site:</span> <span class="hljs-string">same-site</span><span class="hljs-attr">User-Agent:</span> <span class="hljs-string">Mozilla/5.0</span> <span class="hljs-string">(Macintosh;</span> <span class="hljs-string">Intel</span> <span class="hljs-string">Mac</span> <span class="hljs-string">OS</span> <span class="hljs-string">X</span> <span class="hljs-string">10_14_6)</span> <span class="hljs-string">AppleWebKit/537.36</span> <span class="hljs-string">(KHTML,</span> <span class="hljs-string">like</span> <span class="hljs-string">Gecko)</span> <span class="hljs-string">Chrome/86.0.4240.75</span> <span class="hljs-string">Safari/537.36</span><span class="hljs-attr">x-log-apiversion:</span> <span class="hljs-number">0.6</span><span class="hljs-number">.0</span><span class="hljs-attr">x-log-bodyrawsize:</span> <span class="hljs-number">1234</span></code></pre><p>在请求头的里面，Request Headers 有 Cache-Control，里面的一些属性意义如下</p><p>public</p><p>所有内容都将被缓存(客户端和代理服务器都可缓存)</p><p>private</p><p>内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)</p><p>no-cache</p><p>必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。</p><p>no-store</p><p>所有内容都不会被缓存到缓存或 Internet 临时文件中</p><p>must-revalidation/proxy-revalidation</p><p>如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证</p><p>max-age=xxx</p><p>缓存的内容将在 xxx 秒后失效, 这个选项只在 HTTP 1.1 可用, 并如果和 Last-Modified 一起使用时, 优先级较高</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>（相当于就是浏览器与服务器通过一个值作为更新 flag，一个协商一个判断）<br>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p><h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h5><p>当浏览器请求服务器的某项资源（A）时，服务器会根据 A 算出一个哈希值，并通过 Etag 返回给浏览器，浏览器把 ETAG 和资源 A 同时缓存到本地。<br>当下次向服务器请求该资源时，会通过 If-None-Match 把 ETAG 发送给服务器。<br>服务器再次计算 A 的哈希值并和浏览器的返回值作比较，如果 A 发生了变化就把 A 返回给浏览器（返回值 200）,如果未发生变化就返回浏览器 304（未修改）</p><p>换种理解方式：<br>如果缓存中有 ETag 令牌，客户端请求时会自动在“If-None-Match” HTTP 请求标头内提供 ETag 令牌。<br>服务器根据当前资源核对令牌，验证是否发生变化，将验证结果通知给客户端，客户端根据结果看看是否需要从缓存中读取还是发送资源请求。</p><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p>在浏览器请求服务器的某项资源时，返回资源的同时还有一个 Last-Modified 的属性标记此文件在服务器端的最后修改时间；<br>浏览器第二次访问该资源时，会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否被修改过；<br>如果服务器的资源没有变化，则时间一致，返回 304 的状态吗，浏览器使用本地缓存；<br>如果时间不一致，返回 200，显示新文件并缓存。</p><h5 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h5><p>Etag 是标识传输，Last-Modified 是时间传输;<br>Etag 的优先级高于 Last-Modified;<br>Last-modified 标注的最后修改时间只能精确到秒，如果文件在 1 秒以内被多次修改，它不能准确标注文件的最后修改时间；<br>如果文件定期生成，但内容没有任何变化，但是 last-modified 却改变了，导致没法使用缓存；<br>有可能存在服务器没有准确获取文件修改时间，或与代理服务器时间不一致的情况；<br>etag 每次服务端生成都需要进行读写操作，而 last-modified 只需要读取操作，etag 消耗更大些；</p><h4 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h4><p>强缓存规则：</p><p>已失效时，请求服务器，服务器返回数据和缓存规则，客户端将数据和缓存规则存入缓存数据库；<br>未失效时，请求缓存数据库，返回数据并渲染；<br>协商缓存规则：</p><p>先到缓存数据库中获取标识 Etag/Last-Modified，<br>再通过 If-None-Match/If-Modified-Since 字段带上缓存标识请求服务器，服务器判断内容是否失效；</p><p>顺序：<br>强缓存未失效，从缓存中读取数据，cache-control 优先级高于 Expires；<br>强缓存已失效，执行协商缓存，Etag 的优先级高于 last-Modified；<br>缓存未失效从缓存中读取数据返回 304 状态码；<br>缓存已失效返回资源和 200 状态码；</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><h4 id="本地小容量缓存"><a href="#本地小容量缓存" class="headerlink" title="本地小容量缓存"></a>本地小容量缓存</h4><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><h5 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h5><p>localStorage.setItem(“key”,value)<br>var value=localStorage.getItem(“key”)<br>localStorage.removeItem(key);</p><h5 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h5><h4 id="本地大容量缓存"><a href="#本地大容量缓存" class="headerlink" title="本地大容量缓存"></a>本地大容量缓存</h4><h5 id="WebSql"><a href="#WebSql" class="headerlink" title="WebSql"></a>WebSql</h5><p>用 sql 操作数据库</p><h5 id="IndexDB"><a href="#IndexDB" class="headerlink" title="IndexDB"></a>IndexDB</h5><p>也是数据库</p><h3 id="应用程序缓存"><a href="#应用程序缓存" class="headerlink" title="应用程序缓存"></a>应用程序缓存</h3><h4 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h4><h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4> <!--  *   *                             _ooOoo_ *                            o8888888o *                            88" . "88 *                            (| -_- |) *                            O\  =  /O *                         ____/`---'\____ *                       .'  \\|     |//  `. *                      /  \\|||  :  |||//  \ *                     /  _||||| -:- |||||-  \ *                     |   | \\\  -  /// |   | *                     | \_|  ''\---/''  |   | *                     \  .-\__  `-`  ___/-. / *                   ___`. .'  /--.--\  `. . __ *                ."" '<  `.___\_<|>_/___.'  >'"". *               | | :  `- \`.;`\ _ /`;.`/ - ` : | | *               \  \ `-.   \_ __\ /__ _/   .-` /  / *          ======`-.____`-.___\_____/___.-`____.-'====== *                             `=---=' *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ *                     佛祖保佑        永无BUG *            佛曰: *                   写字楼里写字间，写字间里程序员； *                   程序人员写程序，又拿程序换酒钱。 *                   酒醒只在网上坐，酒醉还来网下眠； *                   酒醉酒醒日复日，网上网下年复年。 *                   但愿老死电脑间，不愿鞠躬老板前； *                   奔驰宝马贵者趣，公交自行程序员。 *                   别人笑我忒疯癫，我笑自己命太贱； *                   不见满街漂亮妹，哪个归得程序员？  -->]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存 cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件卸载生命周期遇见的坑</title>
    <link href="/2020/10/13/componentwillunmount/"/>
    <url>/2020/10/13/componentwillunmount/</url>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>刚刚在敲码时候遇见了个离谱的问题，排查发现与组件卸载相关。<br>刚好写个博，一来趁热记录一下刚刚走过的坑，二来总结学习一下相关的问题其余的坑。</p><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在页面挂载了一个 pubsub 监听程序，，啊，突然发现 pubsub 使用方法的博客还没写，留了个坑<br>问题是触发该 pubsub 的时候，本该执行一次的函数被执行了多次，并且发现每次热更新就会多执行一次函数</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>经过排查啊，页面组件是只加载一次的，所以就一定是 pubsub 的监听被触发了多次或者生成了多个监听程序</p><h3 id="上代码实战分析"><a href="#上代码实战分析" class="headerlink" title="上代码实战分析"></a>上代码实战分析</h3><pre><code class="hljs typescript">PubSub.subscribe(<span class="hljs-string">'电子签名'</span>, <span class="hljs-function">(<span class="hljs-params">keyword, data</span>) =&gt;</span> &#123;     <span class="hljs-keyword">const</span> &#123; functionalModuleId, caseName, caseObject, okFn, ...rest &#125; = data;     <span class="hljs-keyword">const</span> eSignAuth = getEsignAuthorities().find(       item =&gt; <span class="hljs-string">`<span class="hljs-subst">$&#123;item.id&#125;</span>`</span> === <span class="hljs-string">`<span class="hljs-subst">$&#123;functionalModuleId&#125;</span>`</span>,     ); <span class="hljs-comment">// 获取电子签名权限信息</span>     <span class="hljs-comment">//  判断电子签名是否开启</span>     <span class="hljs-keyword">const</span> newDisabled = !(       eSignAuth &amp;&amp;       (eSignAuth.electronicSignatureIdentifier === <span class="hljs-number">1</span> ||         eSignAuth.electronicSignatureIdentifier === <span class="hljs-number">3</span>)     );     <span class="hljs-keyword">if</span> (!functionalModuleId || newDisabled) &#123;       okFn(&#123;&#125;);       <span class="hljs-keyword">return</span>;     &#125;     <span class="hljs-keyword">this</span>.setState(&#123;       isModalShow: <span class="hljs-literal">true</span>,       functionalModuleId,       caseName,       caseObject,       okFn,       ...rest,     &#125;);   &#125;);</code></pre><p>原来上面这段代码写在 componentDidMount 的生命周期里。后来放进类构造函数里，用 componentWillUnmount 处理<br>代码如下</p><pre><code class="hljs kotlin">componentDidMount() &#123;  <span class="hljs-keyword">this</span>.esignPubsub;&#125;componentWillUnmount() &#123;  PubSub.unsubscribe(<span class="hljs-keyword">this</span>.esignPubsub);&#125;</code></pre><p>这里其实还涉及一些其他的点，比如<br>热更新 websocket 推送过去的，只更新变化的 bundle。<br>浏览器刷新全量更新除缓存外所有文件。</p><p>所以每次保存代码热更新，，都没有清空上一次程序的线程，会导致多次运行同一个程序<br>类似的还有：</p><p>websocket 的运行等</p><h4 id="这个组件卸载的生命周期啊，就是这个-componentWillUnmount-生命周期还要注意定时器的清楚。这已经是老生常谈了哈哈哈"><a href="#这个组件卸载的生命周期啊，就是这个-componentWillUnmount-生命周期还要注意定时器的清楚。这已经是老生常谈了哈哈哈" class="headerlink" title="这个组件卸载的生命周期啊，就是这个 componentWillUnmount 生命周期还要注意定时器的清楚。这已经是老生常谈了哈哈哈"></a>这个组件卸载的生命周期啊，就是这个 componentWillUnmount 生命周期还要注意定时器的清楚。这已经是老生常谈了哈哈哈</h4><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>解决这个问题还是收获挺多的。挺开心。以前害怕遇见问题解决不了，现在希望能遇见更多的问题，从中学到更多的遗漏的知识点。<br>心态的改变，也印证了自我的成长。继续前行吧</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件卸载 componentWillUnmount</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电影《我和我的家乡》</title>
    <link href="/2020/10/10/movie1014/"/>
    <url>/2020/10/10/movie1014/</url>
    
    <content type="html"><![CDATA[<h3 id="先整个序"><a href="#先整个序" class="headerlink" title="先整个序"></a>先整个序</h3><p>是的没错，我把原来的内容屏蔽了</p><!-- 其实不太想写，看完这电影没啥想写的。。并不是我非得看小众电影，瞧不上大众电影。只是觉得这种所谓的喜剧片没有笑点，是真的尬啊电影分为五个单元，依次写感想了### 电影#### 《北京好人》整体观感不错，虽然能猜到 70%的笑点，但是毕竟又葛优葛大爷的演技加成，还挺好看的。普通人的视角，普通人的生活。剧情人物冲突也比较明显，起承转合比较合适。故事线简单，完整。想买车=》表舅生病借钱=》骗医保=》骗医保失败=》放弃买车钱给表舅治病=》表舅自己有医保有因有果的剧情，没有硬伤。宁浩 葛优 很难拉垮的组合啊综合来说，给 4 星#### 《天上掉下个 UFO》无聊，能猜到 100%的笑点，并且真的很难笑出来。黄渤，王宝强，刘昊然，佟丽娅。 导演陈思成，就这？就这？？？没劲，没笑点，剧情生硬，人物冲突不和谐。没有把佟丽娅拍的足够美。要看点没看点，要笑点没笑点打分？ 1 星#### 《回乡之路》这看个开头就能猜到结尾的剧情，又能有多少惊喜呢？人物简单，剧情简单，反转的喜剧效果完全没有感受到就挺无聊的打分 1 星半#### 《最后一课》演技好评，剧情一般。主要是这演员里就没有拉垮的人范伟 徐峥 张译 雷佳音 于和伟 陶虹，这怎么拉垮？夸范伟的已经太多了，我就不多说了剧情真有点生硬。笑点，，，可能是那只鸡。也可能是我笑点高？？别的地方真没觉得好笑啊浙江淳安，我去过，千岛湖嘛综合给 3 星半#### 《神笔马亮》剧情比较满，没有硬伤，也没啥惊喜。虽然这个单元受到了大家的好评，但是笑点不多，故事设定有点假。毛衣梗，定格梗啥的没觉得好笑啊打分 3 星 --><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>无聊可以看看，不推荐特意去看。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>监听与触发机制——pubsub</title>
    <link href="/2020/10/09/pubsub/"/>
    <url>/2020/10/09/pubsub/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚刚敲完组件卸载那个博客，趁热来填坑。pubsub 这个是前一段接触到的，为了实现全局性的事件触发。<br>触发一个事件，调用对应的函数。同样的功能我能用另外两种方式实现<br>不过用这个新的技术，也挺好，也不是坏事。<br>多学会个东西总是好的。遇见新东西还是不要抵触。</p><h3 id="pubsub-使用"><a href="#pubsub-使用" class="headerlink" title="pubsub 使用"></a>pubsub 使用</h3><p>分为几步<br>引入<br>注册事件<br>触发事件<br>销毁</p><pre><code class="hljs typescript"><span class="hljs-comment">//  引入</span><span class="hljs-keyword">import</span> PubSub <span class="hljs-keyword">from</span> <span class="hljs-string">'pubsub-js'</span><span class="hljs-comment">//  注册事件</span><span class="hljs-keyword">var</span> token = PubSub.subscribe(<span class="hljs-string">'MY TOPIC'</span>, <span class="hljs-function">(<span class="hljs-params">msg,data</span>)=&gt;</span> <span class="hljs-built_in">console</span>.log(msg,data))<span class="hljs-comment">// msg第一个参数是事件名，这里就是“MY TOPIC”</span><span class="hljs-comment">// data是触发事件的时候传过来的参数</span><span class="hljs-comment">//  触发事件</span>PubSub.publish(<span class="hljs-string">'MY TOPIC'</span>, <span class="hljs-string">'hello world!'</span>);<span class="hljs-comment">//  这里的“hello world”会被当作参数传过去</span><span class="hljs-comment">//  注销</span>PubSub.unsubscribe(token);</code></pre><p>总体来说，还是比较简单的</p><h3 id="实战代码"><a href="#实战代码" class="headerlink" title="实战代码"></a>实战代码</h3><pre><code class="hljs kotlin"><span class="hljs-comment">//  注册</span>    <span class="hljs-keyword">this</span>.esignPubsub = PubSub.subscribe(<span class="hljs-string">'电子签名'</span>, (keyword, <span class="hljs-keyword">data</span>) =&gt; &#123;      <span class="hljs-keyword">const</span> &#123; functionalModuleId, caseName, caseObject, okFn, ...rest &#125; = <span class="hljs-keyword">data</span>;      <span class="hljs-keyword">const</span> eSignAuth = getEsignAuthorities().find(        item =&gt; `$&#123;item.id&#125;` === `$&#123;functionalModuleId&#125;`,      ); <span class="hljs-comment">// 获取电子签名权限信息</span>      <span class="hljs-comment">//  判断电子签名是否开启</span>      <span class="hljs-keyword">const</span> newDisabled = !(        eSignAuth &amp;&amp;        (eSignAuth.electronicSignatureIdentifier === <span class="hljs-number">1</span> ||          eSignAuth.electronicSignatureIdentifier === <span class="hljs-number">3</span>)      );      <span class="hljs-keyword">if</span> (!functionalModuleId || newDisabled) &#123;        okFn(&#123;&#125;);        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">this</span>.setState(&#123;        isModalShow: <span class="hljs-literal">true</span>,        functionalModuleId,        caseName,        caseObject,        okFn,        ...rest,      &#125;);    &#125;);  componentDidMount() &#123;    <span class="hljs-keyword">this</span>.esignPubsub;  &#125;<span class="hljs-comment">//  触发</span>        PubSub.publish(<span class="hljs-string">'电子签名'</span>, &#123;                    functionalModuleId: <span class="hljs-string">'2003000003'</span>,                    caseName: record.fileName,                    caseObject: <span class="hljs-string">'fileName'</span>,                    okFn: (&#123; signature &#125;) =&gt; &#123;                      saveRecord(&#123;                        ...record,                        ...newRecord,                        signature,                      &#125;).then((&#123; success, response &#125;) =&gt; &#123;                        <span class="hljs-keyword">if</span> (success) &#123;                          loadRecords();                          modalSuccess();                        &#125; <span class="hljs-keyword">else</span> &#123;                          message.error(response.<span class="hljs-keyword">data</span>.message);                        &#125;                      &#125;);                    &#125;,                  &#125;)<span class="hljs-comment">// 触发（2）</span>          &lt;button                      type=<span class="hljs-string">"submit"</span>                      onClick=&#123;() =&gt; &#123;                        PubSub.publish(<span class="hljs-string">'电子签名'</span>, &#123;                          functionalModuleId: <span class="hljs-string">'2002001009'</span>,                          caseName: <span class="hljs-string">'projectCode'</span>,                          caseObject: <span class="hljs-string">'projectCode'</span>,                          okFn: x =&gt; console.log(x),                          someForm: <span class="hljs-number">1</span>,                          other: <span class="hljs-number">343</span>,                        &#125;);                      &#125;&#125;                    &gt;                      click <span class="hljs-keyword">this</span> button                    &lt;/button&gt;  <span class="hljs-comment">//  注销</span>  componentWillUnmount() &#123;    PubSub.unsubscribe(<span class="hljs-keyword">this</span>.esignPubsub);  &#125;</code></pre><h3 id="可用于"><a href="#可用于" class="headerlink" title="可用于"></a>可用于</h3><p>跨页面触发事件，传递参数的需求。<br>或者是多页面公用一些事件触发机制。</p><p>这种事件触发可能类似于 dva 里的 subscribtion，其实用 model 层也能解决类似问题</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>没啥总结的哈哈，这玩意用起来不难</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pubsub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《穿过大半个中国去睡你》</title>
    <link href="/2020/09/21/essay0921/"/>
    <url>/2020/09/21/essay0921/</url>
    
    <content type="html"><![CDATA[<h2 id="我把读后感屏蔽了-🔞"><a href="#我把读后感屏蔽了-🔞" class="headerlink" title="我把读后感屏蔽了 🔞"></a>我把读后感屏蔽了 🔞</h2><!-- ### 前言提示：下面有关于性的讨论。反感的就别看了。 --><hr><!-- 今天偶然读到了这首诗， 一首在 2015 年火起来的饱受争议的诗。不记得我之前有没有读过，不过2015 年那时候在读海子，仓央嘉错，纳兰容若，这首不是我的菜恐怕读过我也没印象 😂今天读过能够 get 到了有觉得震撼，在了解到作者背景后更是感慨万千。 --><h3 id="诗句"><a href="#诗句" class="headerlink" title="诗句"></a>诗句</h3><p>《穿过大半个中国去睡你》 ———— 余秀华</p><p>其实，睡你和被你睡是差不多的，无非是</p><p>两具肉体碰撞的力， 无非是这力催开的花朵</p><p>无非是这花朵虚拟出的春天让我们误以为生命被重新打开</p><p>大半个中国，什么都在发生：火山在喷，河流在枯</p><p>一些不被关心的政治犯和流民</p><p>一路在枪口的麋鹿和丹顶鹤</p><p>我是穿过枪林弹雨去睡你</p><p>我是把无数的黑夜摁进一个黎明去睡你</p><p>我是无数个我奔跑成一个我去睡你</p><p>当然我也会被一些蝴蝶带入歧途</p><p>把一些赞美当成春天</p><p>把一个和横店类似的村庄当成故乡</p><p>而它们</p><p>都是我去睡你必不可少的理由</p><!-- ### 对诗的感受以我现在的阅历和人生观，领悟了三层感受。抛开诗人的经历，过往，人设。只谈作品本身给我的感受。#### 一 肉欲第一句就抓住我了第二句就震撼到我了睡你和被你睡是差不多的，因为我们都是愿意的，都是享受这场性爱的不是 I fuck you而是 We have sex两具肉体碰撞的力这句话，这几个字激起了太多感官感受是两具身体碰撞的声音柔软细腻的肌肤紧实有弹性的大腿褶皱潮湿的床单掉落在地上的枕头整首诗用的文字的直观感受都很直白对比一下> 我是天空里的一片云，偶尔投影在你的波心 —— 徐志摩> 你见，或者不见我，我就在那里，不悲不喜。 —— 扎西拉姆·多多> 我如果爱你，绝不像攀援的凌霄花，借你的高枝炫耀自己; ——— 舒婷别人写爱情都很委婉唯美，作者就很直接，就是睡你，就是有力，简单粗暴，爱咋咋地如此粗砺的文字却直击灵魂，刺激每个人的生理欲望。非常强烈的性欲其他人或者是自己都无法满足这欲望就是要你就是要睡你要你用力催开我的花朵要你在生命大和谐中打开我生命的春天即使跋山涉水，路上误入迷途也一定要睡你#### 二 情绪起伏经历过很多，所以才会有连续几个“无非是”看到这个世界的糟糕对自然环境变化的无奈对人与人关系冷漠的悲悯对人向动物发起杀戮的愤怒与心痛也隐约描述了自己的经历捱过难熬的日日夜夜也在感情路上的摸爬滚打后意识到曾经的错误后终于认识了你感觉就像黎明的曙光是我渴求的爱情所散发的光芒我愿意穿过枪林弹雨我愿意为之付出一切同时也不后悔过去的一切正是过去每一天的我正是经历过无数事情的我才让我变成现在的我我带着我的一切向你奔跑不远万里要去睡你要去爱你#### 三 生命力这首诗体现出的生命力实在是太强大了表面上是追求满足性欲和性爱实际上是生存价值和生活的追求不管是现实的枪林弹雨让我千疮百孔还是感情虐我千百遍让我遍体鳞伤无论如何，都要很好的活着，有所追求的活着### 对诗人经历的感受诗人余秀华她天生脑瘫，行动不便，口齿不清。高中文凭，被现实压迫接受了没有爱情的婚姻。她也想拥有爱情啊可是注定她这一生也不会拥有她唯一能做的就是摆脱那段恶心的婚姻。总比在压迫压抑中度过一生要好得多。生活总是如此艰难，我们都要加油啊... -->]]></content>
    
    
    <categories>
      
      <category>读书心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>余秀华</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解一下webpack吧</title>
    <link href="/2020/09/15/webpack/"/>
    <url>/2020/09/15/webpack/</url>
    
    <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其转换和打包为合适的格式供浏览器使用。</p><p>所有模块都是 JS 模块 webpack 只支持 JS 模块，所有其他类型的模块，比如图片，css 等，都需要通过对应的 loader 转成 JS 模块。所以在 webpack 中无论任何类型的资源，本质上都被当成 JS 模块处理。</p><p>就像个面条机器，面放进去，面条出来</p><p>好像是这样，，我们敲代码的时候分模块实现页面功能。但是其实它是一个单页面应用，理论上就是只有一个页面<br>这个 webpack 就是把我们写的一堆模块放进一个 index 文件里面。称为模块打包<br>因为 webpack 只搞 js 文件，所以遇见其他文件就通过各种 loader 给搞成 js 文件</p><h3 id="简介-babel-loader"><a href="#简介-babel-loader" class="headerlink" title="简介 babel-loader"></a>简介 babel-loader</h3><pre><code class="hljs javascript"><span class="hljs-comment">//  原封不动return出来</span><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;  <span class="hljs-keyword">return</span> source&#125;<span class="hljs-comment">// 用babel处理一下，然后return出来</span><span class="hljs-keyword">var</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-core"</span>)<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;  <span class="hljs-keyword">var</span> babelOptions = &#123;    presets: [<span class="hljs-string">'env'</span>]  &#125;  <span class="hljs-keyword">var</span> result = babel.transform(source, babelOptions)  <span class="hljs-keyword">return</span> result.code&#125;<span class="hljs-comment">//  终极版自定义babel-loader</span><span class="hljs-keyword">var</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-core"</span>)<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source, inputSourceMap</span>) </span>&#123;  <span class="hljs-keyword">var</span> babelOptions = &#123;    presets: [<span class="hljs-string">'env'</span>],    inputSourceMap: inputSourceMap,    filename: <span class="hljs-keyword">this</span>.request.split(<span class="hljs-string">'!'</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">'/'</span>).pop(),    sourceMaps: <span class="hljs-literal">true</span>  &#125;  <span class="hljs-keyword">var</span> result = babel.transform(source, babelOptions)  <span class="hljs-keyword">this</span>.callback(<span class="hljs-literal">null</span>, result.code, result.map)&#125;</code></pre><p><a href="https://github.com/lihongxun945/diving-into-webpack/blob/master/2-babel-loader.md" target="_blank" rel="noopener">链接，自定义 babel-loader 相关内容</a></p><h3 id="简介-css-loader-amp-style-loader"><a href="#简介-css-loader-amp-style-loader" class="headerlink" title="简介 css-loader &amp; style-loader"></a>简介 css-loader &amp; style-loader</h3><p>css-loader 的作用是处理 css 中的 @import 和 url 这样的外部资源<br>style-loader 的作用是把样式插入到 DOM 中，方法是在 head 中插入一个 style 标签，并把样式写入到这个标签的 innerHTML 里</p><pre><code class="hljs css">&#123;  <span class="hljs-attribute">module</span>: &#123;    rules: [      &#123;        test: /\.css$/,        use: [          &#123; loader: <span class="hljs-string">"style-loader"</span> &#125;,          &#123; <span class="hljs-attribute">loader</span>: <span class="hljs-string">"css-loader"</span> &#125;        ]      &#125;    ]  &#125;&#125;</code></pre><p>即我们的 CSS 代码会先被 css-loader 处理一次，然后再交给 style-loader 进行处理。</p><p><a href="https://blog.csdn.net/sinat_17775997/article/details/84030720" target="_blank" rel="noopener">源码相关文档</a></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>我们可以将一些编译选项放在配置文件中，以便于统一管理：</p><p>创建 webpack.config.js 文件，代码如下所示：</p><pre><code class="hljs dts">module.exports = &#123;<span class="hljs-symbol">    entry:</span> <span class="hljs-string">"./runoob1.js"</span>,<span class="hljs-symbol">    output:</span> &#123;<span class="hljs-symbol">        path:</span> __dirname,<span class="hljs-symbol">        filename:</span> <span class="hljs-string">"bundle.js"</span>    &#125;,<span class="hljs-symbol">    module:</span> &#123;<span class="hljs-symbol">        loaders:</span> [            &#123; test: /\.css$/, loader: <span class="hljs-string">"style-loader!css-loader"</span> &#125;        ]    &#125;&#125;;</code></pre><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件在 webpack 的配置信息 plugins 选项中指定，用于完成一些 loader 不能完成的工。<br>webpack 自带一些插件，你可以通过 cnpm 安装一些插件。<br>使用内置插件需要通过以下命令来安装：cnpm install webpack –save-dev</p><p>比如我们可以安装内置的 BannerPlugin 插件，用于在文件头部输出一些注释信息。<br>修改 webpack.config.js，代码如下：</p><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> webpack=<span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);<span class="hljs-built_in">module</span>.exports = &#123;    entry: <span class="hljs-string">"./runoob1.js"</span>,    output: &#123;        path: __dirname,        filename: <span class="hljs-string">"bundle.js"</span>    &#125;,    <span class="hljs-keyword">module</span>: &#123;        loaders: [            &#123; test: <span class="hljs-regexp">/\.css$/</span>, loader: <span class="hljs-string">"style-loader!css-loader"</span> &#125;        ]    &#125;,    plugins:[    <span class="hljs-keyword">new</span> webpack.BannerPlugin(<span class="hljs-string">'菜鸟教程 webpack 实例'</span>)    ]&#125;;</code></pre><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><h3 id="webpack-热更新"><a href="#webpack-热更新" class="headerlink" title="webpack 热更新"></a>webpack 热更新</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>模块热替换（HMR - Hot Module Replacement）是 webpack 提供的最有用的功能之一。<br>它允许在运行时替换，添加，删除各种模块，而无需进行完全刷新重新加载整个页面，其思路主要有以下几个方面</p><ul><li>保留在完全重新加载页面时丢失的应用程序的状态</li><li>只更新改变的内容，以节省开发时间</li><li>调整样式更加快速，几乎等同于就在浏览器调试器中更改样式</li></ul><h4 id="启用热更新"><a href="#启用热更新" class="headerlink" title="启用热更新"></a>启用热更新</h4><p>第一种方法：webpack 配置形式 1.引入 webpack 库 2.使用 new webpack.HotModuleReplacementPlugin() 3.设置 devServer 选项中的 hot 字段为 true</p><p>第二种方法：node 命令行形式<br><code>webpack-dev-sever --hot</code></p><hr><p>package.json 文件</p><pre><code class="hljs stata"><span class="hljs-string">"scripts"</span>: &#123;   <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"</span><span class="hljs-keyword">Error</span>: <span class="hljs-keyword">no</span> <span class="hljs-keyword">test</span> specified\<span class="hljs-string">" &amp;&amp; exit 1"</span>,   <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack"</span>,   <span class="hljs-string">"watch"</span>: <span class="hljs-string">"webpack --watch"</span>,   <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack-dev-server --open"</span> <span class="hljs-comment">// open参数 构建完自动刷新浏览器</span> &#125;,</code></pre><p>webpack.config.js 文件</p><pre><code class="hljs less"><span class="hljs-attribute">mode</span>: <span class="hljs-string">'development'</span>, <span class="hljs-attribute">plugins</span>: [     new webpack.HotModuleReplacementPlugin() ], <span class="hljs-attribute">devServer</span>: &#123;     <span class="hljs-attribute">contentBase</span>: <span class="hljs-string">'./dist'</span>,  <span class="hljs-comment">// 服务基础目录</span>     <span class="hljs-attribute">hot</span>: true,  <span class="hljs-comment">// 热更新</span>     <span class="hljs-comment">// hotOnly: true</span>     <span class="hljs-attribute">proxy</span>: &#123;  <span class="hljs-comment">// 反向代理跨域</span>         <span class="hljs-string">"/api"</span>: &#123;             <span class="hljs-attribute">target</span>: <span class="hljs-string">"http://localhost:3000"</span>,             <span class="hljs-attribute">pathRewrite</span>: &#123;                 <span class="hljs-string">"^/api"</span>: <span class="hljs-string">""</span>             &#125;         &#125;     &#125; &#125; ```</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电影《信条》</title>
    <link href="/2020/09/14/movie0914/"/>
    <url>/2020/09/14/movie0914/</url>
    
    <content type="html"><![CDATA[<h3 id="先写个序"><a href="#先写个序" class="headerlink" title="先写个序"></a>先写个序</h3><p>是的没错，我又把原来内容屏蔽了 😁</p><!-- 还是一个人看电影的生活，孤独指数++博客是从 6 月开始写的，开始只是想写技术博客，一边学习一边留下记录，方便复习。后来开始写生活相关的，读书啊，随笔啊现在开始写观后感以前读过的书，看过的电影，后续如果有感触的时候，也会写进来好了，开始### 情节概述一群蒙面匪徒闯入乌克兰一个歌剧院劫持人质，真实目标是要抢夺一个装有神秘物质的手提箱。主角和同伴假扮成特警也要抢夺手提箱，但任务离奇失败，主角为保护秘密“被假死”。主角在假死被救后，被赋予新的更大的任务，通过女科学家的帮助，主角从射出的子弹倒着回到枪膛的实验中了解到“逆转时间”的概念，并被告知整个世界可能因为逆时间技术消失。主角从此不再有身份，加入“信条”组织，成为无名氏，他的任务是保护全世界不要被逆时间毁灭。为了阻止萨特企图毁灭人类的行为，以无名氏、尼尔和凯特为首的队伍们来到萨特的基地，利用逆时间完成了任务，毁掉了萨特手中的时间炸弹，最终阻止了人类世界在逆时间中灭亡以上来自百度。### 观影感受好电影来之不易，我不愿意非得找出所谓的剧情破绽啥的看电影图一乐，我不以挑刺为乐，也不想写一个剧本似的影评随心所欲，想啥写啥了看这个之前有了解到是一个蛮烧脑的电影，但是我没有提前攻略一下提前攻略不就相当于自己给自己剧透了么所以进影院之前已经做好了心理准备不过进了电影院发现就只有寥寥几个人，差点我包场了哈哈看来大部分人是不爱看这玩意的电影里的时间倒流概念用熵和热力学解释了一波不过，我是一点都没纠结第一呢，我也不懂这么高深的物理第二呢，人家台词都直接告诉你了，不要去试着理解，而是试着感受。这是台词，这是导演想告诉你的，那就看就完了呗#### 对逆时间的理解时间倒流，不是时间穿越。理解为，如果时间是一条线所有事件都是这条线上的点我们正常时间流逝的速度，就是速度只不过这里可以选择这个速度是负值或者正值选择的方式就是进那个机器你想去未来的某个事件发生的点，那就等时间流逝呗如果想去过去某个时间发生的点，那就让时间反着走负的时间速度 乘 时间 ，就能到过去的点（逆时间度过那个点）在逆时间的过程中，你觉得世界都是反的，世界也觉得你是反的，在逆时间的过程中，你可以再进机器正向时间，这时候就相当于大多数的穿越的概念穿越到过去某个时间点，再来一次所以在可以随便选择时间的正逆方向的概念下理论上某段时间里可以有很多很多个你自己#### 祖父悖论一个人，穿越到祖父与祖母交配怀孕之前，杀死了祖父，导致发生未来的自己不存在的事实，从而与现实出现相斥。或者简单点，你穿越回 1 天前把你自己杀了，会咋样？这一天你做的事，与你接触的人。与你相关的，已经发生的历史会怎样？就很离谱吧？电影里做了个规则，就是不能让两个自己接触，否则会湮灭。已经知道结果的事也要去做在这个规则下角色之间产生错综复杂的关系正是这种复杂到混乱的剧情才让人看不懂也正是这种复杂到混乱的剧情才觉得有趣想一想啊或许在此时此刻，未来的你正在远处看着你呢也或许未来的我正在远处看着你呢哈哈哈不信你看窗外### 因果关系只要事情发生了，就一定会有影响只要有因，就会有果因果关系是无所谓时间正逆的如果未来没有时间机器这一秒决定做啥，下一秒就会做啥未来是未知的，但是也是自由意志决定的如果未来有时间机器那理论上我们身边应该有很多未来人啊哈哈哈所以已经发生的一切就已经是被未来所影响的结果结果是啥？结果是我依然没有对象结果是我仍然没中彩票怎么回事？是因为未来的我改变了性取向？那也不对啊，我连男朋友也没有啊。。只有一种解释：未来的我变成了单身主义，并且视金钱如粪土并且心理变态就愿意看自己曾经痛苦挣扎的样子emmm离谱不可能所以拉倒吧时间不会倒流，未来也不能穿越不用幻想未来的你会脚踏祥云出现了还是自己脚踏实地好好生活吧### 拍摄技巧画面构图啊，叙事啊，都足够优秀。毕竟人家是大导演。简单几个点- 男主在火车铁轨上被刑讯的画面。在火车路过的过程车厢的空隙中若隐若现，这个画面还挺有张力的  能想象到一些血腥残酷的画面，能想象到惨烈痛苦的呻吟  血腥被藏在奔驰的火车后，呻吟被淹没在火车轰鸣中，  挺酷* 时间机器的红蓝光氛围，便于区分正逆时间画面，增加了正逆时间逻辑的张力。红色的光线打在反派狰狞的脸上，  典型的用颜色传递情绪。红蓝光，加上逆弹孔，逆子弹，逆动作。还挺赛博朋克的  张力这个词真好，哈哈，王力李力都不行啊- 飞机撞大楼，前面有说仓库像五角大楼，然后这里也安排了飞机撞的情节，可能是个梗。  但是老实讲，这个画面没有我想象中刺激。估计是因为实拍的原因，第一飞机撞击速度不快，第二爆炸效果不壮观，第三破坏效果不严重。  真不如整个特效呢。在这个画面里最让我惦记的是那一地的金砖啊哈哈* 我打我自己，哈哈，在仓库里边自己与自己展开了激烈的搏斗，因为有一个逆时间的自己，所以画面诡异的有趣。  还有后面抢箱子的飙车画面，正逆时间都有，同一个时间段出现了好多个角色完成剧情，如此复杂的场景，镜头交代的简洁有力且有序* 给女主拍的也很好看啊，女主剧情开始的看画画面里，漂亮的耳朵和脸颊轮廓，显白的深蓝色衣服。  船上露出的锁骨，湿漉漉的大腿，展示伤口露出平坦的小腹。修没修图不知道，反正挺好看。### 完事突然觉得，如果写个系列————各大导演如何把女角色拍的美，或许好多人会看啊，有商机，有搞头。今天就写到这吧，要下班回家了 -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>配合antd上传组件的分片上传实现</title>
    <link href="/2020/09/14/chunkUpload/"/>
    <url>/2020/09/14/chunkUpload/</url>
    
    <content type="html"><![CDATA[<h2 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h2><p>项目中遇见了超过 1G 的大文件，在上传接口调用的时候会超时，报错。<br>为了解决问题，搞了个分片上传，配合 antd 的 Upload 组件<br>主要是利用了 Blob 文件的 blob.slice 方法切割文件<br>然后把切割出来的文件传给后端</p><pre><code class="hljs typescript">&lt;Upload  action=&#123;<span class="hljs-string">`/server/api/orderFiles/cus/<span class="hljs-subst">$&#123;order.id&#125;</span>/enable/1/dipServices/<span class="hljs-subst">$&#123;order.dipService?.id&#125;</span>`</span>&#125;  autoUpload=&#123;<span class="hljs-literal">false</span>&#125;  multiple  beforeUpload=&#123;<span class="hljs-function">(<span class="hljs-params">file, fileList</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (file.size &lt;= <span class="hljs-number">0</span>) &#123;      message.warning(formatMessage(&#123; id: <span class="hljs-string">'文件无效，请重新上传!'</span> &#125;));      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (fileList.length &gt; <span class="hljs-number">10</span> - originFiles.length &amp;&amp; fileList.indexOf(file) === <span class="hljs-number">0</span>) &#123;      message.warning(formatMessage(&#123; id: <span class="hljs-string">'选择文件数量超出限制，请重新选择'</span> &#125;));      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (fileList.length &gt; <span class="hljs-number">10</span> - originFiles.length) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (originFiles.length &gt; <span class="hljs-number">10</span>) &#123;      message.warning(formatMessage(&#123; id: <span class="hljs-string">'已上传文件数量超过限制，无法上传'</span> &#125;));      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">// if (file.size &gt; 1024 * 1024 * 5) &#123;</span>    <span class="hljs-comment">//   message.warning(formatMessage(&#123; id: `文件：$&#123;file.name&#125; 超过5M，无法上传!` &#125;));</span>    <span class="hljs-comment">//   return false;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;&#125;  customRequest=&#123;<span class="hljs-function">(<span class="hljs-params">&#123; file, onError, onSuccess &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">//  如果小于5M 上传整个文件，如果超过5M分片上传</span>    <span class="hljs-keyword">const</span> bytesPerPiece = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>; <span class="hljs-comment">// 每个文件切片大小定为5MB .</span>    <span class="hljs-comment">// const uid = uuid.v4();</span>    <span class="hljs-keyword">if</span> (file.size &lt; bytesPerPiece) &#123;      <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();      formData.append(<span class="hljs-string">'file'</span>, file);      formData.append(<span class="hljs-string">'chunkFlag'</span>, <span class="hljs-literal">false</span>);      formData.append(<span class="hljs-string">'chunk'</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//  第几片</span>      formData.append(<span class="hljs-string">'chunkSize'</span>, bytesPerPiece); <span class="hljs-comment">//  分片大小</span>      formData.append(<span class="hljs-string">'chunks'</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 分片总数</span>      formData.append(<span class="hljs-string">'uuid'</span>, file.uid); <span class="hljs-comment">//  整个文件的标识</span>      request(        <span class="hljs-string">`/server/api/orderFiles/cus/<span class="hljs-subst">$&#123;order.id&#125;</span>/enable/1/dipServices/<span class="hljs-subst">$&#123;order.dipService?.id&#125;</span>`</span>,        &#123;          method: <span class="hljs-string">'post'</span>,          body: formData,        &#125;,      ).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;          onSuccess(res, file);        &#125; <span class="hljs-keyword">else</span> &#123;          onError();        &#125;        getOriginFiles(&#123;          id: order.id,        &#125;);      &#125;);      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 发送请求</span>    <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> Blob([file]);    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> end;    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">const</span> filesize = blob.size;    <span class="hljs-comment">// const filename = blob.name;</span>    <span class="hljs-comment">// 计算文件切片总数</span>    <span class="hljs-keyword">const</span> totalPieces = <span class="hljs-built_in">Math</span>.ceil(filesize / bytesPerPiece);    <span class="hljs-keyword">const</span> filePieces = [];    <span class="hljs-keyword">while</span> (start &lt; filesize) &#123;      end = start + bytesPerPiece;      <span class="hljs-keyword">if</span> (end &gt; filesize) &#123;        end = filesize;      &#125; <span class="hljs-comment">// 匹配最后一个分片的情况</span>      <span class="hljs-keyword">const</span> chunk = blob.slice(start, end); <span class="hljs-comment">// 切割文件</span>      <span class="hljs-keyword">const</span> sliceIndex = file.name;      <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();      formData.append(<span class="hljs-string">'file'</span>, chunk, sliceIndex);      formData.append(<span class="hljs-string">'chunk'</span>, index); <span class="hljs-comment">//  第几片</span>      formData.append(<span class="hljs-string">'chunkSize'</span>, bytesPerPiece); <span class="hljs-comment">//  分片大小</span>      formData.append(<span class="hljs-string">'chunks'</span>, totalPieces); <span class="hljs-comment">// 分片总数</span>      formData.append(<span class="hljs-string">'chunkFlag'</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">//  是否分片</span>      formData.append(<span class="hljs-string">'uuid'</span>, file.uid); <span class="hljs-comment">//  整个文件的标识</span>      filePieces.push(formData);      <span class="hljs-comment">// request(</span>      <span class="hljs-comment">//   `/server/api/orderFiles/cus/$&#123;order.id&#125;/enable/1/dipServices/$&#123;order.dipService?.id&#125;`,</span>      <span class="hljs-comment">//   &#123;</span>      <span class="hljs-comment">//     method: 'post',</span>      <span class="hljs-comment">//     body: formData,</span>      <span class="hljs-comment">//   &#125;,</span>      <span class="hljs-comment">// ).then(() =&gt;</span>      <span class="hljs-comment">//   getOriginFiles(&#123;</span>      <span class="hljs-comment">//     id: order.id,</span>      <span class="hljs-comment">//   &#125;),</span>      <span class="hljs-comment">// );</span>      start = end;      index += <span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">Promise</span>.all(      filePieces        .filter(<span class="hljs-function">(<span class="hljs-params">item, arrayIndex, array</span>) =&gt;</span> &#123;          <span class="hljs-keyword">return</span> arrayIndex &lt; array.length - <span class="hljs-number">1</span>;        &#125;)        .map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;          <span class="hljs-keyword">return</span> request(            <span class="hljs-string">`/server/api/orderFiles/cus/<span class="hljs-subst">$&#123;order.id&#125;</span>/enable/1/dipServices/<span class="hljs-subst">$&#123;order.dipService?.id&#125;</span>`</span>,            &#123;              method: <span class="hljs-string">'post'</span>,              body: item,            &#125;,          );        &#125;),    ).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      request(        <span class="hljs-string">`/server/api/orderFiles/cus/<span class="hljs-subst">$&#123;order.id&#125;</span>/enable/1/dipServices/<span class="hljs-subst">$&#123;order.dipService?.id&#125;</span>`</span>,        &#123;          method: <span class="hljs-string">'post'</span>,          body: filePieces[filePieces.length - <span class="hljs-number">1</span>],        &#125;,      ).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (res.success) &#123;          onSuccess(res, file);        &#125; <span class="hljs-keyword">else</span> &#123;          onError();        &#125;        getOriginFiles(&#123;          id: order.id,        &#125;);      &#125;);    &#125;);  &#125;&#125;  <span class="hljs-comment">// onAllComplete=&#123;() =&gt; &#123;</span>  <span class="hljs-comment">// &#125;&#125;</span>/&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分片上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《人间失格》</title>
    <link href="/2020/09/11/essay0911/"/>
    <url>/2020/09/11/essay0911/</url>
    
    <content type="html"><![CDATA[<p>看了几眼，感觉读这个的兴趣不是很高。<br>后续会细读一番</p>]]></content>
    
    
    <categories>
      
      <category>读书心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人间失格</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是神奇的hooks</title>
    <link href="/2020/09/10/hooks/"/>
    <url>/2020/09/10/hooks/</url>
    
    <content type="html"><![CDATA[<h2 id="HOOKS"><a href="#HOOKS" class="headerlink" title="HOOKS"></a>HOOKS</h2><p>插眼，后续完成文档</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些好用的git命令</title>
    <link href="/2020/09/10/git/"/>
    <url>/2020/09/10/git/</url>
    
    <content type="html"><![CDATA[<h2 id="git-代码版本管理工具"><a href="#git-代码版本管理工具" class="headerlink" title="git 代码版本管理工具"></a>git 代码版本管理工具</h2><p>最开始的时候，只会 git add ,git commit , git push , git pull ,当熟练使用这样的提交代码的“硬”命令后<br>在工作中不断遇见各种情况，学习了各种好用的命令<br>也得益与我执着与手敲命令而不是用一些 git 工具<br>在这里做一个简单的总结，并再次拓宽自己的 git 知识～<br>冲鸭</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>git stash 可以把所有未提交的修改（工作区和暂存区）也就是 git commit 之前的 ，保存到堆栈中，先进后出。<br>在日常敲代码，中经常会使用<br>在切分支，紧急上线，但是正在开发的功能分支还没有开发完的时候，就可以使用这个命令啦</p><h4 id="git-stash-save-“zhujunTest”"><a href="#git-stash-save-“zhujunTest”" class="headerlink" title="git stash save “zhujunTest”"></a>git stash save “zhujunTest”</h4><p>可以在暂存的时候加备注 理解为 git commit -m “” 这种备注即可</p><h4 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h4><p>查看当前 stash 中的内容</p><h4 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h4><p>将当前 stash 中的内容弹出，并应用到当前分支对应的工作目录上。<br>注：该命令将堆栈中最近保存的内容删除（栈是先进后出）</p><h4 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h4><p>将堆栈中的内容应用到当前目录，不同于 git stash pop，该命令不会将内容从堆栈中删除，也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况。<br>可以使用 git stash apply + stash 名字（如 stash@{1}）指定恢复哪个 stash 到当前的工作目录。</p><h4 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h4><p>清除堆栈中的所有 内容</p><h4 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h4><p>查看堆栈中最新保存的 stash 和当前目录的差异。</p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>本地代码多次提交后，合并主分支的时候，如果用 git merge 分支树会分叉<br>这时候使用 git rebase 就很酷很优雅<br>来吧展示</p><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span>git pull origin <span class="hljs-literal">master</span>git checkout 本地分支git rebase <span class="hljs-literal">master</span>// 如果有冲突，解决冲突 然后git add .    +   git rebase --continuegit checkout <span class="hljs-literal">master</span>git merge 本地分支git push</code></pre><p>完事。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>重置 HEAD 指针</p><h4 id="git-reset-–hard"><a href="#git-reset-–hard" class="headerlink" title="git reset –hard"></a>git reset –hard</h4><p>比如 git reset –hard origin master 这时会清空暂存区，也就是说没有 commit 的内容都会被清除掉<br>重置位置的同时，直接将 working Tree 工作目录、 index 暂存区及 repository 都重置成目标 Reset 节点的內容,所以效果看起来等同于清空暂存区和工作区。</p><h4 id="git-reseet-–mixed-或者说不加参数"><a href="#git-reseet-–mixed-或者说不加参数" class="headerlink" title="git reseet –mixed 或者说不加参数"></a>git reseet –mixed 或者说不加参数</h4><p>保留工作目录，并清空暂存区<br>工作目录的内容和 –soft 一样会被保留，但和 –soft 的区别在于，它会把暂存区清空,并把原节点和 reset 节点的差异的文件放在工作目录，总而言之就是，工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录</p><h4 id="git-reset-–soft"><a href="#git-reset-–soft" class="headerlink" title="git reset –soft"></a>git reset –soft</h4><p>保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区<br>–hard 会清空工作目录和暂存区的改动,而 –soft 则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>某次提交可以单独合并某次提交的代码，比如 A 分支有 3 次提交，想要把第 2 次合并到 B 分支。</p><p>如果遇到了代码冲突，解决冲突然后<br>git add .<br>git cherry-pick –continue</p><p><strong>–abort</strong><br>代码冲突，取消合并代码的事件</p><p><strong>–quit</strong><br>代码冲突，推出 cherry-pick，但是不会倒操作前的代码</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>差不多可以这样理解<br>git pull = git fetch + git merge<br>最常用的是，多人协同开发，别人新建的分支，在你 git branch -a 看不到的时候<br>执行一下 git fetch<br>完事</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>通常发布的时候，每个版本都会打对应的 tag，方便后期回溯<br>git tag -a v2.4.9 （tag 的版本号）-m “描述”<br>-a 参数来创建一个带备注的 tag，备注信息由-m 指定。如果你未传入-m 则创建过程系统会自动为你打开编辑器让你填写备注信息。<br>git show 命令可以查看 tag 的详细信息，包括 commit 号等。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《嫌疑人 X 的献身》</title>
    <link href="/2020/09/09/essay0909/"/>
    <url>/2020/09/09/essay0909/</url>
    
    <content type="html"><![CDATA[<h3 id="故事简介"><a href="#故事简介" class="headerlink" title="故事简介"></a>故事简介</h3><p>百年一遇的数学天才石神，每天唯一的乐趣，便是去固定的便当店买午餐，只为看一眼在便当店做事的邻居靖子。</p><p>靖子与女儿相依为命，失手杀了前来纠缠的前夫。石神提出由他料理善后。石神设了一个匪夷所思的局，令警方始终只能在外围敲敲打打，根本无法与案子沾边。</p><p>故事中有插叙和正续交互不断的组件丰富整个故事，不如让我捋一捋</p><p>石神与汤川是大学同学，两个高智商的人在大学里就是好友。<br>世界总是现实的，所以石神毕业后的生活也并不如意，最后成为了一个不被学生喜欢的数学老师。实际上学生只是不喜欢数学吧<br>石神逐渐的觉得生活失去了意义，没有朋友，没有爱人，没有亲人，只有数学，只有自己。<br>时间久了，连自己也不想要了<br>只会数学，但是在数学领域自己不会有发展<br>这种一眼看到头的日子，有什么意义<br>石神决定自杀<br>自杀过程被新邻居敲门打断，打开门，是一对母女。母亲靖子和女儿美里<br>那一瞬间应该是很美好，以至于让石神决定继续生活<br>得知靖子在一家便当店上班，石神就每天都去<br>每天吃同一种便当，每天看靖子一眼，每天路过满是流浪汉的桥<br>每天都一样<br>直到靖子和美里失手杀了人<br>杀的是不停纠缠靖子的靖子前夫<br>于是石神决定帮助母女瞒天过海<br>再高智商的人想要完美的隐藏犯罪也很困难<br>所以石神决定用自己换母女的下半生幸福<br>石神在母女杀人第二天，杀了一个流浪汉<br>把流浪汉伪装成前一天死掉的靖子前夫的身份<br>利用时间差，让母女摆脱了嫌疑<br>可是他们遇见了协助警察破案的汤川<br>汤川识破了石神的计谋，但是没有证据<br>石神自首<br>真相会永远的被埋藏<br>可惜<br>汤川既然已经识破，又怎能让真相被埋藏<br>汤川告诉了靖子真相<br>靖子自首</p><p>故事大概就是这样</p><h3 id="人物理解与个人见解"><a href="#人物理解与个人见解" class="headerlink" title="人物理解与个人见解"></a>人物理解与个人见解</h3><h4 id="石神自杀"><a href="#石神自杀" class="headerlink" title="石神自杀"></a>石神自杀</h4><p>石神自杀，是对自己的价值产生了怀疑，生活枯燥乏味，自身价值无法实现。<br>活着为了什么呢？<br>当一个人抛开情欲，或者是失去情欲的时候，活着是什么？<br>把各种食物转化为粪便？<br>繁衍后代？<br>当人没有情欲以后<br>生命就是静止的<br>是万分之一的光景，也是四万八千年的永恒<br>是结束也是开始<br>是死也是生<br>基本上就成仙成佛了<br>那时候还谈什么生命意义，自我价值<br>都是空，都是无，都是狗屁<br>所以说活着得有情欲啊<br>数学是无聊的，我也不喜欢<br>女人不是无聊的，我很喜欢<br>石神也很喜欢，所以他选择了活下来<br>有时候，一个人只要好好活着，就足以拯救某个人<br>但是我觉得那一瞬间他的情感是及其丰富复杂的<br>要有对死亡本能的恐惧<br>有对生命本能的渴望<br>有对爱情的憧憬向往<br>也要有对世界重新产生的一点好奇<br>至于什么活着的价值，生命的意义这种问题嘛<br>如果我的能力只能让我穷困潦倒，那么穷困潦倒就是我的价值<br>不必在吃喝嫖赌莺歌燕舞中寻找意义，活着本身就是一种意义<br>就平平淡淡普普通通的生活呗<br>在平淡中加一点点情趣<br>烟啊酒啊运动啊整点啥不行啊<br>再加一点点色情<br>这里省略几百字以免跑偏<br>再整点美食好吃的<br>天南海北那么多好吃的想想都流口水<br>如果遇到了困难<br>如果挣扎在低谷<br>无论如何都要活下去啊</p><h4 id="石神杀人"><a href="#石神杀人" class="headerlink" title="石神杀人"></a>石神杀人</h4><p>在爱情里面混入太多情感以后，这份爱就会变得扭曲。<br>但是这种扭曲并不影响爱存在着<br>石神爱的扭曲并且极致<br>愿意为了爱付出一切，不计后果，不求回报<br>自私的讲，能被这样爱着也挺幸福的<br>石神选了一条退无可退的路，不管是为了爱情，还是为了支撑他活下去的信念<br>他得这么做，他必须这么做<br>他可以承担下所有的罪责<br>他愿意承受内心的煎熬<br>也许是夜夜无休止的噩梦<br>也许是耳边若有若无的幻听<br>他必须这么做<br>他要杀人<br>想起一首歌，<br>《kill for you》<br>you gonna make me a believer<br>enen if that shit ain’t true<br>you gonna make me commit murder<br>baby i’d kill for you</p><p>别说什么值不值得<br>我愿意去做，那就都值得<br>逻辑的尽头，不是理性与秩序的理想国，而是我用生命奉献的爱情。</p><h4 id="靖子"><a href="#靖子" class="headerlink" title="靖子"></a>靖子</h4><p>我看书的时候就一直不太喜欢靖子<br>不是因为她不选择石神<br>相反她不选择石神倒让我对她有了一丝好感<br>不知道说啥<br>她是被命运推着走的<br>人生中做了几次选择都错误<br>唯一一次正确的还被汤川破坏了</p><p>接受石神？<br>不不不<br>且不说喜欢不喜欢<br>石神这份爱太过沉重<br>不知道还好<br>知道了就会被压到无法喘息<br>爱情是要轻松的，快乐的<br>绝不能是沉重的，压抑的<br>最后知道真相的靖子去自首<br>也一定是因为这种压抑</p><p>爱情里只要有一方爱的过火，爱情就不会长久<br>甚至会有危险<br>过分的爱容易产生强烈到扭曲的占有欲、控制欲</p><h4 id="汤川"><a href="#汤川" class="headerlink" title="汤川"></a>汤川</h4><p>只要汤川出现，这个故事的结局就注定是悲剧了。<br>虽然杀人放火，承担后果是政治正确<br>但是我还真挺希望靖子如石神所期待那样，幸福的生活下去<br>有些真相注定是要小心翼翼深埋心底的，因为答案揭晓的那一刻，也是灰飞烟灭的开始。<br>可是当汤川知道了真相以后，他怎可能深埋心底<br>他良心难安啊<br>他无法允许自己生命中发生这样的事情啊<br>石神杀了人，应该受到惩罚<br>靖子杀了人，也应该受到惩罚才对<br>如果自己知道了真相却深埋心底，与杀人无异啊<br>这个世上没有无用的齿轮，只有齿轮自身才能决定自己的用途。<br>可是<br>如果揭开真相只会带来更多痛苦，那我们一直以来追求的，到底是什么？</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我很想把读后感写的详细，在每一个我有感触的点都做记录。但是也无所谓，随着时间和经历，对故事的理解会不同，如果想写，后续再补充。</p><p>工藤邦明先生是个诚实可靠的人。和他结婚，你和美里获得幸福的几率较高。把我完全忘记，不要有任何负罪感。如果你过得不幸福，我所做的一切才是徒劳</p>]]></content>
    
    
    <categories>
      
      <category>读书心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嫌疑人 X 的献身</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用webSocket完成前后端交互</title>
    <link href="/2020/09/09/webSocket/"/>
    <url>/2020/09/09/webSocket/</url>
    
    <content type="html"><![CDATA[<h2 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。<br>是一种网络通信协议<br>在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。<br>直白一点说，想做一个类似于消息推送的功能，大概能想到两种方法<br>第一种就是 ajax 轮询，整一个定时器不停的调用后端接口<br>另一种就是用 webSocket，让服务器端可以主动的发消息给浏览器端<br>所以你看，还是 webSocket 好啊</p><p>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。<br>以下 API 用于创建 WebSocket 对象。<br><code>var Socket = new WebSocket(url, [protocol] );</code><br>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><p>总觉得要自己玩一次才更好理解这个，看来对 node 的学习要提上日程了。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">"wss://echo.websocket.org"</span>);ws.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Connection open ..."</span>);  ws.send(<span class="hljs-string">"Hello WebSockets!"</span>);&#125;;ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"Received Message: "</span> + evt.data);  ws.close();&#125;;ws.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Connection closed."</span>);&#125;;</code></pre><p>webSocket 扩展，心跳检测，数据加密，身份认证等知识点。</p><h3 id="插件及使用"><a href="#插件及使用" class="headerlink" title="插件及使用"></a>插件及使用</h3><p>使用了一个 webSocket 的插件叫做 sockjs-client，封装组件如下</p><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * WebSocket Client</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> SockJS <span class="hljs-keyword">from</span> <span class="hljs-string">'sockjs-client'</span>;<span class="hljs-keyword">import</span> Stomp <span class="hljs-keyword">from</span> <span class="hljs-string">'stompjs'</span>;<span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/Enhanced'</span>;  <span class="hljs-comment">//  项目用获取token的方法，可以忽略不管</span><span class="hljs-keyword">const</span> Index = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> &#123; url, options, connect = &#123;&#125;, observers = [], disconnect = &#123;&#125;, children &#125; = props;  <span class="hljs-keyword">const</span> newUrl = url.includes(<span class="hljs-string">'?'</span>) ? url : <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?token=<span class="hljs-subst">$&#123;getToken()&#125;</span>`</span>;  <span class="hljs-keyword">const</span> [client, setClient] = useState(<span class="hljs-literal">null</span>);  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> newClient = Stomp.over(<span class="hljs-keyword">new</span> SockJS(newUrl, <span class="hljs-literal">null</span>, options));    newClient.debug = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;    <span class="hljs-keyword">const</span> &#123; onOpen, onError &#125; = connect;    newClient.connect(      connect.headers || &#123;&#125;,      () =&gt; &#123;        <span class="hljs-keyword">if</span> (onOpen) &#123;          onOpen();        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'CONNECTED'</span>);        &#125;        setClient(newClient);      &#125;,      error =&gt; &#123;        <span class="hljs-keyword">if</span> (onError) &#123;          onError();        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ERROR'</span>, error);        &#125;      &#125;,    );    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (newClient.ws.readyState === SockJS.OPEN) &#123;        <span class="hljs-keyword">const</span> &#123; onClose &#125; = disconnect;        newClient.disconnect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (onClose) &#123;            onClose();          &#125;        &#125;, disconnect.headers);      &#125;    &#125;;  &#125;, []);  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (client) &#123;      observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> &#123; destination, onMessage &#125; = observer;        <span class="hljs-keyword">if</span> (destination) &#123;          client.subscribe(            destination,            data =&gt; &#123;              <span class="hljs-keyword">try</span> &#123;                onMessage(<span class="hljs-built_in">JSON</span>.parse(data.body));              &#125; <span class="hljs-keyword">catch</span> (e) &#123;                onMessage(data.body);              &#125;            &#125;,            observer.headers,          );        &#125;      &#125;);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (client) &#123;        <span class="hljs-built_in">Object</span>.keys(client.subscriptions).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;          client.unsubscribe(item);        &#125;);      &#125;    &#125;;  &#125;, [!!client, observers.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.destination).join(<span class="hljs-string">','</span>)]);  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> children === <span class="hljs-string">'function'</span> ? children(client) : children || <span class="hljs-literal">null</span>;&#125;;Index.displayName = <span class="hljs-string">'WsClient'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Index;</code></pre><h3 id="项目应用相关文档"><a href="#项目应用相关文档" class="headerlink" title="项目应用相关文档"></a>项目应用相关文档</h3><p>问题描述：<br>对于 dip-tms-fe 项目的预估报价、结算报价自动分析功能，当待分析文件数量过多或<br>文件过大时，服务器会因网络超时而导致 500 错误，尽管此时后端分析服务还在运行中。<br>问题原因：<br>因服务器长时间未响应，请求时间过长，而引发此错误。为避免这种情况，后端可反馈<br>伪成功，即代表已收到请求。而后，基于 WebSocket 双工通信机制，在后端处理完请求后，<br>主动向前端推送处理结束消息。<br>解决方案： 1.解决 WebSocket 连接过慢问题，支持断后重连<br>在页面头部导航中引入 WebSocket，以便用户在登录成功后，立即开始建立连接。通过<br>查阅资料发现 sockJS 支持多种连接方式：websocket，xdr-streaming，xhr-streaming，<br>eventsource，iframe-eventsource，htmlfile，iframe-htmlfile，xdr-polling，xhr-polling，<br>iframe-xhr-polling，jsonp-polling。建立连接时会依次进行尝试，直到连接成功。在测<br>试时发现采用“xhr-polling”的方式连接耗时最短，因此将其设为首选连接方式。为避免<br>因网络断开导致的 WebSocket 通讯中断，因此支持了断后重连。<br>url：用于建立握手连接</p><pre><code class="hljs javascript">&lt;WsClient  url=<span class="hljs-string">"/server/api/wsconnect"</span>  observers=&#123;[    &#123;      destination: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;currentUser.userId&#125;</span>/notice`</span>,      onMessage: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'订阅返回'</span>);        PubSub.publish(<span class="hljs-string">'更新报告分析结果'</span>);      &#125;,    &#125;,  ]&#125;/&gt;</code></pre><p>destination：统一用户定位符，能把一个用户独一无二的标识出来<br>onMessage：接收由后端主动向前端推送的各种消息<br>coverAndSend：以广播形式，将消息推送给所有用户<br>coverAndSendToUser：将消息推送给指定用户</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webSocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些实用的操作符</title>
    <link href="/2020/09/01/operator/"/>
    <url>/2020/09/01/operator/</url>
    
    <content type="html"><![CDATA[<h3 id="可选链"><a href="#可选链" class="headerlink" title="?. 可选链"></a>?. 可选链</h3><p>通过连接的对象的引用或函数可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。<br>react 项目中用的时候需要在 package.json 文件中加入这个依赖<br>“devDependencies”: {<br>“@babel/plugin-proposal-optional-chaining”: “7.2.0”,<br>}<br>使用 vscode 会报错，要在 vscode 的 setting 中配置：<br>“javascript.validate.enable”: false,</p><pre><code class="hljs maxima">//  不用可选链<span class="hljs-built_in">let</span> nestedProp = obj.<span class="hljs-built_in">first</span> &amp;&amp; obj.<span class="hljs-built_in">first</span>.<span class="hljs-built_in">second</span>;//  用可选链<span class="hljs-built_in">let</span> nestedProp = obj.<span class="hljs-built_in">first</span>?.<span class="hljs-built_in">second</span>;<span class="hljs-built_in">let</span> result = someInterface.customMethod?.();<span class="hljs-built_in">let</span> arrayItem = arr?.[<span class="hljs-number">42</span>]</code></pre><h3 id="空值合并操作符"><a href="#空值合并操作符" class="headerlink" title="?? 空值合并操作符"></a>?? 空值合并操作符</h3><p>第一次见的时候，觉得不就是 || 这种操作么， 比如 false || ‘zhujun’<br>结果当然不是那么简单<br>让我来 show you something</p><p>|| 这种叫做 逻辑或操作符，左边成立用左边，左边 false 用右边 可是如果左边有值为 0 的时候，就不对了 ，举个 🌰</p><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> wanghao = &#123; IQ:<span class="hljs-number">0</span> , cm:<span class="hljs-number">150</span> &#125;;<span class="hljs-keyword">const</span> value = wanghao.IQ || <span class="hljs-number">100</span>console.log(value)  <span class="hljs-comment">//  100</span><span class="hljs-comment">//  这就不对了，它的IQ明明是0 。。。。哈哈</span><span class="hljs-comment">//  假值（0,'',NaN,null,undefined） 对于空字符串和数字0，就只用用逻辑操作符 || 会有问题的</span><span class="hljs-keyword">const</span> newValue = wanghao.IQ ?? <span class="hljs-string">'wanghao is really smart'</span>console.log(newValue)  <span class="hljs-comment">// 0  这就对了，，哈哈😄</span></code></pre><p>用了?? 保证没有 null 或者 undefined ~</p><p>tips：null || undefined ?? “foo”; // 抛出 SyntaxError</p><p>空值合并操作符针对 undefined 与 null 这两个值，可选链式操作符（?.） 也是如此。在这访问属性可能为 undefined 与 null 的对象时，可选链式操作符非常有用。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可选链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-proxy对象代理</title>
    <link href="/2020/08/18/js-proxy/"/>
    <url>/2020/08/18/js-proxy/</url>
    
    <content type="html"><![CDATA[<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p><strong>Proxy</strong> 是 ES6 中新增的功能，它可以用来自定义对象中的操作。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">官网链接</a></p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">target</span>, <span class="hljs-keyword">handler</span>)</code></pre><p>target<br>要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。<br>handler<br>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p><p>handler.has()<br>in 操作符的捕捉器。<br>handler.get()<br>属性读取操作的捕捉器。<br>handler.set()<br>属性设置操作的捕捉器。</p><p>举几个个 🌰</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> handler = &#123;    <span class="hljs-keyword">get</span>: function(obj, prop) &#123;        <span class="hljs-keyword">return</span> prop <span class="hljs-keyword">in</span> obj ? obj[prop] : <span class="hljs-number">37</span>;    &#125;&#125;;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, handler);p.a = <span class="hljs-number">1</span>;p.b = <span class="hljs-literal">undefined</span>;<span class="hljs-built_in">console</span>.log(p.a, p.b);      <span class="hljs-comment">// 1, undefined</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'c'</span> <span class="hljs-keyword">in</span> p, p.c); <span class="hljs-comment">// false, 37</span><span class="hljs-comment">//  这是一条分割线 ================</span><span class="hljs-comment">//  转发操作</span><span class="hljs-keyword">let</span> target = &#123;&#125;;<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;&#125;);p.a = <span class="hljs-number">37</span>;   <span class="hljs-comment">// 操作转发到目标</span><span class="hljs-built_in">console</span>.log(target.a);    <span class="hljs-comment">// 37. 操作已经被正确地转发</span><span class="hljs-comment">//  这也是一条分割线  ===================</span><span class="hljs-comment">// 用于校验，也很ok</span><span class="hljs-keyword">let</span> validator = &#123;  <span class="hljs-keyword">set</span>: function(obj, prop, value) &#123;    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'age'</span>) &#123;      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Number</span>.isInteger(value)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'The age is not an integer'</span>);      &#125;      <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">200</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">'The age seems invalid'</span>);      &#125;    &#125;    <span class="hljs-comment">// The default behavior to store the value</span>    obj[prop] = value;    <span class="hljs-comment">// 表示成功</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;&#125;;<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, validator);person.age = <span class="hljs-number">100</span>;<span class="hljs-built_in">console</span>.log(person.age);<span class="hljs-comment">// 100</span>person.age = <span class="hljs-string">'young'</span>;<span class="hljs-comment">// 抛出异常: Uncaught TypeError: The age is not an integer</span>person.age = <span class="hljs-number">300</span>;<span class="hljs-comment">// 抛出异常: Uncaught RangeError: The age seems invalid</span></code></pre><p>还可以扩展构造函数，<br>还可以操作 dom，比如互换两个不同元素的属性或类名</p><p>重点在于，拦截 =&gt; 操作<br>这个官网写的挺全面，如果有需要就点击上面那个链接到官网看吧～</p><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><pre><code class="hljs qml"><span class="hljs-comment">//  我再分割一波 ==============================</span><span class="hljs-comment">//  看了下面能更好的理解，理解，会用，就ok！ 这里有个reflect 代码下面文字解析一波</span><span class="hljs-keyword">let</span> onWatch = (obj, setBind, getLogger) =&gt; &#123;  <span class="hljs-keyword">let</span> handler = &#123;    get(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, receiver) &#123;      getLogger(target, <span class="hljs-keyword">property</span><span class="hljs-string">)</span>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, receiver)    &#125;,    set(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, value, receiver) &#123;      setBind(value, <span class="hljs-keyword">property</span><span class="hljs-string">)</span>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, value)    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, handler)&#125;<span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attribute">a</span>: <span class="hljs-number">1</span> &#125;<span class="hljs-keyword">let</span> p = onWatch(  obj,  (v, <span class="hljs-keyword">property</span><span class="hljs-string">) </span>=&gt; &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`监听到属性<span class="hljs-subst">$&#123;property&#125;</span>改变为<span class="hljs-subst">$&#123;v&#125;</span>`</span>)  &#125;,  (target, <span class="hljs-keyword">property</span><span class="hljs-string">) </span>=&gt; &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`'<span class="hljs-subst">$&#123;property&#125;</span>' = <span class="hljs-subst">$&#123;target[property]&#125;</span>`</span>)  &#125;)p.a = <span class="hljs-number">2</span> <span class="hljs-comment">// 监听到属性a改变</span>p.a <span class="hljs-comment">// 'a' = 2</span></code></pre><p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。<br>Reflect 的所有属性和方法都是静态的（就像 Math 对象）。</p><p><em>Reflect.apply(target, thisArgument, argumentsList)</em><br>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。</p><p><em>Reflect.get(target, propertyKey[, receiver])</em><br>获取对象身上某个属性的值，类似于 target[name]。</p><p><em>Reflect.has(target, propertyKey)</em><br>判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同</p><p><em>Reflect.set(target, propertyKey, value[, receiver])</em><br>将值分配给属性的函数。返回一个 Boolean，如果更新成功，则返回 true。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> duck = &#123;  name: <span class="hljs-string">'Maurice'</span>,  color: <span class="hljs-string">'white'</span>,  greeting: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Quaaaack! My name is <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>`</span>);  &#125;&#125;<span class="hljs-built_in">Reflect</span>.has(duck, <span class="hljs-string">'color'</span>);<span class="hljs-comment">// true</span><span class="hljs-built_in">Reflect</span>.has(duck, <span class="hljs-string">'haircut'</span>);<span class="hljs-comment">// false</span><span class="hljs-comment">//  还是一个分割线 哈哈====================</span><span class="hljs-built_in">Reflect</span>.set(duck, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'black'</span>);<span class="hljs-comment">// returns "true" if successful</span><span class="hljs-comment">// "duck" now contains the property "eyes: 'black'"</span></code></pre><p>所以上面的代码中<br><code>return Reflect.set(target, property, value)</code><br>这就是添加了一个新的属性 ，例如 target : { property:value }</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>ok ，那这就是 proxy 相关的一些内容，这里是朱军 ❤️ _bye ～</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js-proxy 拦截对象 对象代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>immer一个很酷的immutable库</title>
    <link href="/2020/08/17/immer/"/>
    <url>/2020/08/17/immer/</url>
    
    <content type="html"><![CDATA[<p>immer 是一个用 C ++ 编写的可持久化和不可更改的数据结构库。</p><p>可持久化意味着修改数据结构时，将保留旧值。</p><p>不可更改意味着所有的操作方法都是 const。</p><p>代码更优雅，可读性好一些。<br>至于用这个的必要性，老实说也不大，了解就行。</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">'immer'</span>;<span class="hljs-keyword">const</span> &#123; zhujun &#125; = <span class="hljs-keyword">this</span>.state;<span class="hljs-keyword">this</span>.setState(&#123;  zhujun:[    &#123;      ...zhujun[<span class="hljs-number">0</span>],      age:zhujun[<span class="hljs-number">0</span>].age += <span class="hljs-number">1</span>    &#125;,    ...members.slice(<span class="hljs-number">1</span>)  ]&#125;)<span class="hljs-keyword">this</span>.setState(produce(<span class="hljs-function"><span class="hljs-params">draft</span>=&gt;</span>&#123;  draft.zhujun[<span class="hljs-number">0</span>].age+=<span class="hljs-number">1</span>&#125;))<span class="hljs-comment">//  一些用法 项目里随便找的</span> <span class="hljs-keyword">const</span> newValue = produce(value, <span class="hljs-function"><span class="hljs-params">draftState</span> =&gt;</span> &#123;    draftState = <span class="hljs-function">(<span class="hljs-params">draftState || []</span>).<span class="hljs-params">map</span>(<span class="hljs-params">(<span class="hljs-params">item, index</span>) =&gt; (<span class="hljs-params">&#123;</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">      ...item,</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">      key: item.key || item.id || `ID-$&#123;index&#125;`,</span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">    &#125;</span>)</span>);</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-params">if</span> (<span class="hljs-params">constraintType === '+'</span>) &#123;</span><span class="hljs-function">      <span class="hljs-params">if</span> (<span class="hljs-params">draftState.length === 0</span>) &#123;</span><span class="hljs-function">        <span class="hljs-params">draftState</span>.<span class="hljs-params">push</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-function"><span class="hljs-params">          key: keyZero,</span></span><span class="hljs-function"><span class="hljs-params">          ...(<span class="hljs-params"><span class="hljs-keyword">typeof</span> createTemplate === '<span class="hljs-keyword">function</span>' ? createTemplate(<span class="hljs-params"></span>) : createTemplate</span>),</span></span><span class="hljs-function"><span class="hljs-params">          unsaved: <span class="hljs-literal">true</span>,</span></span><span class="hljs-function"><span class="hljs-params">        &#125;</span>);</span><span class="hljs-function">      &#125;</span><span class="hljs-function"></span><span class="hljs-function">      <span class="hljs-params">if</span> (<span class="hljs-params">draftState.length === 1</span>) &#123;</span><span class="hljs-function">        <span class="hljs-params">draftState</span>[0].<span class="hljs-params">closable</span> = <span class="hljs-params">false</span>;</span><span class="hljs-function">      &#125; <span class="hljs-params">else</span> &#123;</span><span class="hljs-function">        <span class="hljs-params">draftState</span>[0].<span class="hljs-params">closable</span> = <span class="hljs-params">true</span>;</span><span class="hljs-function">      &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-params">return</span> <span class="hljs-params">draftState</span>;</span><span class="hljs-function">  &#125;);</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>immer immutable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用FormRender快速开发表单</title>
    <link href="/2020/08/13/form-render/"/>
    <url>/2020/08/13/form-render/</url>
    
    <content type="html"><![CDATA[<p>今天学习研究了一下 FormRender，觉得在一些表单多的项目，或者是后端数据结构复杂的项目，很适用。<br>可以在这个链接里面找到快速 /拖拽的 形式 生成表单结构 ，再自动转化为 json-schema 的格式<br>放进 FormRender 里面，完成快速生成表单<br><a href="https://form-render.github.io/schema-generator/" target="_blank" rel="noopener">这是链接</a><br>下面是一个写满了注释的，尽量全面的栗子 🌰，注入了我的心血！<br>用的时候甚至可以直接复制这个</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> &#123; Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;<span class="hljs-comment">// 使用 Ant Design 体系</span><span class="hljs-keyword">import</span> FormRender <span class="hljs-keyword">from</span> <span class="hljs-string">'form-render/lib/antd'</span>;<span class="hljs-comment">// 使用 Fusion Design 体系</span><span class="hljs-comment">// import FormRender from "form-render/lib/fusion";</span><span class="hljs-comment">//  这些内容可以到这个地址搞  https://form-render.github.io/schema-generator/playground</span><span class="hljs-built_in">window</span>.copyMe = <span class="hljs-function">(<span class="hljs-params">list, index</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> item = list[index];  list.splice(index, <span class="hljs-number">0</span>, item);  <span class="hljs-keyword">return</span> list;&#125;;<span class="hljs-keyword">const</span> SiteInput = <span class="hljs-function">(<span class="hljs-params">&#123; value, onChange, name &#125;</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    &lt;Input      addonBefore=<span class="hljs-string">"http://"</span>      addonAfter=<span class="hljs-string">".com"</span>      value=&#123;value&#125;      onChange=&#123;e =&gt; onChange(name, e.target.value)&#125;    /&gt;  );&#125;;<span class="hljs-keyword">const</span> schema1 = &#123;  type: <span class="hljs-string">'object'</span>,  <span class="hljs-string">'ui:labelWidth'</span>: <span class="hljs-string">'30%'</span>, <span class="hljs-comment">// 用于控制本元素以及其子元素（如果本元素是对象或列表）的标签宽度</span>  <span class="hljs-comment">//  ui:disabled: 可控制 input、number、date、checkbox、radio、select、switch 对于组件的 disabled 属性(变灰不可点击)</span>  <span class="hljs-comment">//  ui:readonly：可控制 input、number 组件中的 readonly 属性(不可编辑，但不变灰)</span>  <span class="hljs-comment">//  ui:hidden：可控制所有基础组件是否显示，可使用 true/false 或函数表达式</span>  <span class="hljs-comment">//  ui:className：添加组件 root 元素的 className（和 fr-field 这个 className 在同级），用于自定义单独组件的样式</span>  <span class="hljs-comment">//  ui:width：单个基础组件的长度，建议使用百分比例如"ui:width":"50%"。</span>  properties: &#123;    agree: &#123;      title: <span class="hljs-string">'是否同意'</span>,      type: <span class="hljs-string">'boolean'</span>,      <span class="hljs-comment">//      title：表单的标题信息，作为 label 展示，注意 title 为""时占位，title 不写时不占位</span>      <span class="hljs-comment">//      description：表单的描述信息，常将填写注意点放入此参数</span>      <span class="hljs-comment">//      type：表单的类型，支持 string、number、boolean、array、object、range</span>      <span class="hljs-comment">//      format：用来描述输入框的格式，支持 image、dateTime、date、time</span>      <span class="hljs-comment">//      pattern：自定义正则校验，用于校验 string 或 number 数据是否合格，详细使用可见 pattern 自定义正则校验</span>      <span class="hljs-comment">//      message 校验提示自定义文案，与 pattern 共同使用</span>      <span class="hljs-comment">//      default 默认值，对象类型不能使用 default，其他类型包括 array 都可以使用 default</span>    &#125;,    someObj: &#123;      title: <span class="hljs-string">'对象'</span>,      type: <span class="hljs-string">'object'</span>,      properties: &#123;        personType: &#123;          title: <span class="hljs-string">'类型'</span>,          type: <span class="hljs-string">'number'</span>,          enum: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],        &#125;,        age: &#123;          type: <span class="hljs-string">'string'</span>,          title: <span class="hljs-string">'age'</span>,          <span class="hljs-string">'ui:hidden'</span>: <span class="hljs-string">'&#123;&#123;formData.agree==false &amp;&amp; rootValue.personType!=2 &#125;&#125;'</span>,          <span class="hljs-comment">//  两种写法，随便取舍</span>          <span class="hljs-comment">//  'ui:hidden': (formData, rootValue) =&gt; formData.agree==false,</span>          <span class="hljs-comment">//  formData 整个 form 的值 （最常用，当两个关联组件距离较远时，可以从顶层的 formData 里获取）</span>          <span class="hljs-comment">//  rootValue  父组件的值 （比较常用，上一级的值，方便从中能获取所有兄弟组件的值）</span>        &#125;,      &#125;,    &#125;,    stringDemo: &#123;      title: <span class="hljs-string">'字符串'</span>,      description: <span class="hljs-string">'英文或数字组合'</span>,      type: <span class="hljs-string">'string'</span>,      pattern: <span class="hljs-string">'^[A-Za-z0-9]+$'</span>,      message: &#123;        pattern: <span class="hljs-string">'请输入正确格式'</span>,      &#125;,      <span class="hljs-string">'ui:labelWidth'</span>: <span class="hljs-string">'30%'</span>,    &#125;,    imgDemo: &#123;      title: <span class="hljs-string">'图片'</span>,      type: <span class="hljs-string">'string'</span>,      format: <span class="hljs-string">'image'</span>,      <span class="hljs-keyword">default</span>: <span class="hljs-string">"'https://img.alicdn.com/tfs/TB1P8p2uQyWBuNjy0FpXXassXXa-750-1334.png'"</span>,    &#125;,    disabledDemo: &#123;      title: <span class="hljs-string">'不可用'</span>,      type: <span class="hljs-string">'string'</span>,      <span class="hljs-keyword">default</span>: <span class="hljs-string">'我是一个被 disabled 的值'</span>,      <span class="hljs-string">'ui:disabled'</span>: <span class="hljs-literal">true</span>,    &#125;,    url: &#123;      title: <span class="hljs-string">'网址'</span>,      type: <span class="hljs-string">'string'</span>,      <span class="hljs-string">'ui:widget'</span>: <span class="hljs-string">'siteInput'</span>,    &#125;,    enumDemo: &#123;      title: <span class="hljs-string">'枚举'</span>,      enum: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>],      enumNames: [<span class="hljs-string">'朱军'</span>, <span class="hljs-string">'张旭'</span>],    &#125;,    monthpicker: &#123;      title: <span class="hljs-string">'月份选择'</span>,      type: <span class="hljs-string">'string'</span>,      format: <span class="hljs-string">'date'</span>,      <span class="hljs-string">'ui:options'</span>: &#123;        picker: <span class="hljs-string">'month'</span>,      &#125;,    &#125;,    objDemo: &#123;      title: <span class="hljs-string">'单个对象'</span>,      description: <span class="hljs-string">'这是一个对象类型'</span>,      type: <span class="hljs-string">'object'</span>,      properties: &#123;        isLike: &#123;          title: <span class="hljs-string">'单选项'</span>,          type: <span class="hljs-string">'boolean'</span>,          <span class="hljs-keyword">default</span>: <span class="hljs-literal">true</span>,        &#125;,        background: &#123;          title: <span class="hljs-string">'颜色选择'</span>,          description: <span class="hljs-string">'特殊面板'</span>,          format: <span class="hljs-string">'color'</span>,          type: <span class="hljs-string">'string'</span>,        &#125;,        oncemore: &#123;          any: <span class="hljs-string">'anthing'</span>,          type: <span class="hljs-string">'object'</span>,          properties: &#123;            oncemoreee: &#123;              title: <span class="hljs-string">'我再来一层'</span>,              type: <span class="hljs-string">'string'</span>,              <span class="hljs-keyword">default</span>: <span class="hljs-string">'7'</span>,            &#125;,          &#125;,        &#125;,      &#125;,    &#125;,    arrDemo: &#123;      title: <span class="hljs-string">'对象数组'</span>,      description: <span class="hljs-string">'对象数组嵌套功能'</span>,      type: <span class="hljs-string">'array'</span>,      minItems: <span class="hljs-number">1</span>,      maxItems: <span class="hljs-number">3</span>,      items: &#123;        type: <span class="hljs-string">'object'</span>,        properties: &#123;          name: &#123;            title: <span class="hljs-string">'字符名称'</span>,            description: <span class="hljs-string">'string类型'</span>,            type: <span class="hljs-string">'string'</span>,            pattern: <span class="hljs-string">'^[A-Za-z0-9]+$'</span>,          &#125;,          num: &#123;            title: <span class="hljs-string">'数字参数'</span>,            description: <span class="hljs-string">'number类型'</span>,            type: <span class="hljs-string">'number'</span>,          &#125;,        &#125;,      &#125;,      <span class="hljs-string">'ui:options'</span>: &#123;        buttons: [          &#123;            text: <span class="hljs-string">'Excel导入'</span>,            icon: <span class="hljs-string">'copy'</span>,            callback: <span class="hljs-string">'someCallback'</span>,          &#125;,          &#123;            text: <span class="hljs-string">'删除全部'</span>,            icon: <span class="hljs-string">'delete'</span>,            callback: <span class="hljs-string">'clearAll'</span>,          &#125;,          &#123;            text: <span class="hljs-string">'复制上个'</span>,            icon: <span class="hljs-string">'copy'</span>,            callback: <span class="hljs-string">'copyLast'</span>,          &#125;,        ],        itemButtons: [          &#123;            text: <span class="hljs-string">'朱军在里面复制'</span>,            icon: <span class="hljs-string">'copy'</span>,            callback: <span class="hljs-string">'copyMe'</span>,          &#125;,        ],      &#125;,    &#125;,  &#125;,  required: [<span class="hljs-string">'stringDemo'</span>, <span class="hljs-string">'dateDemo'</span>],&#125;;<span class="hljs-keyword">const</span> list = &#123;  type: <span class="hljs-string">'array'</span>,  items: &#123;    type: <span class="hljs-string">'object'</span>,    properties: &#123;      x: &#123;        type: <span class="hljs-string">'string'</span>,      &#125;,    &#125;,  &#125;,  <span class="hljs-keyword">default</span>: [&#123; <span class="hljs-attr">x</span>: <span class="hljs-string">'a'</span> &#125;, &#123; <span class="hljs-attr">x</span>: <span class="hljs-string">'b'</span> &#125;],&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Demo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> [formData, setData] = useState(&#123;&#125;);  <span class="hljs-keyword">const</span> [valid, setValid] = useState([]);  <span class="hljs-keyword">const</span> onSubmit = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-comment">// valid 是校验判断的数组，valid 长度为 0 代表校验全部通过</span>    <span class="hljs-keyword">if</span> (valid.length &gt; <span class="hljs-number">0</span>) &#123;      alert(<span class="hljs-string">`校验未通过字段：<span class="hljs-subst">$&#123;valid.toString()&#125;</span>`</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      alert(<span class="hljs-built_in">JSON</span>.stringify(formData, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));    &#125;  &#125;;  <span class="hljs-keyword">return</span> (    &lt;div style=&#123;&#123; <span class="hljs-attr">maxWidth</span>: <span class="hljs-number">600</span> &#125;&#125;&gt;      &lt;FormRender        schema=&#123;schema1&#125;        formData=&#123;formData&#125;        onChange=&#123;setData&#125;        onValidate=&#123;setValid&#125;        displayType=<span class="hljs-string">"row"</span> <span class="hljs-comment">// 详细配置见下</span>        widgets=&#123;&#123; <span class="hljs-attr">siteInput</span>: SiteInput &#125;&#125; <span class="hljs-comment">//  这里可以使用自定义组件</span>      /&gt;      &#123;<span class="hljs-comment">/* &lt;FormRender</span><span class="hljs-comment">        schema=&#123;list&#125;</span><span class="hljs-comment">        formData=&#123;formData&#125;</span><span class="hljs-comment">        onChange=&#123;setData&#125;</span><span class="hljs-comment">        onValidate=&#123;setValid&#125;</span><span class="hljs-comment">        displayType="row" // 详细配置见下</span><span class="hljs-comment">      /&gt; */</span>&#125;      &lt;button onClick=&#123;onSubmit&#125; type=<span class="hljs-string">"submit"</span>&gt;        提交      &lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">    &lt;/</span>div&gt;  );&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Demo;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FormRender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现excel的本地预览</title>
    <link href="/2020/08/11/preview-excel/"/>
    <url>/2020/08/11/preview-excel/</url>
    
    <content type="html"><![CDATA[<p>项目是外企的项目，它的线上服务器资源无法在公网访问到，所以无法使用微软公开的接口实现预览<br>由于不能使用微软接口在线预览 office 文件，所以自己实现了一套预览 excel 的方案，代码如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> produce <span class="hljs-keyword">from</span> <span class="hljs-string">'immer'</span>;<span class="hljs-keyword">import</span> XLSX <span class="hljs-keyword">from</span> <span class="hljs-string">'xlsx'</span>;<span class="hljs-keyword">import</span> &#123; Spin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span>;<span class="hljs-keyword">import</span> Tabs <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Enhanced/Tabs'</span>;<span class="hljs-keyword">import</span> &#123; request &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/Enhanced'</span>;<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.less'</span>;<span class="hljs-keyword">const</span> Index = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> &#123; src, ...rest &#125; = props;  <span class="hljs-keyword">const</span> [data, setData] = useState(<span class="hljs-literal">null</span>);  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (src) &#123;      request(src, &#123;        responseType: <span class="hljs-string">'arraybuffer'</span>,      &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (response.success) &#123;          <span class="hljs-keyword">const</span> workbook = XLSX.read(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(response.data), &#123;            type: <span class="hljs-string">'array'</span>,          &#125;);          <span class="hljs-keyword">const</span> newData = produce([], draftState =&gt; &#123;            <span class="hljs-comment">// eslint-disable-next-line</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(workbook.Sheets)) &#123;              draftState.push(&#123;                name: k,                html: XLSX.utils.sheet_to_html(v),              &#125;);            &#125;            <span class="hljs-keyword">return</span> draftState;          &#125;);          setData(newData);        &#125;      &#125;);    &#125;  &#125;, [src]);  <span class="hljs-keyword">return</span> (    &lt;div &#123;...rest&#125;&gt;      &#123;data ? (        &lt;Tabs          tabPanes=&#123;data.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> (&#123;            id: index,            title: item.name,            content: (              &lt;div className=&#123;styles.excel&#125; dangerouslySetInnerHTML=&#123;&#123; <span class="hljs-attr">__html</span>: item.html &#125;&#125; /&gt;            ),          &#125;))&#125;        /&gt;      ) : (        &lt;Spin style=&#123;&#123; <span class="hljs-attr">display</span>: <span class="hljs-string">'block'</span>, <span class="hljs-attr">margin</span>: <span class="hljs-string">'0 auto'</span> &#125;&#125; /&gt;      )&#125;    &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">  );</span><span class="hljs-regexp">&#125;;</span><span class="hljs-regexp"></span><span class="hljs-regexp">Index.displayName = 'ExcelViewer';</span><span class="hljs-regexp">export default Index;</span></code></pre><p><img src="/img/sheets.png" srcset="/img/loading.gif" alt="图片"></p><p>sheet[‘!ref’]：表示所有单元格的范围，例如从 A1 到 F8 则记录为 A1:F8；<br>sheet[!merges]：存放一些单元格合并信息，是一个数组，每个数组由包含 s 和 e 构成的对象组成，s 表示开始，e 表示结束，r 表示行，c 表示列；</p><table><thead><tr><th>键</th><th>描述</th></tr></thead><tbody><tr><td>v</td><td>源数据(未经过处理的数据)</td></tr><tr><td>w</td><td>格式化后的文本(如果能够被格式化)</td></tr><tr><td>t</td><td>单元格类型</td></tr><tr><td>r</td><td>解码后的富文本</td></tr><tr><td>h</td><td>渲染成 HTML 格式的富文本</td></tr><tr><td>c</td><td>单元格注释</td></tr><tr><td>z</td><td>格式化成字符串的数值</td></tr></tbody></table><p>v: “zhujun”<br>w: “zhujun”<br>t: “s” <code>// s 表示 string 类型，n 表示 number 类型，b 表示 boolean 类型，d 表示 date 类型，等等</code><br>r: <code>&quot;&lt;t&gt;zhujun&lt;t&gt;&quot;</code><br>h: “zhujun”</p><p>XLSX.utils.sheet_to_csv：生成 CSV 格式<br>XLSX.utils.sheet_to_txt：生成纯文本格式<br>XLSX.utils.sheet_to_html：生成 HTML 格式<br>XLSX.utils.sheet_to_json：输出 JSON 格式<br>XLSX.utils.sheet_to_row_object_array：按每行数据输出数组</p><p><em>几个重点：</em></p><ol><li>xlsx 方法的使用</li><li>immer 的使用</li><li>Object.entries()方法的使用</li><li>dangerouslySetInnerHTML 的使用</li></ol><p>Object.entries() 可以把一个对象的键值以数组的形式遍历出来，结果和 for…in 一致，但不会遍历原型属性。</p><pre><code class="hljs yaml"><span class="hljs-string">const</span> <span class="hljs-string">arr1</span> <span class="hljs-string">=</span> <span class="hljs-string">[&#123;</span> <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">];</span><span class="hljs-string">console.log(Object.entries(arr1));</span>  <span class="hljs-string">//</span> <span class="hljs-string">[['0',</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;],</span> <span class="hljs-string">['1',</span> <span class="hljs-string">'2'</span><span class="hljs-string">],</span> <span class="hljs-string">['2',</span> <span class="hljs-string">'3'</span><span class="hljs-string">]]</span><span class="hljs-string">const</span> <span class="hljs-string">arr2</span> <span class="hljs-string">=</span> <span class="hljs-string">[&#123;</span> <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;,</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">b:</span> <span class="hljs-number">2</span> <span class="hljs-string">&#125;,</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">c:</span> <span class="hljs-number">3</span> <span class="hljs-string">&#125;];</span><span class="hljs-string">console.log(Object.entries(arr2));</span>  <span class="hljs-string">//</span> <span class="hljs-string">[['0',</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;],</span> <span class="hljs-string">['1',</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">b:</span> <span class="hljs-number">2</span> <span class="hljs-string">&#125;],</span> <span class="hljs-string">['2',</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">c:</span> <span class="hljs-number">3</span> <span class="hljs-string">&#125;]]</span><span class="hljs-string">const</span> <span class="hljs-string">obj</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">sheet1:</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">zhujun:</span> <span class="hljs-number">666</span> <span class="hljs-string">&#125;&#125;;</span><span class="hljs-string">console.log(Object.entries(obj));</span>  <span class="hljs-string">//</span>  <span class="hljs-string">[</span> <span class="hljs-string">'sheet1'</span><span class="hljs-string">,&#123;</span> <span class="hljs-attr">zhujun:</span> <span class="hljs-number">666</span> <span class="hljs-string">&#125;</span> <span class="hljs-string">]</span></code></pre><p>在 react 中，展示富文本 ，字符串的方法，注意用法！</p><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> dangerouslySetInnerHTML=&#123;&#123; __html: '&lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">123</span>&lt;/<span class="hljs-keyword">div</span>&gt;' &#125;&#125; /&gt;</code></pre><hr><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Fragment, PureComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> XLSX <span class="hljs-keyword">from</span> <span class="hljs-string">'xlsx'</span>;<span class="hljs-keyword">import</span> &#123; Card, Spin, Tabs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd'</span>;<span class="hljs-keyword">import</span> &#123; formatMessage &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'umi-plugin-react/locale'</span>;<span class="hljs-keyword">import</span> &#123; Table &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/Enhanced'</span>;<span class="hljs-keyword">import</span> &#123; request &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/Enhanced'</span>;<span class="hljs-keyword">const</span> &#123; TabPane &#125; = Tabs;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.state = &#123;      workbook: <span class="hljs-literal">null</span>,      isLoading: <span class="hljs-literal">true</span>,    &#125;;  &#125;  componentDidMount() &#123;    <span class="hljs-keyword">const</span> &#123; src &#125; = <span class="hljs-keyword">this</span>.props;    <span class="hljs-keyword">if</span> (src) &#123;      request(src, &#123;        method: <span class="hljs-string">'get'</span>,        download: <span class="hljs-literal">true</span>,      &#125;).then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(resp.response.data);        <span class="hljs-keyword">const</span> workbook = XLSX.read(data, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'array'</span> &#125;);        <span class="hljs-keyword">this</span>.setState(&#123;          isLoading: <span class="hljs-literal">false</span>,          workbook,        &#125;);      &#125;);    &#125;  &#125;  render() &#123;    <span class="hljs-keyword">const</span> &#123; isLoading, workbook &#125; = <span class="hljs-keyword">this</span>.state;    <span class="hljs-keyword">return</span> (      &lt;Fragment&gt;        &#123;isLoading ? (          &lt;Spin size=<span class="hljs-string">"large"</span> /&gt;        ) : (          &lt;Tabs&gt;            &#123;workbook.SheetNames.map(<span class="hljs-function">(<span class="hljs-params">sheetName, sheetIndex</span>) =&gt;</span> &#123;              <span class="hljs-keyword">return</span> (                &lt;TabPane tab=&#123;sheetName&#125; key=&#123;sheetIndex&#125;&gt;                  &lt;Table                    columns=&#123;<span class="hljs-built_in">Object</span>.keys(                      XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName])[<span class="hljs-number">0</span>],                    ).map(<span class="hljs-function">(<span class="hljs-params">columnItem, columnIndex</span>) =&gt;</span> &#123;                      <span class="hljs-keyword">return</span> &#123;                        title: formatMessage(&#123; <span class="hljs-attr">id</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;columnItem&#125;</span>`</span> &#125;),                        dataIndex: columnItem,                        key: columnIndex,                      &#125;;                    &#125;)&#125;                    dataSource=&#123;XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName])&#125;                  /&gt;                &lt;<span class="hljs-regexp">/TabPane&gt;</span><span class="hljs-regexp">              );</span><span class="hljs-regexp">            &#125;)&#125;</span><span class="hljs-regexp">          &lt;/</span>Tabs&gt;        )&#125;      &lt;<span class="hljs-regexp">/Fragment&gt;</span><span class="hljs-regexp">    );</span><span class="hljs-regexp">  &#125;</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">export default Index;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>预览excel XLSX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《少有人走的路》</title>
    <link href="/2020/08/02/essay0802/"/>
    <url>/2020/08/02/essay0802/</url>
    
    <content type="html"><![CDATA[<p>这是一系列书，现在在读第 4 本《在焦虑的年代获得精神的成长》</p><p>心智成熟的旅程 ——自律，自信<br>勇敢的面对谎言 ——谎言是邪恶的根源<br>与心灵对话 ——人生错综复杂<br>这本书 ——人生没有简单的答案</p><p>所以下面的内容先是第 4 本内容，至于前面几本书写不写，看我心情吧～<br>这本是斯科特*派克在 60 岁的时候写的，相比之下我还是更喜欢他 40 岁写的第一本书叫《心智成熟的旅程》</p><blockquote><p>自我和灵魂常处于交战状态，自我需要拥有，拥有的越多越好，而灵魂需要放弃，放弃的越多越自由。所以前半生要追寻自我，后半生则要放下自我，追随灵魂。</p></blockquote><p>我们喋喋不休，说东道西，<br>却仍旧孤独<br>活着却孤独<br>归宿<br>在哪里？</p><blockquote><p>那些听不见音乐的人认为那些跳舞的人都疯了 ——— 尼采</p></blockquote><p>冲突：利益 偏见</p><blockquote><p>许多人宁愿死，也不愿意思考，事实上他们也确实至死都没有思考过 ——— 罗素</p></blockquote><p>草率思考和盲从心理<br>先入为主与贴标签<br>认为自己无所不知，无所不能，其实才是最大的蠢货。</p><p>自我才有自尊 灵魂没有自尊</p><p>思考最忌讳的是草率，倾听最忌讳的是分心。</p>]]></content>
    
    
    <categories>
      
      <category>读书心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>少有人走的路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《你不知道的javascript》</title>
    <link href="/2020/07/30/javascript/"/>
    <url>/2020/07/30/javascript/</url>
    
    <content type="html"><![CDATA[<h2 id="上卷"><a href="#上卷" class="headerlink" title="上卷"></a>上卷</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是能够储存变量当中的值，并且能在之后对这个 值进行访问或修改。</p><h4 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h4><ul><li>引擎</li></ul><p>从头到尾负责整个 javascript 程序的变异及执行过程</p><ul><li>编译器</li></ul><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活</p><ul><li>作用域</li></ul><p>引擎的另一个好朋友，负责手机并且维护由所有生命的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对撰写标识符的访问权限。</p><p>举个栗子 🌰</p><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(a)</span> <span class="hljs-comment">&#123; console.log( a ); // 2</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">( 2 )</span>;</span></code></pre><p>引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?<br>作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎:哥们太够意思了!好吧，我来执行一下 foo。<br>引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?<br>作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。<br>引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。<br>引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?<br>作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。<br>引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。<br>引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。<br>作用域:放心吧，这个变量没有变动过，拿走，不谢。<br>引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。<br>……</p><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span></code></pre><ol><li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li><li>接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。</li></ol><p>块级作用域<br>try catch 语句里面 catch 部分是块级作用域<br>let 可以在任意作用域中，通常是函数内部。可以当做块级变量～但是没有声明提升<br>const 也一样</p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>包括变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。</p><p>当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个 声明:var a;和 a = 2;。<br>第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。</p><p>声明变量提升</p><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><pre><code class="hljs javascript">foo(); <span class="hljs-comment">// 1</span><span class="hljs-keyword">var</span> foo;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );&#125;foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );&#125;;<span class="hljs-comment">// 会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log( <span class="hljs-number">1</span> );&#125;foo(); <span class="hljs-comment">// 1</span>foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log( <span class="hljs-number">2</span> );&#125;;</code></pre><p><strong>小结：</strong><br>我们习惯将 var a = 2;看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a<br>和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的 最顶端，这个过程被称为提升。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>为什么用 this。 简洁 ，复用性好</p><p>我觉得关于 this 真的没什么好总结的，就一句话就完事：<br>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>说实在的 这玩意我在红宝书里看过的</p><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">myObject</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span> <span class="hljs-string">a:2</span><span class="hljs-string">&#125;;</span>     <span class="hljs-string">Object.getOwnPropertyDescriptor(</span> <span class="hljs-string">myObject,</span> <span class="hljs-string">"a"</span> <span class="hljs-string">);</span>     <span class="hljs-string">//</span> <span class="hljs-string">&#123;</span><span class="hljs-string">//</span> <span class="hljs-attr">value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span><span class="hljs-string">//</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span><span class="hljs-string">//</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span><span class="hljs-string">//</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span> <span class="hljs-string">//</span> <span class="hljs-string">&#125;</span><span class="hljs-string">var</span> <span class="hljs-string">myObject</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;&#125;;</span>     <span class="hljs-string">Object.defineProperty(</span> <span class="hljs-string">myObject,</span> <span class="hljs-string">"a"</span><span class="hljs-string">,</span> <span class="hljs-string">&#123;</span>         <span class="hljs-attr">value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span><span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span>     <span class="hljs-string">&#125;</span> <span class="hljs-string">);</span>     <span class="hljs-string">myObject.a;</span> <span class="hljs-string">//</span> <span class="hljs-number">2</span><span class="hljs-string">//</span>  <span class="hljs-string">禁止一个对象添加新属性并且保留已有属性</span>        <span class="hljs-string">Object.preventExtensions(</span> <span class="hljs-string">myObject</span> <span class="hljs-string">);</span>     <span class="hljs-string">myObject.b</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span><span class="hljs-string">;</span>     <span class="hljs-string">myObject.b;</span> <span class="hljs-string">//</span> <span class="hljs-string">undefined</span></code></pre><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false</p><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值</p><p>for in 遍历对象中所有可枚举属性<br>for of 遍历对象{key:value}中的 value</p><p>构造函数 原型啥的不写了</p><h2 id="中卷"><a href="#中卷" class="headerlink" title="中卷"></a>中卷</h2><p>类型<br>值<br>原生函数<br>强制类型转换<br>语法<br>。。。又是 300 多页<br>我挑感兴趣的看吧</p><p>鸭子类型： 当一个东西长得像鸭子，叫声也像鸭子，那么它就是个鸭子</p><p>从 JavaScript 主程序(或另一个 Worker)中，可以这样实例化一个 Worker: var w1 = new Worker( “<a href="http://some.url.1/mycoolworker.js&quot;" target="_blank" rel="noopener">http://some.url.1/mycoolworker.js&quot;</a> );<br>这个 URL 应该指向一个 JavaScript 文件的位置(而不是一个 HTML 页面!)，这个文件将 被加载到一个 Worker 中。然后浏览器启动一个独立的线程，让这个文件在这个线程中作 为独立的程序运行。</p><p>Worker 之间以及它们和主程序之间，不会共享任何作用域或资源，那会把所有多线程编程 的噩梦带到前端领域，而是通过一个基本的事件消息机制相互联系。</p><p>Worker w1 对象是一个事件侦听者和触发者，可以通过订阅它来获得这个 Worker 发出的事 件以及发送事件给这个 Worker。<br>以下是如何侦听事件(其实就是固定的 “message” 事件):<br>w1.addEventListener( “message”, function(evt){<br>// evt.data<br>} );<br>也可以发送 “message” 事件给这个 Worker:<br>w1.postMessage( “something cool to say” );<br>在这个 Worker 内部，收发消息是完全对称的: // “mycoolworker.js”<br>addEventListener( “message”, function(evt){<br>// evt.data<br>} );<br>postMessage( “a really cool reply” );<br>注意，专用 Worker 和创建它的程序之间是一对一的关系。也就是说，”message” 事件 没有任何歧义需要消除，因为我们确定它只能来自这个一对一的关系:它要么来自这个 Worker，要么来自主页面。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>也读过周爱民写的 js 基本原理，总的来说对 js 有了一些认知了。太深刻的，复杂的我就不细研究了。就这。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>药</title>
    <link href="/2020/07/14/essay0714/"/>
    <url>/2020/07/14/essay0714/</url>
    
    <content type="html"><![CDATA[<p>药医不死病，死病无药医。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2020全国2卷作文随笔</title>
    <link href="/2020/07/07/essay0707/"/>
    <url>/2020/07/07/essay0707/</url>
    
    <content type="html"><![CDATA[<p>全国 Ⅱ 卷作文解析+阅读下面的材料，根据要求写作。<br>墨子说：“视人之国，若视其国；视人之家，若视其家；视人之身，若视其身。”<br>英国诗人约翰多恩说：“没有人是自成一体、与世隔绝的孤岛，每一个人都是广袤大陆的一部分。”<br>“青山一道同云雨，明月何曾是两乡。”“同气连枝，共盼春来。”……2020 年的春天，这些寄言印在国际社会援助中国的物资上，表达了世界人民对中国的支持。<br>“山和山不相遇，人和人要相逢。”“消失吧，黑夜！黎明时我们将获胜！”……这些话语印在中国援助其他国家的物资上，寄托着中国人民对世界的祝福。<br>“世界青年与社会发展论坛”邀请你作为中国青年代表参会，发表以“携手同一世界，青年共创未来”为主题的中文演讲。请完成一篇演讲稿。<br>要求：结合材料内容及含意完成写作任务；选好角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于 800 字。</p><p>2020 年的全国 2 卷作文，看完这个并没有想写作文的冲动。<br>不过我喜欢这句 山和山不相遇，人和人要相逢</p><p>山和山不会相遇吗？<br>你可曾看过连绵的山脉，<br>那一山挨着一山，<br>就好比一山爱着一山，<br>还可能有很多小山，哈哈<br>这世界上有很多山啊，天生就是在一起的<br>相互依偎，不曾分离，坚定的心就像石头一样。<br>奥对，山，本来就是石头。<br>坚定的石头的心，守在身边一动不动<br>主要它想动也没办法啊<br>它没有腿啊<br>哈哈哈哈哈哈哈哈<br>其实严谨来说啊<br>那些连绵依偎的山<br>也不是天生就在一起的<br>只不过从我的生命周期来说<br>从我的生到死的时间里<br>在一起的山脉还是在一起<br>多好<br>多让人羡慕<br>但是地球板块是会移动的鸭<br>在一起的山脉<br>在板块移动过程中<br>可能会拥抱的更加紧密<br>也可能会默默分离<br>不在一起的山<br>也可能一步步的靠近<br>我喜欢那一座山<br>我要走去它那里<br>只要是有一颗愿意接近的心<br>我的每一步<br>每一厘米<br>就都有意义<br>然后<br>在相遇的那一刻<br>谁还在乎是不是已经天荒地老<br>谁还在乎经历了多少春秋更替<br>就在那一刻<br>它们拉住彼此的手<br>都会产生一种异常激动的情绪<br>用了三千万年<br>终于来到了这里<br>怎么他妈的你也是个男的！</p><p>人和人需要相逢吗<br>需要<br>我需要你<br>这世界的每一个人你听好<br>我需要你<br>你来吧<br>来跟我相逢吧<br>我在<br>北纬 41°48′11.75″<br>东经 123°25′31.18<br>你来吧<br>来跟我相逢吧<br>见面记得给我一块钱<br>如果每个人都给我一块钱<br>那我就能买点肉留着过年<br>奥对了<br>路费火车票啥的我可不报销</p><p>相逢这个字眼<br>总是能给人憧憬或者希望<br>在对未知的好奇和幻想中<br>莫名的就对相逢这件事产生了好感<br>不过比起相逢<br>我更喜欢重逢<br>经历分离<br>经历时间<br>经历别人<br>经历了很多以后<br>还是想再见你<br>如果刚好你也这样想<br>那重逢对于我们就有了意义<br>也许是儿时嬉戏的玩伴<br>也许是一生所爱的情人<br>也许是刀山火海的兄弟<br>也许是阴阳两隔的亲人<br>让我们重逢吧！<br>让我们重逢吧。<br>我会告诉你我有多么的想你<br>一个字一个字的说给你听<br>在你的耳边<br>或者<br>在我的梦里</p><p>山和山也许相遇<br>人和人未必相逢<br>如果有幸曾与你相逢<br>那就让我们重逢吧<br>火车票我会给你报了</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>读深入浅出React和Redux</title>
    <link href="/2020/07/06/reactandredux/"/>
    <url>/2020/07/06/reactandredux/</url>
    
    <content type="html"><![CDATA[<p>开始读书～<br>程墨编著<br>下面的内容比较随性，暂时自己写给自己看的，不建议阅读。</p><ul><li>react 不支持 ie8 以下</li></ul><p>“scripts”:{<br>“start”:”react-scripts start”,</p><p>“eject”:”react-scripts eject”<br>}</p><p>eject 弹射<br>会把潜藏在 react-scripts 重的一系列技术栈配置都弹射到应用的顶层。<br>然后我们就可以研究这些配置细节了，而且可以更灵活的定制应用的配置。<br>⚠️ 注意啊 eject 命令不可逆 ，在执行 npm run eject 之前最好备份一下。</p><hr><p>如果用 jq 写组件，<br>先写个 index.html<br>然后写 html dom 节点 然后是 js 绑定点击逻辑啥的<br>jq 会让事件和 dom 造成纠缠代码结构</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="react-总结公式为"><a href="#react-总结公式为" class="headerlink" title="react 总结公式为"></a>react 总结公式为</h3><p>UI = render（data）<br>响应式编程 （Reactive programming）<br>一看这个名字，就知道为啥 react 框架名字的由来了</p><h3 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h3><p>说是第五章具体说虚拟 dom</p><h3 id="设计高质量的-React-组件"><a href="#设计高质量的-React-组件" class="headerlink" title="设计高质量的 React 组件"></a>设计高质量的 React 组件</h3><h4 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h4><p>把问题分解为多个小问题，必要的时候可以拆分大组件，分为小组件。<br>组件划分要满足 高内聚 低耦合</p><blockquote><p>高内聚 ：把逻辑紧密的内容放在一个组件中<br>低耦合 ：不同组件之间的依赖关系要尽量弱化</p></blockquote><h4 id="state-props"><a href="#state-props" class="headerlink" title="state props"></a>state props</h4><p>对外用 props<br>内部用 state</p><h5 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h5><p>counter(这是个组件名).proptypes = {<br>a:PropTypes.string.isRequired<br>B:PropTypes.number<br>}</p><p>规定了 a 属性这个必须是字符串类型，并且必须有值，不能 undefined 啥的<br>但是这个 B 因为没有 isRequired 所以没有 B 也无所谓</p><p>这个 propTypes 是个辅助开发的功能，可以不写的<br>如果写了这玩意，要在产品上线发布的时候，用 babel-react-optimize 去掉这个东西，理由如下：</p><ol><li>占用代码空间</li><li>消耗 cpu 计算资源</li><li>对用户输出报错无意义</li></ol><h5 id="state-不用-setState-方法"><a href="#state-不用-setState-方法" class="headerlink" title="state 不用 setState 方法"></a>state 不用 setState 方法</h5><p>如果不用这个方法，会野蛮的修改 state 的值，不过并不会触发驱动组件更新。所以页面上没有效果。</p><h5 id="不要直接修改传染源的-props-对象的值"><a href="#不要直接修改传染源的-props-对象的值" class="headerlink" title="不要直接修改传染源的 props 对象的值"></a>不要直接修改传染源的 props 对象的值</h5><p>如果一个子组件改了 props 的值，其他子组件就会陷入程序混乱了。所以不行不允许这样处理</p><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><h4 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h4><p>constructon<br>getInitalState<br>getDefaultProps<br>componentWillMount<br>render<br>componentDidMount</p><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>使用这个适用于下面目的：</p><ul><li>初始化 state</li><li>绑定成员函数的 this 环境</li></ul><p>this.onClickButton = this.onClickButton.bind(this)</p><p>这样写，会用过 bind 方法，让当前实例中 onClickButton 函数被调用的时候，this 指向始终都是当前组件实例。</p><p>this.foo = ::this.foo;<br>等同于：<br>this.foo = this.foo.bind(this);<br>这里:: 两个冒号的操作符叫做 bind 操作符。<br>不知道是不是 ES 标准语法，暂时不推荐使用</p><h5 id="render"><a href="#render" class="headerlink" title="render"></a>render</h5><p>render 函数只是返回一个 JSX 描述的结构，最终由 React 来操作渲染的过程<br>render 函数应该是一个纯函数，不要产生任何的副作用，<br>在 render 函数中去调用 this.setState 是错误的，因为一个纯函数不应该引起状态的改变</p><h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h5><p>render 调用完以后，componentDidmount 并不会被立刻调用，当他调用的时候，render 函数返回的东西已经引发了渲染，<br>组件已经被“装载”到 DOM 树上。<br>render 函数本身并不王 DOM 树上渲染或者装载内容，它只是返回一个 JSX 对象，然后由 React 库决定如何渲染。<br>而 React 库要把所有的组件都返回结果综合起来以后，才能做出对应 dom 修改，所以，在所有组件都 render 完事了以后，<br>才会开始进行调用各个组件的 componentDidMount<br>componentDidMount 只在浏览器端执行</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><p>componentWillReceiveProps<br>shouldComponentUpdate<br>componentWillUpdate<br>render<br>componentDidUpdate</p><h5 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h5><p>只要是副组件的 render 被调用，在 render 里渲染的子组件就会经历更新的过程，逗号<br>不管父组件传给子组件的 props 有没有改变，都会触发上面这个生命生命周期<br>⚠️ 注意：子组件内通过 this.setState 方法触发的更新过程不会调用这个函数。理由如下：<br>这个生命周期函数适合根据新的 props 值，也就是参数 nextProps 来计算出是不是要更新内部状态 state，<br>更新组件内部方法就是 this.setState，如果 setState 会导致这个生命周期调用，就死循环了鸭</p><h5 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)"></a>shouldComponentUpdate(nextProps,nextState)</h5><p>决定一个组件什么时候不需要渲染<br>和 render 是 React 生命周期中唯二要求有返回结果的函数；<br>这个函数要返回一个布尔值，告诉 React 这个组件这次是否要继续更新</p><pre><code class="hljs kotlin">shouldComponentUpdata(nextProps,nextStates)&#123;  <span class="hljs-keyword">return</span> (nextProps.caption !== <span class="hljs-keyword">this</span>.props.Caption) ||   (nextState.count !== <span class="hljs-keyword">this</span>.state.count)&#125;</code></pre><h4 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h4><h5 id="conponentWillUnmount"><a href="#conponentWillUnmount" class="headerlink" title="conponentWillUnmount"></a>conponentWillUnmount</h5><p>conponentWillUnmount 往往与 componnetDidMount 有关，比如用了非 React 的方法创造了一些 DOM 元素，<br>如果不管理的话会可能造成内存泄漏，就需要在这里处理掉</p><h3 id="state-和-prop-的局限"><a href="#state-和-prop-的局限" class="headerlink" title="state 和 prop 的局限"></a>state 和 prop 的局限</h3><ol><li>父组件 子组件 孙子组件什么的会有重复的数据</li><li>包含 3 级或者以上的组件结构，可能中间那一层根本就用不上这个 prop，但是却还要传递<blockquote><p>简称为数据的冗余和重复</p></blockquote></li></ol><h2 id="从-Flux-到-Redux"><a href="#从-Flux-到-Redux" class="headerlink" title="从 Flux 到 Redux"></a>从 Flux 到 Redux</h2><h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p>单向数据流</p><h4 id="MVC-框架的缺陷"><a href="#MVC-框架的缺陷" class="headerlink" title="MVC 框架的缺陷"></a>MVC 框架的缺陷</h4><p>Model 模型 大部分业务逻辑应该放在这里<br>View 视图 这里应该尽量避免业务逻辑<br>Controller 控制器 负责接受用户输入，根据用户输入调用对应的 Model 逻辑，产生的结果给 View 层</p><p>但是各个不用模块之间的依赖关系让系统变得脆弱且不可预测<br>model 和 view 之间的通信让局面变得烂七八糟</p><p>所以就整出这个 Flux<br>action 到 dispatch 到 store 到 view<br>view 通过 action 调用 dispatch</p><p>存在于 Flux 框架中的 React 组件需要实现以下功能：</p><ul><li>创建时要读取 Store 上的状态来初始化组件内部形态</li><li>当 Store 上状态发生变化的时候，组件要立刻同步更新内部状态保持一致</li><li>view 如果要改变 Store 状态，必须且只能派发 action</li></ul><h4 id="Flux-的不足"><a href="#Flux-的不足" class="headerlink" title="Flux 的不足"></a>Flux 的不足</h4><ul><li>在 Flux 体系中，如果两个 Store 之间有逻辑依赖关系，就必须用上 Dispatcher 的 waitFor 函数。依赖关系处理不够优雅</li><li>难以进行服务器端的渲染</li><li>stroe 混杂了逻辑和状态</li></ul><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>redux 是 flux 的一种实现。</p><p>redux 的基本原则</p><ul><li>唯一数据源<br>应用的状态数据置存储在唯一的一个 store 上</li><li>保持状态只读<br>要修改 store 状态，必须通过派发一个 action 对象完成。但是改变状态的方法不是去修改状态上的值，而是创建一个新的状态对象返回给 Redux</li><li>数据改变只能通过纯函数完成<br>reducer 必须是纯函数<br>reducer 只负责计算状态，不负责存储状态。</li></ul><h4 id="redux-实例"><a href="#redux-实例" class="headerlink" title="redux 实例"></a>redux 实例</h4><p>我们创造一个 src/Store.js 文件，这个文件输出全局唯一的那个 Store，代码如下:</p><pre><code class="hljs routeros">import &#123;createStore&#125; <span class="hljs-keyword">from</span> ’redux’import reducer <span class="hljs-keyword">from</span> ’. /Reducer.js ’;const initValues = &#123; ’First’: 0, ’Second’: 10, ’Third’: 20 &#125;const store= createStore (reducer, initValues);<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>store;</code></pre><p>想记点什么 又无从下手 。。这段知识，，，我不知道怎么表达</p><p>在 redux 框架下，一个 react 组件基本上就是要完成以下：</p><ol><li>和 redux store 打交道，读取 store 状态，用于初始化组件的状态，同时还要监听 store 的状态改变<br>当 store 状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新 store 状态时，就要派发 action 对象</li><li>根据当前 props 和 state，渲染出用户界面。</li></ol><p>所以把 react 组件拆分为两个，第一个组件负责跟 redux store 打交道，处于外层，称为<strong>容器组件</strong> （聪明组件）<br>负责渲染界面的组件在内层，称为<strong>展示组件</strong> （傻瓜组件）</p><h4 id="组件-Context"><a href="#组件-Context" class="headerlink" title="组件 Context"></a>组件 Context</h4><p>上下文环境<br>搜先上级组件要宣称自己支持 context，并且提供一个函数来返回代表 Context 的 对象<br>然后，这个上级组件之下的所有子孙组件，只要宣称自己需要这个 context，就可以 通过 this.context 访问到这个共同的环境对象。</p><h4 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h4><pre><code class="hljs scala"><span class="hljs-keyword">import</span> &#123;<span class="hljs-type">PropTypes</span>, <span class="hljs-type">Component</span>&#125; from ’react’;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123; getChildContext&#123;) &#123;<span class="hljs-keyword">return</span> &#123;store: <span class="hljs-keyword">this</span>.props.storerender() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.children;  &#125;&#125;</code></pre><p>就是在每个组件外层都套上</p><pre><code class="hljs apache"><span class="hljs-section">&lt;Provider&gt;</span>  <span class="hljs-section">&lt;Children/&gt;</span><span class="hljs-section">&lt;/Provider&gt;</span></code></pre><p>除了吧渲染工作完全交给子组件，Provider 还要提供一个函数 getChildContext ，这个函数返回的就是代表 Context 的对象。<br>为了让 Provider 能够被 React 认可为一个 Context 的提供者，还需要指定 Provider 的 childContextTypes 属性， 代码如下:</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Provider</span>.</span></span>childContextTypes = &#123;   store: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropTypes</span>.</span></span>ob]ect&#125;</code></pre><p>Provider 只是把渲染工作完全交给子组件，它扮演的角色只是提供 Context，包住了最顶层的 组件，也就让 context 覆盖了整个应用中所有组件。</p><p>为了让 CounterContainer 能够访问到 context，必须给 CounterContainer 类的 context­<br>Types 赋值和 Provider.childContextTypes 一样的值，两者必须一致，不然就无法访问到 context，代码如下:<br><code>CounterContainer.contextTypes = { store: PropTypes.。bject</code><br>在 CounterContainer 中，所有对 store 的访问，都是通过 this.context.store 完成，因 为 this.context 就是 Provider 提供的 context 对象，所以 getOwnState 函数代码如下:</p><pre><code class="hljs kotlin">getOwnState() &#123;  <span class="hljs-keyword">return</span> &#123;    value: <span class="hljs-keyword">this</span> .context. store .getState () [<span class="hljs-keyword">this</span>. props .caption]  &#125;&#125;</code></pre><p>还有一点，因为我们自己定义了构造函数，所以要用上第二个参数 context，代码<br>如下:<br>constructor (props, context) { super(props, context);<br>在调用 super 的时候，一定要带上 context 参数，这样才能让 React 组件初始化实例<br>中的 context，不然组件的其他部分就无法使用 this.context。</p><h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><p>connect : 链接容器组件和傻瓜组件，<br>把 store 伤的状态转化为内层傻瓜组件的 prop，把内层傻瓜组件中的用户动作转化为派送给 store 的动作</p><p>Provider：提供包含 store 的 context</p><hr><p>export default connect(mapStateToProps, mapDispatchToProps) (Cunter)</p><p>一个状态节点只属于一个模块，这里的“拥有权”指的是“修改权”，而不是“读取权”，<br>实际上，Redux Store 上的全部状态，在任何时候，对任何模块都是可以读取的，但是更新修改只能上跟自己相关的那一部分模块的数据</p><p>在设计 redux store 的状态树时，要尽量保持树形结构的扁平。一个很复杂的状态树是难以管理的。</p><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><h4 id="操纵-prop"><a href="#操纵-prop" class="headerlink" title="操纵 prop"></a>操纵 prop</h4><p>高阶组件可以增减/删除/修改传递给包裹组件的 props 列表</p><pre><code class="hljs scala">const addNewProps = (<span class="hljs-type">WrappedComponent</span>, newProps) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrappingComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    render()&#123;      <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">WrappedComponent</span> &#123;...<span class="hljs-keyword">this</span>.props&#125; &#123;...newProps &#125;&gt;    &#125;  &#125;&#125;</code></pre><h4 id="访问-ref"><a href="#访问-ref" class="headerlink" title="访问 ref"></a>访问 ref</h4><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> refsHOC =(WrappedComponent) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOCComponent</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>()&#123;      <span class="hljs-keyword">super</span>(...arguments)      <span class="hljs-keyword">this</span>.linkRef = <span class="hljs-keyword">this</span>.linkRef.bind(<span class="hljs-keyword">this</span>)    &#125;    linkRef(wrappedInstance)&#123;      <span class="hljs-keyword">this</span>._root = wrappedInstance;    &#125;    render()&#123;      <span class="hljs-keyword">const</span> props = &#123;...<span class="hljs-keyword">this</span>.props, ref: <span class="hljs-keyword">this</span>.linkRef&#125;      <span class="hljs-keyword">return</span> &lt;WrappedComponent &#123;...props&#125;&gt;    &#125;  &#125;&#125;</code></pre><h4 id="抽取状态"><a href="#抽取状态" class="headerlink" title="抽取状态"></a>抽取状态</h4><p>比如 react-redux 的 connect 函数<br>在傻瓜组件通常不要管理自己的状态，所有状态的管理都交给外面 的容器组件，这个模式就是“抽取状态”</p><pre><code class="hljs scala">const doNothing = () =&gt; (&#123;&#125;);function connect(mapStateToProps=doNothing,mapDispatchToProps=doNothing)&#123;  <span class="hljs-keyword">return</span> function(<span class="hljs-type">WrappedComponent</span>)&#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOCComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;      <span class="hljs-comment">// 在这里定义HOCComponent的生命周期函数</span>    &#125;    <span class="hljs-type">HOCComponent</span>.contextTypes = &#123;      store: <span class="hljs-type">React</span>.<span class="hljs-type">PropTypes</span><span class="hljs-class">.<span class="hljs-keyword">object</span></span><span class="hljs-class">    &#125;</span><span class="hljs-class">    <span class="hljs-title">return</span> <span class="hljs-title">HOCComponent</span></span>;  &#125;&#125;</code></pre><h4 id="包装组件"><a href="#包装组件" class="headerlink" title="包装组件"></a>包装组件</h4><pre><code class="hljs scala">const styleHOC = (<span class="hljs-type">WrappedComponent</span>, style) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOCComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    render()&#123;      <span class="hljs-keyword">return</span> (        &lt;div style=&#123;style&#125;&gt;          &lt;<span class="hljs-type">WrappedComponent</span> &#123;...<span class="hljs-keyword">this</span>.props&#125;&gt;        &lt;/div&gt;      )    &#125;  &#125;&#125;</code></pre><h3 id="继承方式的高阶组件"><a href="#继承方式的高阶组件" class="headerlink" title="继承方式的高阶组件"></a>继承方式的高阶组件</h3><p>暂时不理解 ，不写了</p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>polyfill 指的是“用于实现浏览器不支持原生功能的代码”，比如，现代浏览器应<br>该支持 fetch 函数，对于不支持的浏览器，网页中引入对应 fetch 的 polyfill 后， 这个 polyfill 就给全局的 window 对象上增加一个 fetch 函数，让这个网页中的 JavaScript 可以直接使用 fetch 函数了，就好像浏览器本来就支持 fetch 一样 。 在 这个链接上<a href="https://github.com/github/fetch可以找到fetchpolyfill的一个实现。" target="_blank" rel="noopener">https://github.com/github/fetch可以找到fetchpolyfill的一个实现。</a></p><p>react 你本地调试的时候,你直接请求接口肯定是跨域了，你的网页应用域名 localhost，你对应的服务器域名也是这玩意，所以你跨域啊<br>但是不慌，creat react app 有代理功能 proxy （来跟我发音，抛克西）</p><p>creat react-app 陌生成应用的 proxy 功能只是方便开发，在实际的生产环境中，使<br>用这个 proxy 功能就不合适了，应该要开发出自己的代理服务器来满足生产环境 的需要 。</p><h4 id="redux-thunk-中间件"><a href="#redux-thunk-中间件" class="headerlink" title="redux-thunk 中间件"></a>redux-thunk 中间件</h4><p>在 reducer 调用前调用的玩意儿<br>action =&gt; 中间件（比如 thunk）=&gt; reducer =&gt; state</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单测有一堆框架。<br>看了一遍。。。还是不想写单测</p><h3 id="扩展-REDUX"><a href="#扩展-REDUX" class="headerlink" title="扩展 REDUX"></a>扩展 REDUX</h3><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-react -redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http请求方方面面安排一波</title>
    <link href="/2020/07/01/request/"/>
    <url>/2020/07/01/request/</url>
    
    <content type="html"><![CDATA[<p>前言：下边的内容是从 XMLHttpRequest，到封装 XMLHttpRequest，再到 axios。<br>弄了很久啊，查资料，查官网信息，整理各种文档，输出各种观点。巨佬们慢慢看吧～</p><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="-XMLHttpRequest"></a>-XMLHttpRequest</h2><p>XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。<br>咱们硬核一点，直接上代码</p><h4 id="简单例子-🌰"><a href="#简单例子-🌰" class="headerlink" title="简单例子 🌰"></a>简单例子 🌰</h4><pre><code class="hljs pgsql">let xhr = <span class="hljs-built_in">new</span> XMLHttpRequest();xhr.<span class="hljs-keyword">open</span>(<span class="hljs-string">'GET'</span>,<span class="hljs-string">'https://www.baidu.com'</span>,<span class="hljs-keyword">true</span>,username,<span class="hljs-keyword">password</span>); // 解释一下参数。<span class="hljs-keyword">GET</span>释请求方法，必须得有，http请求方法有很多，常用post/<span class="hljs-keyword">get</span> ，这里的参数写法不区分大小写，写成‘<span class="hljs-keyword">get</span>’也是可以的。 // 第二个参数是请求的url，必须得有。 // 第三个参数这里的<span class="hljs-keyword">true</span> 代表是否异步 ，如果是<span class="hljs-keyword">true</span>就异步，<span class="hljs-keyword">false</span>就同步 。默认为异步。 // username：可选参数，如果服务器需要验证，该参数指定用户名，如果未指定，当服务器需要验证时，会弹出验证窗口。 // <span class="hljs-keyword">password</span>：可选参数，验证信息中的密码部分，如果用户名为空，则该值将被忽略。xhr.send(body) // body是通过该请求发送的参数数据啥的，不传就不用填写。</code></pre><p>这里插播一下请求失败的错误码，想了一下，还是放在这篇文里边吧，反正发请求就会有请求失败的可能嘛。<br>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。常见状态代码、状态描述的说明如下。<br>200 OK：客户端请求成功。<br>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。<br>401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。<br>403 Forbidden：服务器收到请求，但是拒绝提供服务。<br>404 Not Found：请求资源不存在，举个例子：输入了错误的 URL。<br>500 Internal Server Error：服务器发生不可预期的错误。<br>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</p><p><strong>通常报 400 多的时候，咱们前端就偷偷自己找找原因，报 500 多的时候，直接找后端就行。</strong></p><p>上边是个简单的栗子 🌰，让我们一点一点的往上加东西～</p><h3 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h3><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.open(<span class="hljs-string">'GET'</span>,<span class="hljs-string">'https://www.baidu.com'</span>,<span class="hljs-literal">true</span>,username,password);xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.readyState === <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-keyword">this</span>.status === <span class="hljs-string">'200'</span>)&#123;    <span class="hljs-comment">// 这里this就是xhr this.readyState 就是 xhr.readyState</span>    <span class="hljs-keyword">do</span> something  &#125;&#125;xhr.send(body)</code></pre><p>这个栗子里 xhr 多了一个属性 onreadystatechange 。onreadystatechange 是一个事件句柄。后边是事件触发的回调函数。当 XMLHttpRequest 对象的状态发生改变时，会触发此函数。状态从 0 (uninitialized) 到 4 (complete) 进行变化。仅在状态为 4 时，我们才执行代码。</p><p><em>补充一下 readyState 的知识，看看知道有这么个事就行。</em><br><em>0 未初始化。表示对象已经建立，但是尚未初始化，尚未调用 open() 方法</em><br><em>1 初始化。表示对象已经建立，尚未调用 send() 方法</em><br><em>2 发送数据。表示 send() 方法已经调用，但是当前的状态及 HTTP 头未知</em><br><em>3 数据传送中。已经接收部分数据，因为响应及 HTTP 头不安全，这时通过 responseBody 和 responseText 获取部分数据会出现错误</em><br><em>4 完成。数据接收完毕，此时可以通过 responseBody 和 responseText 获取完整的响应数据</em></p><h3 id="如何设置-request-header"><a href="#如何设置-request-header" class="headerlink" title="如何设置 request header"></a>如何设置 request header</h3><p>setRequestHeader(name, value)</p><p>name 参数是要设置的头部的名称。这个参数不应该包括空白、冒号或换行。<br>value 参数是头部的值。这个参数不应该包括换行。</p><pre><code class="hljs vhdl">let xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.<span class="hljs-keyword">open</span>(<span class="hljs-symbol">'GET</span>',<span class="hljs-symbol">'https</span>://www.baidu.com',<span class="hljs-literal">true</span>,username,password);xhr.setRequestHeader(<span class="hljs-symbol">'Content</span>-<span class="hljs-keyword">Type</span>', <span class="hljs-symbol">'one</span>');xhr.setRequestHeader(<span class="hljs-symbol">'Content</span>-<span class="hljs-keyword">Type</span>', <span class="hljs-symbol">'two</span>');// 最终request header中<span class="hljs-string">"Content-Type"</span>为: one, twoxhr.send(<span class="hljs-keyword">body</span>)</code></pre><p>方法的第一个参数 header 大小写不敏感，即可以写成 content-type，也可以写成 Content-Type，甚至写成 content-Type。</p><p>Content-Type 的默认值与具体发送的数据类型有关。</p><p>setRequestHeader 必须在 open()方法之后，send()方法之前调用，否则会抛错。</p><p>setRequestHeader 可以调用多次，最终的值不会采用覆盖 override 的方式，而是采用追加 append 的方式。</p><h3 id="如何指定-xhr-response-的数据类型"><a href="#如何指定-xhr-response-的数据类型" class="headerlink" title="如何指定 xhr.response 的数据类型"></a>如何指定 xhr.response 的数据类型</h3><p>xhr.overrideMimeType(‘text/plain; charset=utf-8’) // xhr level 1 使用的方法。</p><p>xhr.responseType = ‘blob’ // xhr level 2 可以用的，比上面简单很多，但是说是兼容性稍微差一点点。不过我没发现过任何问题，推荐用下边的写法</p><h3 id="如何设置请求的超时时间"><a href="#如何设置请求的超时时间" class="headerlink" title="如何设置请求的超时时间"></a>如何设置请求的超时时间</h3><p>如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest 提供了 timeout 属性来允许设置请求的超时时间。<br>xhr.timeout = 0<br>单位：milliseconds 毫秒<br>默认值：0，即不设置超时</p><p>⚠️ 注意：<strong>当 xhr 为一个 sync 同步请求时</strong>，xhr.timeout 必须置为 0，否则会抛错。并且 xhr.withCredentials 必须为 false</p><p>xhr.responseType 必须为””（注意置为”text”也不允许）</p><h3 id="如何获取上传、下载的进度"><a href="#如何获取上传、下载的进度" class="headerlink" title="如何获取上传、下载的进度"></a>如何获取上传、下载的进度</h3><p>在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。<br>我们可以通过 onprogress 事件来实时显示进度，默认情况下这个事件每 50ms 触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的 onprogress 事件：</p><p>上传触发的是 xhr.upload 对象的 onprogress 事件</p><p>下载触发的是 xhr 对象的 onprogress 事件</p><pre><code class="hljs cs">xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;<span class="hljs-function">function <span class="hljs-title">updateProgress</span>(<span class="hljs-params"><span class="hljs-keyword">event</span></span>)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.lengthComputable) &#123;      <span class="hljs-keyword">var</span> completedPercent = <span class="hljs-keyword">event</span>.loaded / <span class="hljs-keyword">event</span>.total;    &#125; &#125;</code></pre><h3 id="如何才能中止请求"><a href="#如何才能中止请求" class="headerlink" title="如何才能中止请求"></a>如何才能中止请求</h3><p>xhr.onreadystatechange = function () {}; //清理事件响应函数<br>xhr.abort(); //中止请求</p><p>在调用 abort() 方法前，应先清除 onreadystatechange 事件处理函数，因为 IE 和 Mozilla 在请求中止后也会激活这个事件处理函数。如果给 onreadystatechange 属性设置为 null，则 IE 会发生异常，所以为它设置一个空函数。</p><h3 id="请求成功的回调"><a href="#请求成功的回调" class="headerlink" title="请求成功的回调"></a>请求成功的回调</h3><p>前面写过，就是在 onreadystatechange 判断 readyState == 4 。。。。。去上面看哈<br>当然啦 ，还有一种方法，也是我比较推荐的，</p><pre><code class="hljs lua">xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &#123;   //如果请求成功   <span class="hljs-keyword">if</span>((xhr.<span class="hljs-built_in">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-built_in">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-built_in">status</span> == <span class="hljs-number">304</span>)&#123;     //<span class="hljs-keyword">do</span> successCallback   &#125; &#125;</code></pre><h3 id="比较完整的-http-请求，方便大家用的时候复制粘贴，嘿嘿"><a href="#比较完整的-http-请求，方便大家用的时候复制粘贴，嘿嘿" class="headerlink" title="比较完整的 http 请求，方便大家用的时候复制粘贴，嘿嘿"></a>比较完整的 http 请求，方便大家用的时候复制粘贴，嘿嘿</h3><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<span class="hljs-comment">// 请求成功回调函数</span>xhr.onload = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request success'</span>);&#125;;<span class="hljs-comment">// 请求结束</span>xhr.onloadend = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request loadend'</span>);&#125;;<span class="hljs-comment">// 请求出错</span>xhr.onerror = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request error'</span>);&#125;;<span class="hljs-comment">// 请求超时</span>xhr.ontimeout = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request timeout'</span>);&#125;;<span class="hljs-comment">// 请求回调函数.XMLHttpRequest标准又分为Level 1和Level 2,这是Level 1和的回调处理方式</span><span class="hljs-comment">// xhr.onreadystatechange = () =&gt; &#123;</span><span class="hljs-comment">//  if (xhr.readyState !== 4) &#123;</span><span class="hljs-comment">//  return;</span><span class="hljs-comment">//  &#125;</span><span class="hljs-comment">//  const status = xhr.status;</span><span class="hljs-comment">//  if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status === 304) &#123;</span><span class="hljs-comment">//  console.log('request success');</span><span class="hljs-comment">//  &#125; else &#123;</span><span class="hljs-comment">//  console.log('request error');</span><span class="hljs-comment">//  &#125;</span><span class="hljs-comment">//  &#125;;</span>xhr.timeout = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置超时时间,0表示永不超时</span><span class="hljs-comment">// 初始化请求</span>xhr.open(<span class="hljs-string">'GET/POST/DELETE/...'</span>, <span class="hljs-string">'/url'</span>, <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>);<span class="hljs-comment">// 设置期望的返回数据类型 'json' 'text' 'document' ...</span>xhr.responseType = <span class="hljs-string">''</span>;<span class="hljs-comment">// 设置请求头</span>xhr.setRequestHeader(<span class="hljs-string">''</span>, <span class="hljs-string">''</span>);<span class="hljs-comment">// 发送请求</span>xhr.send(<span class="hljs-literal">null</span> || <span class="hljs-keyword">new</span> FormData || <span class="hljs-string">'a=1&amp;b=2'</span> || <span class="hljs-string">'json字符串'</span>);</code></pre><h2 id="封装-XMLHttpRequest"><a href="#封装-XMLHttpRequest" class="headerlink" title="-封装 XMLHttpRequest"></a>-封装 XMLHttpRequest</h2><h3 id="初步封装"><a href="#初步封装" class="headerlink" title="初步封装"></a>初步封装</h3><p>下面的代码有点多，不爱看可以不看，没什么难点。大体思路我这里告诉你：<br>先写一个默认的请求需要的一些参数啥的，比如默认 get 方法，默认异步请求等。<br>如果是 get 请求，把请求参数放进 url 里面格式为 <a href="https://www.wanghaojvlao.com?wanghao=jvlao&amp;wanghao=shadiao这样" target="_blank" rel="noopener">https://www.wanghaojvlao.com?wanghao=jvlao&amp;wanghao=shadiao这样</a><br>如果是 post，转化请求体中的 date 类型为字符串类型<br>大概思路就是这样，是不是很简单～</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> http = &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * js封装ajax请求</span><span class="hljs-comment">   * &gt;&gt;使用new XMLHttpRequest 创建请求对象,所以不考虑低端IE浏览器(IE6及以下不支持XMLHttpRequest)</span><span class="hljs-comment">   * &gt;&gt;使用es6语法,如果需要在正式环境使用,则可以用babel转换为es5语法 https://babeljs.cn/docs/setup/#installation</span><span class="hljs-comment">   *  @param settings 请求参数模仿jQuery ajax</span><span class="hljs-comment">   *  调用该方法,data参数需要和请求头Content-Type对应</span><span class="hljs-comment">   *  Content-Type                        data                                     描述</span><span class="hljs-comment">   *  application/x-www-form-urlencoded   'name=哈哈&amp;age=12'或&#123;name:'哈哈',age:12&#125;  查询字符串,用&amp;分割</span><span class="hljs-comment">   *  application/json                     name=哈哈&amp;age=12'                        json字符串</span><span class="hljs-comment">   *  multipart/form-data                  new FormData()                           FormData对象,当为FormData类型,不要手动设置Content-Type</span><span class="hljs-comment">   *  注意:请求参数如果包含日期类型.是否能请求成功需要后台接口配合</span><span class="hljs-comment">   */</span>  ajax: <span class="hljs-function">(<span class="hljs-params">settings = &#123;&#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 初始化请求参数</span>    <span class="hljs-keyword">let</span> _s = <span class="hljs-built_in">Object</span>.assign(&#123;      url: <span class="hljs-string">''</span>, <span class="hljs-comment">// string</span>      <span class="hljs-keyword">type</span>: <span class="hljs-string">'GET'</span>, <span class="hljs-comment">// string 'GET' 'POST' 'DELETE'</span>      dataType: <span class="hljs-string">'json'</span>, <span class="hljs-comment">// string 期望的返回数据类型:'json' 'text' 'document' ...</span>      <span class="hljs-keyword">async</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//  boolean true:异步请求 false:同步请求 required</span>      data: <span class="hljs-literal">null</span>, <span class="hljs-comment">// any 请求参数,data需要和请求头Content-Type对应</span>      headers: &#123;&#125;, <span class="hljs-comment">// object 请求头</span>      timeout: <span class="hljs-number">1000</span>, <span class="hljs-comment">// string 超时时间:0表示不设置超时</span>      beforeSend: <span class="hljs-function">(<span class="hljs-params">xhr</span>) =&gt;</span> &#123;      &#125;,      success: <span class="hljs-function">(<span class="hljs-params">result, status, xhr</span>) =&gt;</span> &#123;      &#125;,      error: <span class="hljs-function">(<span class="hljs-params">xhr, status, error</span>) =&gt;</span> &#123;      &#125;,      complete: <span class="hljs-function">(<span class="hljs-params">xhr, status</span>) =&gt;</span> &#123;      &#125;    &#125;, settings);    <span class="hljs-comment">// 参数验证</span>    <span class="hljs-keyword">if</span> (!_s.url || !_s.type || !_s.dataType || !_s.async) &#123;      alert(<span class="hljs-string">'参数有误'</span>);      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 创建XMLHttpRequest请求对象</span>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();    <span class="hljs-comment">// 请求开始回调函数</span>    xhr.addEventListener(<span class="hljs-string">'loadstart'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      _s.beforeSend(xhr);    &#125;);    <span class="hljs-comment">// 请求成功回调函数</span>    xhr.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> status = xhr.status;      <span class="hljs-keyword">if</span> ((status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>) || status === <span class="hljs-number">304</span>) &#123;        <span class="hljs-keyword">let</span> result;        <span class="hljs-keyword">if</span> (xhr.responseType === <span class="hljs-string">'text'</span>) &#123;          result = xhr.responseText;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xhr.responseType === <span class="hljs-string">'document'</span>) &#123;          result = xhr.responseXML;        &#125; <span class="hljs-keyword">else</span> &#123;          result = xhr.response;        &#125;        <span class="hljs-comment">// 注意:状态码200表示请求发送/接受成功,不表示业务处理成功</span>        _s.success(result, status, xhr);      &#125; <span class="hljs-keyword">else</span> &#123;        _s.error(xhr, status, e);      &#125;    &#125;);    <span class="hljs-comment">// 请求结束</span>    xhr.addEventListener(<span class="hljs-string">'loadend'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      _s.complete(xhr, xhr.status);    &#125;);    <span class="hljs-comment">// 请求出错</span>    xhr.addEventListener(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      _s.error(xhr, xhr.status, e);    &#125;);    <span class="hljs-comment">// 请求超时</span>    xhr.addEventListener(<span class="hljs-string">'timeout'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;      _s.error(xhr, <span class="hljs-number">408</span>, e);    &#125;);    <span class="hljs-keyword">let</span> useUrlParam = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">let</span> sType = _s.type.toUpperCase();    <span class="hljs-comment">// 如果是"简单"请求,则把data参数组装在url上</span>    <span class="hljs-keyword">if</span> (sType === <span class="hljs-string">'GET'</span> || sType === <span class="hljs-string">'DELETE'</span>) &#123;      useUrlParam = <span class="hljs-literal">true</span>;      _s.url += http.getUrlParam(_s.url, _s.data);    &#125;    <span class="hljs-comment">// 初始化请求</span>    xhr.open(_s.type, _s.url, _s.async);    <span class="hljs-comment">// 设置期望的返回数据类型</span>    xhr.responseType = _s.dataType;    <span class="hljs-comment">// 设置请求头</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key of <span class="hljs-built_in">Object</span>.keys(_s.headers)) &#123;      xhr.setRequestHeader(key, _s.headers[key]);    &#125;    <span class="hljs-comment">// 设置超时时间</span>    <span class="hljs-keyword">if</span> (_s.async &amp;&amp; _s.timeout) &#123;      xhr.timeout = _s.timeout;    &#125;    <span class="hljs-comment">// 发送请求.如果是简单请求,请求参数应为null.否则,请求参数类型需要和请求头Content-Type对应</span>    xhr.send(useUrlParam ? <span class="hljs-literal">null</span> : http.getQueryData(_s.data));  &#125;,  <span class="hljs-comment">// 把参数data转为url查询参数</span>  getUrlParam: <span class="hljs-function">(<span class="hljs-params">url, data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!data) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;    &#125;    <span class="hljs-keyword">let</span> paramsStr = data <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? http.getQueryString(data) : data;    <span class="hljs-keyword">return</span> (url.indexOf(<span class="hljs-string">'?'</span>) !== <span class="hljs-number">-1</span>) ? paramsStr : <span class="hljs-string">'?'</span> + paramsStr;  &#125;,  <span class="hljs-comment">// 获取ajax请求参数</span>  getQueryData: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!data) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'string'</span>) &#123;      <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> FormData) &#123;      <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-keyword">return</span> http.getQueryString(data);  &#125;,  <span class="hljs-comment">// 把对象转为查询字符串</span>  getQueryString: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> paramsArr = [];    <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) &#123;      <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;        <span class="hljs-keyword">let</span> val = data[key];        <span class="hljs-comment">// todo 参数Date类型需要根据后台api酌情处理</span>        <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) &#123;          <span class="hljs-comment">// val = dateFormat(val, 'yyyy-MM-dd hh:mm:ss');</span>        &#125;        paramsArr.push(<span class="hljs-built_in">encodeURIComponent</span>(key) + <span class="hljs-string">'='</span> + <span class="hljs-built_in">encodeURIComponent</span>(val));      &#125;);    &#125;    <span class="hljs-keyword">return</span> paramsArr.join(<span class="hljs-string">'&amp;'</span>);  &#125;&#125;</code></pre><p>这时候调用的代码应该是这样的：</p><pre><code class="hljs coffeescript">http.ajax(&#123;  url: url,  type: <span class="hljs-string">'POST'</span>,  data: &#123;name: <span class="hljs-string">'哈哈'</span>, age: <span class="hljs-number">12</span>&#125;, <span class="hljs-regexp">//</span>或 data: <span class="hljs-string">'name=哈哈&amp;age=12'</span>,  headers: &#123;    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>  &#125;,  beforeSend: <span class="hljs-function"><span class="hljs-params">(xhr)</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request show loading...'</span>);  &#125;,  success: function (result, status, xhr) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request success...'</span>);  &#125;,  error: <span class="hljs-function"><span class="hljs-params">(xhr, status, error)</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request error...'</span>);  &#125;,  complete: <span class="hljs-function"><span class="hljs-params">(xhr, status)</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request hide loading...'</span>);  &#125;&#125;);</code></pre><p>可以看出来哈，还是比较麻烦的，你总不能每次请求都整真么一大堆代码吧，所以我们继续封装！</p><h3 id="进一步封装"><a href="#进一步封装" class="headerlink" title="进一步封装"></a>进一步封装</h3><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 根据实际业务情况装饰 ajax 方法</span><span class="hljs-comment">   * 如:统一异常处理,添加http请求头,请求展示loading等</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-variable">settings</span></span></span><span class="hljs-comment">   */</span>  request: <span class="hljs-function">(<span class="hljs-params">settings = &#123;&#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 统一异常处理函数</span>    <span class="hljs-keyword">let</span> errorHandle = <span class="hljs-function">(<span class="hljs-params">xhr, status</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request error...'</span>);      <span class="hljs-keyword">if</span> (status === <span class="hljs-number">401</span>) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request 没有权限...'</span>);      &#125;      <span class="hljs-keyword">if</span> (status === <span class="hljs-number">408</span>) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request timeout'</span>);      &#125;    &#125;;    <span class="hljs-comment">// 使用before拦截参数的 beforeSend 回调函数</span>    settings.beforeSend = (settings.beforeSend || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    &#125;).before(<span class="hljs-function"><span class="hljs-params">xhr</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request show loading...'</span>);    &#125;);    <span class="hljs-comment">// 保存参数success回调函数</span>    <span class="hljs-keyword">let</span> successFn = settings.success;    <span class="hljs-comment">// 覆盖参数success回调函数</span>    settings.success = <span class="hljs-function">(<span class="hljs-params">result, status, xhr</span>) =&gt;</span> &#123;      <span class="hljs-comment">// todo 根据后台api判断是否请求成功</span>      <span class="hljs-keyword">if</span> (result &amp;&amp; result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> &amp;&amp; result.code !== <span class="hljs-number">1</span>) &#123;        errorHandle(xhr, status);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request success'</span>);        successFn &amp;&amp; successFn(result, status, xhr);      &#125;    &#125;;    <span class="hljs-comment">// 拦截参数的 error</span>    settings.error = (settings.error || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    &#125;).before(<span class="hljs-function">(<span class="hljs-params">result, status, xhr</span>) =&gt;</span> &#123;      errorHandle(xhr, status);    &#125;);    <span class="hljs-comment">// 拦截参数的 complete</span>    settings.complete = (settings.complete || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    &#125;).after(<span class="hljs-function">(<span class="hljs-params">xhr, status</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request hide loading...'</span>);    &#125;);    <span class="hljs-comment">// 请求添加权限头,然后调用http.ajax方法</span>    (http.ajax.before(http.addAuthorizationHeader))(settings);  &#125;,  <span class="hljs-comment">// 添加权限请求头</span>  addAuthorizationHeader: <span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> &#123;    settings.headers = settings.headers || &#123;&#125;;    <span class="hljs-keyword">const</span> headerKey = <span class="hljs-string">'Authorization'</span>; <span class="hljs-comment">// todo 权限头名称</span>    <span class="hljs-comment">// 判断是否已经存在权限header</span>    <span class="hljs-keyword">let</span> hasAuthorization = <span class="hljs-built_in">Object</span>.keys(settings.headers).some(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> key === headerKey;    &#125;);    <span class="hljs-keyword">if</span> (!hasAuthorization) &#123;      settings.headers[headerKey] = <span class="hljs-string">'test'</span>; <span class="hljs-comment">// todo 从缓存中获取headerKey的值</span>    &#125;  &#125;&#125;;<span class="hljs-built_in">Function</span>.prototype.before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">beforeFn</span>) </span>&#123; <span class="hljs-comment">// eslint-disable-line</span>  <span class="hljs-keyword">let</span> _self = <span class="hljs-keyword">this</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    beforeFn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);    _self.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);  &#125;;&#125;;<span class="hljs-built_in">Function</span>.prototype.after = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">afterFn</span>) </span>&#123; <span class="hljs-comment">// eslint-disable-line</span>  <span class="hljs-keyword">let</span> _self = <span class="hljs-keyword">this</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    _self.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);    afterFn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);  &#125;;&#125;;</code></pre><p>好极了，这时候我们调用的代码更简洁些了，大概是这样的：</p><pre><code class="hljs javascript">http.request(&#123;  url: url,  type: <span class="hljs-string">'POST'</span>,  data: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'哈哈'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>&#125;, <span class="hljs-comment">// data: 'name=哈哈&amp;age=12',</span>  headers: &#123;    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>  &#125;,  success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, status, xhr</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'就可以操作一波啦'</span>);  &#125;&#125;);<span class="hljs-comment">//对比下刚刚的</span>http.ajax(&#123;  url: url,  type: <span class="hljs-string">'POST'</span>,  data: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'哈哈'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>&#125;, <span class="hljs-comment">//或 data: 'name=哈哈&amp;age=12',</span>  headers: &#123;    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>  &#125;,  beforeSend: <span class="hljs-function">(<span class="hljs-params">xhr</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request show loading...'</span>);  &#125;,  success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result, status, xhr</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request success...'</span>);  &#125;,  error: <span class="hljs-function">(<span class="hljs-params">xhr, status, error</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request error...'</span>);  &#125;,  complete: <span class="hljs-function">(<span class="hljs-params">xhr, status</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'request hide loading...'</span>);  &#125;&#125;);</code></pre><p>嘿嘿，不要停，让我们继续封装一下～ 😏</p><h3 id="终极封装"><a href="#终极封装" class="headerlink" title="终极封装"></a>终极封装</h3><pre><code class="hljs lasso">const http = &#123;  get: (url, <span class="hljs-built_in">data</span>, successCallback, dataType = <span class="hljs-string">'json'</span>) =&gt; &#123;    http.request(&#123;      url: url,      <span class="hljs-keyword">type</span>: <span class="hljs-string">'GET'</span>,      dataType: dataType,      <span class="hljs-built_in">data</span>: <span class="hljs-built_in">data</span>,      success: successCallback    &#125;);  &#125;,  delete: (url, <span class="hljs-built_in">data</span>, successCallback, dataType = <span class="hljs-string">'json'</span>) =&gt; &#123;    http.request(&#123;      url: url,      <span class="hljs-keyword">type</span>: <span class="hljs-string">'DELETE'</span>,      dataType: dataType,      <span class="hljs-built_in">data</span>: <span class="hljs-built_in">data</span>,      success: successCallback    &#125;);  &#125;,  <span class="hljs-comment">// 调用此方法,参数data应为查询字符串或普通对象</span>  post: (url, <span class="hljs-built_in">data</span>, successCallback, dataType = <span class="hljs-string">'json'</span>) =&gt; &#123;    http.request(&#123;      url: url,      <span class="hljs-keyword">type</span>: <span class="hljs-string">'POST'</span>,      dataType: dataType,      <span class="hljs-built_in">data</span>: <span class="hljs-built_in">data</span>,      headers: &#123;        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>      &#125;,      success: successCallback    &#125;);  &#125;,  <span class="hljs-comment">// 调用此方法,参数data应为json字符串</span>  postBody: (url, <span class="hljs-built_in">data</span>, successCallback, dataType = <span class="hljs-string">'json'</span>) =&gt; &#123;    http.request(&#123;      url: url,      <span class="hljs-keyword">type</span>: <span class="hljs-string">'POST'</span>,      dataType: dataType,      <span class="hljs-built_in">data</span>: <span class="hljs-built_in">data</span>,      headers: &#123;        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json; charset=UTF-8'</span>      &#125;,      success: successCallback    &#125;);  &#125;&#125;;</code></pre><p>此时，此时此刻，right now ！ let us see see 😂</p><pre><code class="hljs coffeescript">http.get(url + <span class="hljs-string">'?name=哈哈&amp;age=12'</span>, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-params">(result, status, xhr)</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'你随便干啥都行哈哈哈哈哈哈哈'</span>);&#125;);</code></pre><p>神似 jquery 的 $.ajax() 对不对？很开心了解了这么多东西吧～，ok 那么我们接着看下一个玩意儿～</p><h2 id="axios"><a href="#axios" class="headerlink" title="-axios"></a>-axios</h2><h3 id="axios-简介"><a href="#axios-简介" class="headerlink" title="axios 简介"></a>axios 简介</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p><strong>特性：</strong></p><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><p>那么 axios 和 ajax 的区别在哪里呢？axios 和 XMLHttpRequest 关联又在哪里呢？<br>Axios 在 NPM 上的描述是：Promise based HTTP client for the browser and node.js，是一种基于 Promise 封装的 HTTP 客户端。<br>AJAX 完整是 Asynchronous Javascript And XML . 异步 js 和 xml，是一种异步请求的技术。</p><p>啥意思？Axios 是通过 Promise 实现 XHR 封装，其中 Promise 是控制手段，XHR 是实际发送 Http 请求的客户端。就像$.ajax 是通过 callback+XHR 实现一样就像我们刚刚在上面封装的那个一个意思的，都是 AJAX 技术的一种运用。 AJAX 技术是实现网页的局部数据刷新，你可以通过 XHR、Fetch、WebSocket 等 API 实现。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>硬核一点，直接上官网代码，一目了然～</p><pre><code class="hljs scilab"><span class="hljs-comment">// get</span>axios.get(<span class="hljs-string">'/user'</span>, &#123;    params: &#123;      ID: <span class="hljs-number">12345</span>    &#125;  &#125;)  .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> &#123;</span>    console.<span class="hljs-built_in">log</span>(response);  &#125;)  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> &#123;</span>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">error</span>);  &#125;);<span class="hljs-comment">// post</span>axios.post(<span class="hljs-string">'/user'</span>, &#123;    firstName: <span class="hljs-string">'Fred'</span>,    lastName: <span class="hljs-string">'Flintstone'</span>  &#125;)  .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(response)</span> &#123;</span>    console.<span class="hljs-built_in">log</span>(response);  &#125;)  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> &#123;</span>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">error</span>);  &#125;);<span class="hljs-comment">// 并发</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserAccount</span><span class="hljs-params">()</span> &#123;</span>  <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">'/user/12345'</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserPermissions</span><span class="hljs-params">()</span> &#123;</span>  <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">'/user/12345/permissions'</span>);&#125;axios.all([getUserAccount(), getUserPermissions()])  .<span class="hljs-keyword">then</span>(axios.spread(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acct, perms)</span> &#123;</span>    <span class="hljs-comment">// 两个请求现在都执行完成</span>  &#125;));</code></pre><h3 id="axios-的请求配置"><a href="#axios-的请求配置" class="headerlink" title="axios 的请求配置"></a>axios 的请求配置</h3><p>1、可以通过 axios.defaults 设置全局默认值，在所有请求中都生效。</p><pre><code class="hljs stylus">axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.common</span>[<span class="hljs-string">"token"</span>] = <span class="hljs-string">""</span>axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.post</span>[<span class="hljs-string">"Content-type"</span>] = <span class="hljs-string">"application/json"</span>axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.baseURL</span> = <span class="hljs-string">'https://zhujun.zhenhao.com; //设置统一路径前缀</span></code></pre><p>2、也可以自定义实例的默认值，以及修改实例的配置</p><pre><code class="hljs cs"><span class="hljs-keyword">let</span> zhujun = axios.create(&#123;  baseURL: <span class="hljs-string">'http://zhujun.zhenbang.com'</span>,  <span class="hljs-keyword">params</span>: &#123; name: <span class="hljs-string">'朱军'</span> &#125;&#125;);<span class="hljs-comment">// 修改配置后，超时设置为4秒</span>zhujun.defaults.timeout = <span class="hljs-number">4000</span>;</code></pre><p>3、也可以在每个请求中设置相关的配置。</p><pre><code class="hljs less"><span class="hljs-selector-tag">axios</span>(<span class="hljs-string">'/app/mock/zhujun'</span>, &#123;  <span class="hljs-attribute">params</span>: &#123;    <span class="hljs-attribute">name</span>: <span class="hljs-string">'朱军'</span>  &#125;,  <span class="hljs-attribute">baseURL</span>: <span class="hljs-string">'http://zhujun.zhenshuai.com'</span>&#125;)</code></pre><pre><code class="hljs actionscript">&#123;   <span class="hljs-comment">// `url` 是用于请求的服务器 URL</span>  url: <span class="hljs-string">'/user'</span>,  <span class="hljs-comment">// `method` 是创建请求时使用的方法</span>  method: <span class="hljs-string">'get'</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>  <span class="hljs-comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>  baseURL: <span class="hljs-string">'https://some-domain.com/api/'</span>,  <span class="hljs-comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span>  <span class="hljs-comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span>  <span class="hljs-comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span>  transformRequest: [<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, headers)</span> </span>&#123;    <span class="hljs-comment">// 对 data 进行任意转换处理</span>    <span class="hljs-keyword">return</span> data;  &#125;],  <span class="hljs-comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>  transformResponse: [<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> </span>&#123;    <span class="hljs-comment">// 对 data 进行任意转换处理</span>    <span class="hljs-keyword">return</span> data;  &#125;],  <span class="hljs-comment">// `headers` 是即将被发送的自定义请求头</span>  headers: &#123;<span class="hljs-string">'X-Requested-With'</span>: <span class="hljs-string">'XMLHttpRequest'</span>&#125;,  <span class="hljs-comment">// `params` 是即将与请求一起发送的 URL 参数</span>  <span class="hljs-comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span>  params: &#123;    ID: <span class="hljs-number">12345</span>  &#125;,   <span class="hljs-comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span>  <span class="hljs-comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>  paramsSerializer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(params)</span> </span>&#123;    <span class="hljs-keyword">return</span> Qs.stringify(params, &#123;arrayFormat: <span class="hljs-string">'brackets'</span>&#125;)  &#125;,  <span class="hljs-comment">// `data` 是作为请求主体被发送的数据</span>  <span class="hljs-comment">// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span>  <span class="hljs-comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span>  <span class="hljs-comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>  <span class="hljs-comment">// - 浏览器专属：FormData, File, Blob</span>  <span class="hljs-comment">// - Node 专属： Stream</span>  data: &#123;    firstName: <span class="hljs-string">'Fred'</span>  &#125;,  <span class="hljs-comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span>  <span class="hljs-comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span>  timeout: <span class="hljs-number">1000</span>,   <span class="hljs-comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span>  withCredentials: <span class="hljs-literal">false</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span>  <span class="hljs-comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span>  adapter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(config)</span> </span>&#123;    <span class="hljs-comment">/* ... */</span>  &#125;, <span class="hljs-comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span>  <span class="hljs-comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span>  auth: &#123;    username: <span class="hljs-string">'janedoe'</span>,    password: <span class="hljs-string">'s00pers3cret'</span>  &#125;,   <span class="hljs-comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span>  responseType: <span class="hljs-string">'json'</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `responseEncoding` indicates encoding to use for decoding responses</span>  <span class="hljs-comment">// Note: Ignored for `responseType` of 'stream' or client-side requests</span>  responseEncoding: <span class="hljs-string">'utf8'</span>, <span class="hljs-comment">// default</span>   <span class="hljs-comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span>  xsrfCookieName: <span class="hljs-string">'XSRF-TOKEN'</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span>  xsrfHeaderName: <span class="hljs-string">'X-XSRF-TOKEN'</span>, <span class="hljs-comment">// default</span>   <span class="hljs-comment">// `onUploadProgress` 允许为上传处理进度事件</span>  onUploadProgress: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(progressEvent)</span> </span>&#123;    <span class="hljs-comment">// Do whatever you want with the native progress event</span>  &#125;,  <span class="hljs-comment">// `onDownloadProgress` 允许为下载处理进度事件</span>  onDownloadProgress: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(progressEvent)</span> </span>&#123;    <span class="hljs-comment">// 对原生进度事件的处理</span>  &#125;,   <span class="hljs-comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span>  maxContentLength: <span class="hljs-number">2000</span>,  <span class="hljs-comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span>  validateStatus: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(status)</span> </span>&#123;    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-comment">// default</span>  &#125;,  <span class="hljs-comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span>  <span class="hljs-comment">// 如果设置为0，将不会 follow 任何重定向</span>  maxRedirects: <span class="hljs-number">5</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span>  <span class="hljs-comment">// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span>  <span class="hljs-comment">// Only either `socketPath` or `proxy` can be specified.</span>  <span class="hljs-comment">// If both are specified, `socketPath` is used.</span>  socketPath: <span class="hljs-literal">null</span>, <span class="hljs-comment">// default</span>  <span class="hljs-comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span>  <span class="hljs-comment">// `keepAlive` 默认没有启用</span>  httpAgent: <span class="hljs-keyword">new</span> http.Agent(&#123; keepAlive: <span class="hljs-literal">true</span> &#125;),  httpsAgent: <span class="hljs-keyword">new</span> https.Agent(&#123; keepAlive: <span class="hljs-literal">true</span> &#125;),  <span class="hljs-comment">// 'proxy' 定义代理服务器的主机名称和端口</span>  <span class="hljs-comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span>  <span class="hljs-comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span>  proxy: &#123;    host: <span class="hljs-string">'127.0.0.1'</span>,    port: <span class="hljs-number">9000</span>,    auth: &#123;      username: <span class="hljs-string">'mikeymike'</span>,      password: <span class="hljs-string">'rapunz3l'</span>    &#125;  &#125;,  <span class="hljs-comment">// `cancelToken` 指定用于取消请求的 cancel token</span>  <span class="hljs-comment">// （查看后面的 Cancellation 这节了解更多）</span>  cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cancel)</span> </span>&#123;  &#125;)&#125;</code></pre><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>可以分别设置请求拦截和响应拦截，在发出请求和响应到达 then 之前进行判断处理。</p><pre><code class="hljs typescript">axios.interceptors.response.use(  res =&gt; &#123;    <span class="hljs-keyword">if</span> (res) &#123;      <span class="hljs-keyword">return</span> res;    &#125;  &#125;,  err =&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);  &#125;);</code></pre><p>把上面的 response 换成 request 就是请求发出前的拦截器～<br>拦截器是可以移除的，在特殊的情况下，会用到移除拦截器。（我其实也不知道啥情况需要如此莫名其妙的操作）</p><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> clearInterceptors = axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125;);axios.interceptors.request.eject(clearInterceptors);<span class="hljs-comment">// 移除拦截器，和移除js定时器一样。</span></code></pre><h3 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h3><pre><code class="hljs less"><span class="hljs-attribute">proxy</span>: &#123;  <span class="hljs-string">'/api'</span>: &#123;    <span class="hljs-attribute">target</span>: <span class="hljs-string">'https://www.xxx.com'</span>, <span class="hljs-comment">//目标路径，别忘了加http和端口号</span>    <span class="hljs-attribute">changeOrigin</span>: true, <span class="hljs-comment">//是否跨域</span>    <span class="hljs-attribute">ws</span>: true,    <span class="hljs-attribute">pathRewrite</span>: &#123;      <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span> <span class="hljs-comment">//重写路径</span>    &#125;  &#125;&#125;</code></pre><h3 id="EXTRA"><a href="#EXTRA" class="headerlink" title="EXTRA"></a>EXTRA</h3><p>整点额外的惊喜，硬核起来上代码！</p><pre><code class="hljs php">import axios from <span class="hljs-string">'axios'</span>;import &#123; getLocale &#125; from <span class="hljs-string">'umi-plugin-react/locale'</span>;import &#123; getToken &#125; from <span class="hljs-string">'../token'</span>;<span class="hljs-comment">// Add a request interceptor 这是加个拦截器，在 request 发出请求之前，可以做一些操作的～</span>axios.interceptors.request.<span class="hljs-keyword">use</span>(<span class="hljs-title">function</span>(<span class="hljs-title">config</span>) &#123;// <span class="hljs-title">Do</span> <span class="hljs-title">something</span> <span class="hljs-title">before</span> <span class="hljs-title">request</span> <span class="hljs-title">is</span> <span class="hljs-title">sent</span><span class="hljs-title">return</span> <span class="hljs-title">config</span>;&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>&#123;<span class="hljs-comment">// Do something with request error</span><span class="hljs-keyword">return</span> Promise.reject(error);&#125;);<span class="hljs-comment">// Add a response interceptor 这也是个拦截，在响应到达 then 之前也可以操作一波，这里做了个如果请求失败，自动重新请求的操作</span>axios.interceptors.response.<span class="hljs-keyword">use</span>(<span class="hljs-title">function</span>(<span class="hljs-title">response</span>) &#123;// <span class="hljs-title">Do</span> <span class="hljs-title">something</span> <span class="hljs-title">with</span> <span class="hljs-title">response</span> <span class="hljs-title">data</span><span class="hljs-title">return</span> <span class="hljs-title">response</span>;&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>&#123;<span class="hljs-comment">// Do something with response error</span><span class="hljs-keyword">const</span> &#123; config, response &#125; = error;<span class="hljs-keyword">if</span> (config) &#123;<span class="hljs-keyword">if</span> (config.retry &amp;&amp;[<span class="hljs-string">'get'</span>, <span class="hljs-string">'put'</span>, <span class="hljs-string">'delete'</span>].includes(config.method) &amp;&amp;(!response || (response.status &gt;= <span class="hljs-number">500</span> &amp;&amp; response.status &lt;= <span class="hljs-number">599</span>))) &#123;<span class="hljs-keyword">const</span> &#123; headers &#125; = config;<span class="hljs-keyword">const</span> retryCountHeaderKey = <span class="hljs-string">'X-Retry-Count'</span>;<span class="hljs-keyword">const</span> retryCountHeaderValue = parseInt(headers[retryCountHeaderKey] || <span class="hljs-string">'0'</span>, <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (retryCountHeaderValue &lt;= <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">// 如果失败，自动请求 3 次</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(resolve =&gt; &#123;setTimeout(() =&gt;resolve(axios(&#123;...config,headers: &#123;...headers,[retryCountHeaderKey]: `$&#123;retryCountHeaderValue&#125;`,&#125;,&#125;)),<span class="hljs-number">1000</span> \* retryCountHeaderValue);&#125;);&#125;&#125; <span class="hljs-comment">// 重发“安全请求”</span>&#125;<span class="hljs-keyword">return</span> Promise.reject(error);&#125;);/\*\*- request 方法，axios 的简单封装  \*/  export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span><span class="hljs-params">(url, config = &#123;&#125;)</span> </span>&#123;  axios.defaults.headers.common.Authorization = getToken(); <span class="hljs-comment">// 获取 token</span>  axios.defaults.headers.common[<span class="hljs-string">'Accept-Language'</span>] = `$&#123;getLocale()&#125;;q=<span class="hljs-number">0.9</span>`; <span class="hljs-comment">// 国际化“Accept-Language:zh-CN,zh;q=0.9” =&gt; zh-CN 或 en-US</span><span class="hljs-keyword">const</span> &#123;method = <span class="hljs-string">'get'</span>,responseType,body = &#123;&#125;,headers = &#123;&#125;,cache = <span class="hljs-keyword">false</span>,download = <span class="hljs-keyword">false</span>,retry = <span class="hljs-keyword">true</span>, <span class="hljs-comment">// eslint-disable-line</span>...rest&#125; = config;<span class="hljs-keyword">const</span> newBody = /(put|post|patch)/i.test(method) ? &#123; data: body &#125; : &#123; params: body &#125;; <span class="hljs-comment">// data 参数，在以下“请求类型”中可用：put, post, patch</span><span class="hljs-keyword">const</span> newResponseType = responseType || (download ? <span class="hljs-string">'arraybuffer'</span> : <span class="hljs-string">'json'</span>);<span class="hljs-keyword">return</span> axios.request(&#123;url, <span class="hljs-comment">// URL 地址</span>method, <span class="hljs-comment">// 请求类型，get, post, put, delete...</span>responseType: newResponseType, <span class="hljs-comment">// 响应数据类型</span>      headers: &#123;        ...headers,        ...(cache          ? &#123; <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'public, max-age=86400'</span> &#125;          : &#123; <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'no-cache, no-store, must-revalidate'</span>, Pragma: <span class="hljs-string">'no-cache'</span> &#125;),      &#125;,      ...newBody, <span class="hljs-comment">// 请求参数</span>      ...rest, <span class="hljs-comment">// 剩余参数</span>    &#125;)    .then(response =&gt; (&#123;      success: <span class="hljs-keyword">true</span>,      response,    &#125;))    .<span class="hljs-keyword">catch</span>(error =&gt; &#123;      <span class="hljs-keyword">const</span> &#123; response &#125; = error;      <span class="hljs-keyword">const</span> &#123; status &#125; = response;      <span class="hljs-keyword">const</span> errorName = `Error$&#123;status&#125; - $&#123;response.config.url&#125;`;      <span class="hljs-keyword">const</span> errorMessage = response.statusText;      console.log(errorName);      console.log(errorMessage);<span class="hljs-comment">// 如果不是登陆页，但是状态码 401 那么跳转页面到登陆页</span><span class="hljs-keyword">if</span> (window.location.href.indexOf(<span class="hljs-string">'login'</span>) === <span class="hljs-number">-1</span> &amp;&amp; status === <span class="hljs-number">401</span>) &#123;window.location.href = `/g/login?redirect=$&#123; window.location.href.split(window.location.host)[<span class="hljs-number">1</span>] &#125;`;&#125;      <span class="hljs-keyword">return</span> &#123;        success: <span class="hljs-keyword">false</span>,        response: &#123; ...response, data: response.data || &#123; message: <span class="hljs-string">'504 Gateway Timeout'</span> &#125; &#125;,      &#125;;    &#125;);&#125;```<span class="hljs-comment">#### 在项目中的用法</span>```         onClick=&#123;() =&gt; &#123;              this.setState(&#123;                spinning: <span class="hljs-keyword">true</span>,              &#125;);              request(`/server/api/declarationfiles/$&#123;record.id&#125;`, &#123;                method: <span class="hljs-string">'get'</span>,                download: <span class="hljs-keyword">true</span>,                onDownloadProgress: e =&gt; &#123;                  <span class="hljs-keyword">if</span> (e.loaded / e.total === <span class="hljs-number">1</span>) &#123;                    this.setState(&#123;                      spinning: <span class="hljs-keyword">false</span>,                    &#125;);                  &#125;                &#125;,              &#125;).then(wrappedResponse =&gt; &#123;                <span class="hljs-keyword">const</span> &#123; response &#125; = wrappedResponse;                download(record.fileName, response.data);              &#125;);            &#125;&#125;                <span class="hljs-comment">//  直接在页面里写请求，适用于调用次数少，独立专属于某个页面使用的情况。比如文件下载等</span>```---```\*retrieveRules(&#123; payload &#125;, &#123; call, put, select &#125;) &#123;<span class="hljs-keyword">const</span> newRules = <span class="hljs-keyword">yield</span> select(models =&gt; &#123;<span class="hljs-keyword">const</span> &#123; pagination, searcher &#125; = models[<span class="hljs-keyword">namespace</span>];<span class="hljs-keyword">return</span> &#123;pagination,searcher,...payload,&#125;;&#125;);<span class="hljs-keyword">const</span> &#123; pagination, searcher &#125; = newRules;<span class="hljs-keyword">const</span> wrappedResponse = <span class="hljs-keyword">yield</span> call(request, `/server/api/projectwarningrules`, &#123;method: <span class="hljs-string">'get'</span>,body: &#123;...pagination,...searcher,&#125;,&#125;);&#125;               <span class="hljs-comment">// 写在model 层的effect里面，适用于调用次数多， 比如请求列表数据，增删改查操作后需要再次调用请求数据</span>``````</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XMLHttpRequest request axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议</title>
    <link href="/2020/06/24/network-protocol/"/>
    <url>/2020/06/24/network-protocol/</url>
    
    <content type="html"><![CDATA[<h3 id="五层协议体系结构-物理层、数据链路层、网络层、运输层、应用层"><a href="#五层协议体系结构-物理层、数据链路层、网络层、运输层、应用层" class="headerlink" title="五层协议体系结构:物理层、数据链路层、网络层、运输层、应用层."></a>五层协议体系结构:物理层、数据链路层、网络层、运输层、应用层.</h3><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>物理层的主要任务是确定与传输媒体接口的特性.如机械特性、电气特性、功能特性、过程特性.</li><li>中继器：又叫转发器，功能是将信号整形放大再转发出去，以消除信号的失真和衰减，扩大网络传输的距离，其原理是信号再生，仅作用于电气部分，不管数据中是否有错误</li><li>集线器(HUB):实质上是多端口的中继器，也工作在物理层。一口接受数据信号，将其整形放大转发到其他所有(输入端除外)处于工作状态的端口上，多口输入，冲突-&gt;无效</li><li>码元:在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形.</li><li>几种通信:单工通信、半双工通信(双方交替)、全双工通信</li><li>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。</li><li>奈氏准则:在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能.</li><li>信道的极限信息传输速率 C : C = W log2(1+S/N) b/s ; W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。 ·</li><li>导引型传播媒体:双绞线(屏蔽、无屏蔽)、同轴电缆、光缆(单模光纤、双模光纤)、非导引型传输媒体:无线传输介质:无线电波、微波、红外线、激光.</li><li>频分复用:所有用户在同样的时间占用频率不同的带宽资源.</li><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙</li><li>波分复用：光的频分复用</li><li>码分复用:各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现</li><li>宽带接入技术:ADSL、HFC、FTTx</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li>数据链路层使用的信道:点对点信道 ppp 协议和广播信道.</li><li>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</li><li>一条链路只是一条通路的一个组成部分。数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li><li>数据链路的基本单位是帧.</li><li>数据链路层解决的三个问题是封装成帧、透明传输、差错控制</li><li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li><li>透明传输:原始数据中出现控制符如何转义.0 比特填充.</li><li>循环冗余检验 CRC:现在 k = 6, M = 101001。设 n = 3, 除数 P = 1101，被除数是 2nM = 101001000。 模 2 运算的结果是：商 Q = 110101，余数 R = 001。把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R 即：101001001，共 (k + n) 位。<br>在数据后面添加上的冗余码称为帧检验序列 FCS . CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法</li><li>CRC 不能实现可靠传输,需要确认和重传机制.</li><li>0 比特填充:连续五个 1 之后加入一个 0.</li><li>数据链路层的两个子层:逻辑链路控制 LLC (Logical Link Control)子层</li><li>媒体接入控制 MAC (Medium Access Control)子层.</li><li>通信适配器,也就是网卡,作用是:进行串行/并行转换。对数据进行缓存。在计算机的操作系统安装设备驱动程序。实现以太网协议。</li><li>CSMA/CD 协议: Carrier Sense Multiple Access with Collision Detection.“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。只能实现半双工通信.</li><li>退避算法:发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</li><li>在局域网中，硬件地址又称为物理地址，或 MAC 地址。</li><li>集线器的优缺点:使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信,扩大了局域网覆盖的地理范围.缺点是碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li><li>网桥:在数据链路层扩展局域网.根据 MAC 帧的目的地址对收到的帧进行转发.具有过滤帧的功能<br>网桥的优缺点: 过滤通信量。 扩大了物理范围。提高了可靠性。可互连不同物理层、不同 MAC 子层和不同速率（如 10 Mb/s 和 100 Mb/s 以太网）的局域网。缺点:存储转发增加了时延。 在 MAC 子层并没有流量控制功能。 具有不同 MAC 子层的网段桥接在一起时时延更大。网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</li><li>网桥和集线器的不同:集线器转发时不进行检查,而网桥会进行 CSMA/CD 算法.</li><li>透明网桥:“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。<br>在网桥的转发表中写入的信息除了地址和接口外，还有帧进入该网桥的时间。<br>避免产生转发的帧在网络中不断地兜圈子的方法是生成树.</li><li>以太网交换机:以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。<br>虚拟局域网:虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。<br>IP 协议.地址解析协议 ARP.(IP 地址-&gt;物理地址)逆地址解析协议 RARP.网际控制报文协议 ICMP.网际组管理协议 IGMP 都是网络层的协议,TCP、UDP 是运输层的协议.</li><li>中间设备又称为中间系统或中继(relay)系统。物理层中继系统：转发器(repeater)。数据链路层中继系统：网桥或桥接器(bridge)。网络层中继系统：路由器(router)。网桥和路由器的混合物：桥路器(brouter)。网络层以上的中继系统：网关(gateway)。</li><li>四类 IP 地址:A 类 0 开头网络号 8 位,主机号 24 位.B 类 10 开头网络号 16 位.C 类 110 开头网络号 24 位.D 类 1110 开头,多播地址.E 类 1111 开头,保留地址.</li><li>IP 分网络号和主机号:第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li><li>ARP:每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</li><li>ICMP:ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告.有两种报文种类:即 ICMP 差错报告报文和 ICMP 询问报文.Ping 和 Traceroute 指令通过 ICMP 协议,不经过 TCP 或者 UDP.</li><li>路由选择协议:内部网关协议 IGP( RIP 和 OSPF)和外部网关协议 EGP( BGP-4)</li><li>RIP:是一种分布式的基于距离向量的路由选择协议,每一个路由器都要维护从它自己到其他每一个目的网络的距离记录.RIP 允许一条路径最多只能包含 15 个路由器.</li><li>RIP 协议三个要点:仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li><li>RIP 的优缺点:优点:实现简单开销小,缺点是故障传输慢、网络规模小.</li><li>OSPF 协议:是分布式的链路状态协议.OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF 的三个要点:向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。<br>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。减少了整个网络上的通信量。<br>OSPF 的五种分组类型:问候、数据库描述、链路状态请求、链路状态更新、链路状态确认.<br>MTU(路径最大传输单元)</li><li>CIDR:无类别域间路由.缓解了地址枯竭的趋势；控制甚至缩减了路由表的开销<br>分配 IP 地址的时候不再以类别来分，而是按照可变长的地址块来分配.基于可变长子网掩码 VLSM.</li><li>拥塞控制:流量感知路由、准入控制、流量调节、负载丢弃、随机早期检测 RED.</li><li>流量整形:漏桶、令牌桶.</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul><li>应用进程之间的通信又称为端到端的通信。 运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。IP 协议提供主机之间的逻辑通信,而 TCP/UDP 提供进程之间的逻辑通信.</li><li>用户数据报协议 UDP 和 传输控制协议 TCP ,TCP 要提供可靠的、面向连接的运输服务.</li><li>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU .</li><li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能,不保证可靠交付，同时也不使用拥塞控制</li><li>TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供全双工通信。面向字节流。</li><li>TCP 连接的端点叫做套接字(socket)或插口。</li><li>ARQ:使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest), ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</li><li>连续 ARQ 和回退 NARQ.</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>DNS:同时使用 TCP 和 UDP:53<br>FTP:TCP:21<br>NFS:UDP<br>TFTP:UDP<br>TELNET:TCP:23<br>RPC:TCP<br>HTTP:TCP:80<br>SMTP:TCP:25,发邮件<br>POP3:TCP:110<br>IMAP:TCP<br>MIME:MIME 类型是一种通知客户端其接收文件的多样性的机制:<br>DHCP:UDP<br>SNMP:UDP<br>POP3 和 IMAP 的区别:POP3 协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的 3 封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。而 IMAP 提供 webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</p>]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试相关</title>
    <link href="/2020/06/23/phone-interview/"/>
    <url>/2020/06/23/phone-interview/</url>
    
    <content type="html"><![CDATA[<p><a href="https://vevlins.github.io/2018/03/14/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">别人的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电话面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域</title>
    <link href="/2020/06/23/scope/"/>
    <url>/2020/06/23/scope/</url>
    
    <content type="html"><![CDATA[<h2 id="作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。"><a href="#作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。" class="headerlink" title="作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。"></a>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</h2><h3 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a>1. 全局作用域</h3><p>任何地方都能访问到的对象拥有全局作用域。<br>1.1 函数外面定义的变量拥有全局作用域<br>1.2 未定义直接赋值的变量自动声明为拥有全局作用域<br>1.3.window 对象的属性拥有全局作用</p><h3 id="2-局部作用域"><a href="#2-局部作用域" class="headerlink" title="2. 局部作用域"></a>2. 局部作用域</h3><p>函数内部的作用域为局部作用域</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。</p><p>1.当执行函数时，总是先从函数内部找寻局部变量</p><p>2.如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上</p><hr><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> bb = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">(bb)</span><span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">  bb = 2 ;</span></span><span class="hljs-function"><span class="hljs-comment">  alert(bb)</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">(bb)</span>;</span>alert(bb)<span class="hljs-comment">//  2,1</span><span class="hljs-keyword">var</span> bb = <span class="hljs-number">1</span> ;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">  alert(bb)</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-comment">// undefined</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>作用域 作用域链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到页面渲染</title>
    <link href="/2020/06/18/hardcore-process/"/>
    <url>/2020/06/18/hardcore-process/</url>
    
    <content type="html"><![CDATA[<p>前言：不知道这玩意儿，前端也能干活。但是得进步啊。当学会了这玩意儿，对网络的理解会举头望明月，更上一层楼。<br>反正百利而无一害。嘿嘿，开始整活～</p><p>第一步，手放在键盘上敲出 url，然后回车，咔哒一敲！然后页面就出来了，是不是很简单～ 😁<br>让我们的学习气氛轻松起来～ 下面正式开始，我敲个 url：</p><p><a href="https://onepunchx.github.io/archives/" target="_blank" rel="noopener">https://onepunchx.github.io/archives/</a></p><h2 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h2><p>输入完这个网址，敲回车！浏览器做的第一件事是 解析这个 url：</p><ol><li><strong>通过 <em>DNS_（domain name system） 把域名（domain name）解析程 _IP</em> 地址</strong></li></ol><p>IP 地址这玩意儿，就相当于我们每个人的身份证号码，身份证号可以唯一、精准的匹配到一个人，那么 IP 地址就可以唯一、精准的匹配到对应的计算机。<br>但是身份证号码这玩意，你能记住几个？能记住自己的就不错了，通常你记住的都是别人的名字，那么这个域名/网址/URL 就相当于计算机的名字<br>形象一点的对应关系如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><ol start="2"><li><strong>然后应用曾生成 HTTP 请求报文</strong><br>啥是请求报文？<br>请求报文 有起始行 首部 和 主体部分，说起来太不形象具体了，直接上代码！</li></ol><p>GET <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> HTTP/1.1 （起始行）</p><p>Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>Connection: keep-alive<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8<br>X-Client-Data: CKm1yQEIhbbJAQijtskBCMG2yQEIqZ3KAQioo8oB<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8<br>（首部）</p><p>然后是主体内容，get 请求的主体内容为空，post 的请求主体内容就是请求体，body 里面的内容</p><p>这个 http 请求报文说起来里面学问很大，有机会的话单独写一次。这里给自己先挖个坑。。。</p><ol start="3"><li><p><strong>传输层建立 TCP 连接</strong><br>3 次握手，4 次挥手。<br>这里不细说，等待后续填坑</p></li><li><p><strong>网络层使用 IP 协议来选择路线</strong><br>处理来自传输层的数据段 segment，将数据段 segment 装入数据包 packet，填充包头，主要就是添加源和目的 IP 地址，然后发送数据。在数据传输的过程中，IP 协议负责选择传送的路线，称为路由功能</p></li><li><p><strong>数据链路层实现网络相邻结点间可靠的数据通信</strong><br>　　为了保证数据的可靠传输，把数据包 packet 封装成帧(Frame)，并按顺序传送各帧。由于物理线路的不可靠，发出的数据帧有可能在线路上出错或丢失，于是为每个数据分块计算出 CRC(循环冗余检验)，并把 CRC 添加到帧中，这样接收方就可以通过重新计算 CRC 来判断数据接收的正确性。一旦出错就重传</p></li></ol><p>将数据包 packet 封装成帧(Frame)，包括帧头和帧尾。帧尾是添加被称做 CRC 的循环冗余校验部分。帧头主要是添加数据链路层的地址，即数据链路层的源地址和目的地址，即网络相邻结点间的源 MAC 地址和目的 MAC 地址</p><ol start="6"><li><p><strong>数据链路层的帧(Frame)转换成二进制形式的比特(Bit)流，从网卡发送出去，再把比特转换成电子、光学或微波信号在网络中传输</strong><br>光纤，电缆啥的这时候就派上用场啦</p></li><li><p><strong>服务器处理</strong><br>通俗来说，就是先弄清楚浏览器需要什么，然后找到相关数据，然后封装这些数据，然后准备传回去。打个比方，如果我们输入了百度的网址<br><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>那么这里服务器就会把百度的首页的 html 给浏览器传过去</p></li><li><p><strong>服务器处理完事，给浏览器传回去，跟传过来的时候差不多</strong></p></li><li><p><strong>浏览器渲染</strong><br>这时候你的电脑就接收到了服务器传过来的数据，然后经过处理，准备渲染，这个过程里呢就是遇见了 html 里面需要啥，就发请求获取啥。<br>比如说<br>浏览器开始载入 html 代码，发现<head>标签内有一个<link>标签引用外部 CSS 文件<br>浏览器又发出 CSS 文件的请求，服务器返回这个 CSS 文件<br>浏览器继续载入 html 中<body>部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了<br>浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。<br>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。<br>浏览器发现了一个包含一行 Javascript 代码的 script 标签，赶快运行它。<br>Javascript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 style（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。<br>就这样，浏览器吭呲瘪肚的终于把页面鼓捣出来了！</p></li></ol><p>这就是整个过程啦，大概就是这么回事～</p><p><strong>页面渲染需要做这些事</strong></p><ul><li>解析 html，创建 dom 树</li><li>解析 css ， 给页面美容</li><li>解析 js ，给页面交互响应</li></ul><h3 id="ext-重绘和回流"><a href="#ext-重绘和回流" class="headerlink" title="ext 重绘和回流"></a>ext 重绘和回流</h3><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><p>回流是指窗口尺寸被修改、发生滚动操作，或者元素位置相关属性被更新时会触发布局过程，在布局过程中要计算所有元素的位置信息。<br>（尺寸长宽高改变，显隐就会回流啦）<br>由于 HTML 使用的是流式布局，如果页面中的一个元素的尺寸发生了变化，则其后续的元素位置都要跟着发生变化，也就是重新进行流式布局的过程，所以被称之为回流</p><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>重绘是指当与视觉相关的样式属性值被更新时会触发绘制过程，在绘制过程中要重新计算元素的视觉信息，使元素呈现新的外观<br>当一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。</p><p>回流一定重绘，重绘不一定回流。<br>只有颜色改变的时候就只会发生重绘而不会引起回流<br>当页面布局和几何属性改变时就需要回流<br>比如：添加或者删除可见的 DOM 元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</p><p>下面列举一些减少回流次数的方法（来自百度）</p><p>（1）不要一条一条地修改 DOM 样式，而是修改 className 或者修改 style.cssText</p><p>（2）在内存中多次操作节点，完成后再添加到文档中去</p><p>（3）对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示</p><p>（4）在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中</p><p>（5）不要使用 table 布局，因为一个小改动可能会造成整个 table 重新布局。而且 table 渲染通常要 3 倍于同等元素时间</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>DNS 解析 URL 地址</li><li>生成 HTTP 请求报文</li><li>构建 TCP 连接</li><li>使用 IP 协议选择传输路线</li><li>数据链路层保证数据的可靠传输</li><li>物理层将数据转换成电子、光学或微波信号进行传输</li><li>服务器处理数据，并返回浏览器所需资源</li><li>浏览器处理数据</li><li>页面渲染</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http tcp 重绘回流 DNS IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 合成事件</title>
    <link href="/2020/06/17/react-syntheticevent/"/>
    <url>/2020/06/17/react-syntheticevent/</url>
    
    <content type="html"><![CDATA[<p>这个不是很重要，而且想真弄懂，得看源码。我看的是一头雾水。但是大概思路可以表达出来</p><h3 id="React-合成事件一套机制：React-并不是将-click-事件直接绑定在-dom-上面，而是采用事件冒泡的形式冒泡到-document-上面，当事件发生并冒泡至-document-处时，React-将事件内容封装交给中间层-SyntheticEvent（负责所有事件合成），然后-React-将事件封装给正式的函数处理运行和处理。"><a href="#React-合成事件一套机制：React-并不是将-click-事件直接绑定在-dom-上面，而是采用事件冒泡的形式冒泡到-document-上面，当事件发生并冒泡至-document-处时，React-将事件内容封装交给中间层-SyntheticEvent（负责所有事件合成），然后-React-将事件封装给正式的函数处理运行和处理。" class="headerlink" title="React 合成事件一套机制：React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SyntheticEvent（负责所有事件合成），然后 React 将事件封装给正式的函数处理运行和处理。"></a>React 合成事件一套机制：React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SyntheticEvent（负责所有事件合成），然后 React 将事件封装给正式的函数处理运行和处理。</h3><p>为啥有这种 react 合成事件 这种东西？ 存在即合理。<br>如果 dom 上绑定了特别多的事件处理函数，那指定会卡。为了不会卡，所以有了这个 react 合成事件，并且对浏览器兼容性，不用担心 ie 的坑了。</p><h3 id="注意：React-事件和原生事件最好不要混用。原生事件中如果执行了-stopPropagation-方法，则会导致其他-React-事件失效。因为所有元素的事件将无法冒泡到-document-上，导致所有的-React-事件都将无法被触发。"><a href="#注意：React-事件和原生事件最好不要混用。原生事件中如果执行了-stopPropagation-方法，则会导致其他-React-事件失效。因为所有元素的事件将无法冒泡到-document-上，导致所有的-React-事件都将无法被触发。" class="headerlink" title="注意：React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。"></a>注意：React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。</h3><p>下面留个链接，是大佬分析源码的东西。<br><a href="https://zhuanlan.zhihu.com/p/25883536" target="_blank" rel="noopener">点击跳转</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react合成事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>event.stopPropagation()和event.preventDefault()</title>
    <link href="/2020/06/17/stoppropagation-preventDefault/"/>
    <url>/2020/06/17/stoppropagation-preventDefault/</url>
    
    <content type="html"><![CDATA[<h3 id="硬核整活。就-3-个玩意儿："><a href="#硬核整活。就-3-个玩意儿：" class="headerlink" title="硬核整活。就 3 个玩意儿："></a>硬核整活。就 3 个玩意儿：</h3><ol><li><p>event.stopPropagation() 阻止冒泡</p></li><li><p>event.preventDefault() 阻止默认事件</p></li><li><p>return false 同时阻止冒泡和默认事件</p></li></ol><h3 id="阻止事件冒泡，能咋滴？"><a href="#阻止事件冒泡，能咋滴？" class="headerlink" title="阻止事件冒泡，能咋滴？"></a>阻止事件冒泡，能咋滴？</h3><p>el.addEventListener(”click“,function(){console.log(‘xxx’)},false) 接受第二个参数是个回调函数吧？函数里有操作吧，有干活吧？<br>这个阻止冒泡，就阻止这个回调函数干活。说的是冒泡奥，捕获不阻止的奥。</p><h3 id="阻止默认事件，能咋滴？"><a href="#阻止默认事件，能咋滴？" class="headerlink" title="阻止默认事件，能咋滴？"></a>阻止默认事件，能咋滴？</h3><p>首先你得知道啥是默认事件，你知不知道？<br>不知道我告诉你呗，反正也是我百度的。职业复制粘贴工程师，给你复制一下：<br>就是浏览器通过 HTML 标签或 DOM 元素提供的一些功能性的默认行为。<br>比如在 a 标签 href 属性上的跳转，右键呼出的菜单，当你在一个 form 表单里点击提交按钮时网页会产生提交行为并刷新网页，当你网页上滚动鼠标滚轮时，网页的滚动条会动。<br>阻止默认事件就能阻止类似这些事</p><h3 id="同时阻止，能咋滴？"><a href="#同时阻止，能咋滴？" class="headerlink" title="同时阻止，能咋滴？"></a>同时阻止，能咋滴？</h3><p>不能咋滴，你 return false 🐂🍺</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就这两行玩意，不总结了奥。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阻止事件冒泡 阻止默认事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dom0-dom2</title>
    <link href="/2020/06/15/dom0-dom2/"/>
    <url>/2020/06/15/dom0-dom2/</url>
    
    <content type="html"><![CDATA[<h2 id="dom0"><a href="#dom0" class="headerlink" title="dom0"></a>dom0</h2><p>或者叫 0 级 dom ，如下</p><pre><code class="hljs scilab">&lt;input id=<span class="hljs-string">"btn"</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> onclick=<span class="hljs-string">"console.log('</span>You clicked the button!<span class="hljs-string">');"</span> value=<span class="hljs-string">"Click"</span> /&gt;<span class="hljs-comment">//  或者js写法</span>document.getElementById(<span class="hljs-string">'btn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;</span>            console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Ｉ　am ｐｒｏｃｅｓｓｅｄ by dom0!'</span>);        &#125;;</code></pre><h3 id="这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。"><a href="#这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。" class="headerlink" title="这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。"></a>这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。</h3><h2 id="dom2"><a href="#dom2" class="headerlink" title="dom2"></a>dom2</h2><p>或者叫 2 级 dom，继续如下呗</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'input'</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert('haha')"</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'fff'</span>)</span><span class="actionscript">     &#125;; <span class="hljs-comment">// 目标阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'mmm'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// 捕获阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'ooooo'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// 捕获阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'pppp'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">false</span>)  <span class="hljs-comment">// 冒泡阶段</span></span><span class="actionscript">     <span class="hljs-comment">// 兼容低版本IE的写法</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).attachEvent(<span class="hljs-string">"onclick"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'pppp'</span>)</span>     &#125;); <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // mmm ooooo fff pppp</code></pre><p>dom2 把事情分为 3 步 ———— 事件捕获阶段、处于目标阶段和事件冒泡阶段</p><pre><code class="hljs actionscript">addEventListener(<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;&#125;,<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>)<span class="hljs-comment">// 第一个参数，表明是啥触发事件</span><span class="hljs-comment">// 第二个参数，事件触发以后的回调函数</span><span class="hljs-comment">// 第三个参数，true或者false ，true是第二个参数那个回调函数在捕获阶段调用 ，false在冒泡阶段 ，默认是false</span><span class="hljs-comment">// 2015年底，扩展了第三个参数</span>el.addEventListener(type, listener, &#123;    capture: <span class="hljs-literal">false</span>, <span class="hljs-comment">// useCapture</span>    once: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// 是否设置单次监听</span>    passive: <span class="hljs-literal">false</span>  <span class="hljs-comment">// 是否让阻止默认行为preventDefault()失效</span>    <span class="hljs-comment">//  由于 touchmove 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止。那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。当设置了passive为true，则会忽略代码中的preventDefault(), 因此页面会变得更流畅</span>&#125;)</code></pre><p>window =&gt; document =&gt; body =&gt; div 捕获</p><p>div =&gt; body =&gt; document =&gt; window 冒泡</p><h3 id="这种写法，不会覆盖，会依次输出所有项"><a href="#这种写法，不会覆盖，会依次输出所有项" class="headerlink" title="这种写法，不会覆盖，会依次输出所有项"></a>这种写法，不会覆盖，会依次输出所有项</h3><p>顺便提一嘴 dom3 ，增加了更多的事件类型，比如：<br>       DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，全部类型如下：</p><p>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</p><p>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</p><p>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</p><p>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</p><p>文本事件，当在文档中输入文本时触发，如：textInput</p><p>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</p><p>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</p><p>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</p><p>同时 DOM3 级事件也允许使用者自定义一些事件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>区别：dom0 会覆盖，dom2 不会覆盖。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dom0 dom2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高阶函数</title>
    <link href="/2020/06/15/higher-order-function/"/>
    <url>/2020/06/15/higher-order-function/</url>
    
    <content type="html"><![CDATA[<h2 id="可以接收另一个参数作为参数的函数，就叫做高阶函数。"><a href="#可以接收另一个参数作为参数的函数，就叫做高阶函数。" class="headerlink" title="可以接收另一个参数作为参数的函数，就叫做高阶函数。"></a>可以接收另一个参数作为参数的函数，就叫做高阶函数。</h2><h3 id="常见高阶函数"><a href="#常见高阶函数" class="headerlink" title="常见高阶函数"></a>常见高阶函数</h3><ol><li>Array.prototype.map,</li><li>Array.prototype.filter,</li><li>Array.prototype.reduce,</li></ol><p>既然提到了这几个数组方法，那也就顺便说一说哈</p><ul><li>map 是啥，就不在这里说了，不知道就百度去。map() 方法的回调函数接受 3 个参数。 item index arraySelf 。 item 是数组的每一个元素 ，index 是该元素的下标（数组中的第几个元素），arraySelf 是调用 map 方法的这个数组，当然了，这些参数不是固定叫 item，index 啥的，这是入参，叫啥都行，位置对的上相应的位置就行。比如：</li></ul><pre><code class="hljs stata">[1,2,3].map((<span class="hljs-keyword">one</span>,<span class="hljs-keyword">two</span>,three)=&gt;&#123;  <span class="hljs-comment">// 这里的one就对应上面我说的item ，two就是index，这样说就能明白吧？</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">one</span> + <span class="hljs-keyword">two</span> + three.length&#125;)</code></pre><p>map 有返回值，会返回一个新的数组，而类似的 forEach（）方法，就没有返回值，所以哟，用 forEach 的时候经常会搭配 Array.push() 😁 还有啊，写 jsx 的时候，map 遍历出来的玩意你得加个 key 值，通常可以是 index，比如哈，我举个栗子 🌰</p><pre><code class="hljs javascript">&lt;ul&gt;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span> = <span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&#123;item&#125;</span> &gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>&#125;)&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><p>这玩意写的好像有点多余。。。好像会 map 的都能知道，不会 map 看了我这也看不懂。😂</p><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].filter(item=&gt;item &gt; <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].reduce((x,y)=&gt;&#123;<span class="hljs-keyword">return</span> x + y&#125;)</code></pre><p>react-redux</p><p>connect 方法 嘻嘻 弄一波这个～</p><p>connect 方法做的事情是将 state 和 dispatch 绑定到 Connect 组件的参数上，然后 Connect 组件将你当前的 App 组件封装起来，使得 App 组件可以通过 props 获取到父组件 Connect 传递的 state 和 props。</p><p>这也就是为什么你可以在自己写的组件上面直接通过 this.props 访问到 state 和 action。有的人是通过 store 去读取 state 和 dispatch action，也是一样的道理。</p><p>从 connect 方法的实现，我们看到了非常多 react 组件的影子，生命周期，props 传递，context 上下文。</p><p>对比 Provider 组件：</p><p>Provider 是顶层组件的作用，将 store 作为上下文提供给全局共享，而 Connect 组件是局部组件，将某个 react 组件包装起来，传递指定的 state 和 props 给该组件访问。</p><h3 id="非常遗憾，我没有彻底看懂-connect-的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解"><a href="#非常遗憾，我没有彻底看懂-connect-的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解" class="headerlink" title="非常遗憾，我没有彻底看懂 connect 的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解"></a>非常遗憾，我没有彻底看懂 connect 的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解</h3><p><a href="https://www.cnblogs.com/williamjie/p/9591826.html" target="_blank" rel="noopener">这是别人博客，connect 解析源码的</a></p><h4 id="发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个-480-行的源码还是不明白具体咋回事。"><a href="#发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个-480-行的源码还是不明白具体咋回事。" class="headerlink" title="发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个 480 行的源码还是不明白具体咋回事。"></a>发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个 480 行的源码还是不明白具体咋回事。</h4><pre><code class="hljs kotlin">export <span class="hljs-keyword">default</span> function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;<span class="hljs-keyword">return</span> function wrapWithConnect(WrappedComponent) &#123;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connect</span> <span class="hljs-title">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props, context) &#123;      <span class="hljs-comment">// 从祖先Component处获得store</span>      <span class="hljs-keyword">this</span>.store = props.store || context.store      <span class="hljs-keyword">this</span>.stateProps = computeStateProps(<span class="hljs-keyword">this</span>.store, props)      <span class="hljs-keyword">this</span>.dispatchProps = computeDispatchProps(<span class="hljs-keyword">this</span>.store, props)      <span class="hljs-keyword">this</span>.state = &#123; storeState: <span class="hljs-literal">null</span> &#125;      <span class="hljs-comment">// 对stateProps、dispatchProps、parentProps进行合并</span>      <span class="hljs-keyword">this</span>.updateState()    &#125;    shouldComponentUpdate(nextProps, nextState) &#123;      <span class="hljs-comment">// 进行判断，当数据发生改变时，Component重新渲染</span>      <span class="hljs-keyword">if</span> (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123;        <span class="hljs-keyword">this</span>.updateState(nextProps)          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;      &#125;      componentDidMount() &#123;        <span class="hljs-comment">// 改变Component的state</span>        <span class="hljs-keyword">this</span>.store.subscribe(() = &#123;          <span class="hljs-keyword">this</span>.setState(&#123;            storeState: <span class="hljs-keyword">this</span>.store.getState()          &#125;)        &#125;)      &#125;      render() &#123;        <span class="hljs-comment">// 生成包裹组件Connect</span>        <span class="hljs-keyword">return</span> (          &lt;WrappedComponent &#123;...<span class="hljs-keyword">this</span>.nextState&#125; /&gt;        )      &#125;    &#125;    Connect.contextTypes = &#123;      store: storeShape    &#125;    <span class="hljs-keyword">return</span> Connect;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高阶函数 react-redux connect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端路由</title>
    <link href="/2020/06/11/router-hash-history/"/>
    <url>/2020/06/11/router-hash-history/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是前端路由？"><a href="#什么是前端路由？" class="headerlink" title="什么是前端路由？"></a>什么是前端路由？</h2><p>路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p><h2 id="如何实现前端路由？"><a href="#如何实现前端路由？" class="headerlink" title="如何实现前端路由？"></a>如何实现前端路由？</h2><p>要实现前端路由，需要解决两个核心问题：</p><p>1.如何改变 URL 却不引起页面刷新？ 2.如何检测 URL 变化了？</p><h3 id="hash-实现"><a href="#hash-实现" class="headerlink" title="hash 实现"></a>hash 实现</h3><p>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新<br>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过标签改变 URL、通过 window.location 改变 URL，这几种情况改变 URL 都会触发 hashchange 事件</p><h3 id="history-实现"><a href="#history-实现" class="headerlink" title="history 实现"></a>history 实现</h3><p>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新<br>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过 pushState/replaceState 或标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState 的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</p><h2 id="hash-实现（简略版）"><a href="#hash-实现（简略版）" class="headerlink" title="hash 实现（简略版）"></a>hash 实现（简略版）</h2><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">ref=""&gt;    <span class="hljs-comment">&lt;!-- 定义路由 --&gt;</span></span><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/home"</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/about"</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>ref=<span class="hljs-string">""</span>&gt;    &lt;!-- 渲染路由对应的 UI --&gt;    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"routeView"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  &lt;/ul&gt;&lt;/body&gt;// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件<span class="hljs-keyword">window</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, onLoad)// 监听路由变化<span class="hljs-keyword">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, onHashChange)// 路由视图var routerView = null<span class="hljs-keyword">function</span> onLoad () &#123;  routerView =<span class="hljs-built_in"> document</span>.querySelector(<span class="hljs-string">'#routeView'</span>)  onHashChange()&#125;// 路由变化时，根据路由渲染对应 UI<span class="hljs-keyword">function</span> onHashChange () &#123;  <span class="hljs-keyword">switch</span> (location.hash) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">'#/home'</span>:      routerView.innerHTML = <span class="hljs-string">'Home'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">case</span> <span class="hljs-string">'#/about'</span>:      routerView.innerHTML = <span class="hljs-string">'About'</span>      <span class="hljs-keyword">return</span>    default:      <span class="hljs-keyword">return</span>  &#125;&#125;</code></pre><h2 id="history-实现（简略版）"><a href="#history-实现（简略版）" class="headerlink" title="history 实现（简略版）"></a>history 实现（简略版）</h2><pre><code class="hljs php">&lt;body&gt;  &lt;ul&gt;    &lt;li&gt;&lt;a href=<span class="hljs-string">'/home'</span>&gt;home&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=<span class="hljs-string">'/about'</span>&gt;about&lt;/a&gt;&lt;/li&gt;    &lt;div id=<span class="hljs-string">"routeView"</span>&gt;&lt;/div&gt;  &lt;/ul&gt;&lt;/body&gt;<span class="hljs-comment">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span>window.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, onLoad)<span class="hljs-comment">// 监听路由变化</span>window.addEventListener(<span class="hljs-string">'popstate'</span>, onPopState)<span class="hljs-comment">// 路由视图</span><span class="hljs-keyword">var</span> routerView = <span class="hljs-keyword">null</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLoad</span> <span class="hljs-params">()</span> </span>&#123;  routerView = document.querySelector(<span class="hljs-string">'#routeView'</span>)  onPopState() href=<span class="hljs-string">""</span>&gt;  <span class="hljs-comment">// 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。</span>  <span class="hljs-keyword">var</span> linkList = document.querySelectorAll(<span class="hljs-string">'a[href]'</span>)  linkList.<span class="hljs-keyword">forEach</span>(el =&gt; el.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>&#123;    e.preventDefault()    history.pushState(<span class="hljs-keyword">null</span>, <span class="hljs-string">''</span>, el.getAttribute(<span class="hljs-string">'href'</span>))    onPopState()  &#125;))&#125;<span class="hljs-comment">// 路由变化时，根据路由渲染对应 UI</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onPopState</span> <span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">switch</span> (location.pathname) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">'/home'</span>:      routerView.innerHTML = <span class="hljs-string">'Home'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">case</span> <span class="hljs-string">'/about'</span>:      routerView.innerHTML = <span class="hljs-string">'About'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span>  &#125;&#125;</code></pre><h2 id="总结：前端路由，在-SPA-单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。"><a href="#总结：前端路由，在-SPA-单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。" class="headerlink" title="总结：前端路由，在 SPA 单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。"></a>总结：前端路由，在 SPA 单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端路由 Hash History</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS模块化的发展历程</title>
    <link href="/2020/06/10/commonjs-amd-cmd/"/>
    <url>/2020/06/10/commonjs-amd-cmd/</url>
    
    <content type="html"><![CDATA[<p><strong>随便写点 js 模块化发展历史，面试有问这玩意的，随便看看到时候能答出来几句就 ok，顺便咱也了解一下 js 的这方面历史。</strong></p><p>1.js 的诞生：由 Brendan Eich 花了不到十天时间发明，用来在网页上进行表单校验、实现简单的动画效果等等，你可以回想一下那个网页上到处有公告块飘来飘去的时代。<br>2.2006 年 ajax 出现，js 开始发展。全局变量开始让人头疼了，函数命名开始冲突了 3.所以 js 需要，也必须要整模块化</p><p>需要解决的问题是：</p><ul><li>如何安全的包装一个模块的代码？（不污染模块外的任何代码）</li><li>如何唯一标识一个模块？</li><li>如何优雅的把模块的 API 暴漏出去？（不能增加全局变量）</li><li>如何方便的使用所依赖的模块？</li></ul><p>2009 年，node.js 诞生，这下模块化必须马上整了，要不然服务端没法弄了 所以 当当当当～ CommonJs 闪亮登场</p><h2 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h2><p>简单来说呢，commonJs 就是，exports 暴露 API，require 引入该 API 的模块，</p><p>缺点，得发请求啊 这玩意就不太好了</p><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>异步加载所需的模块，然后在回调函数中执行主逻辑。</p><p>缺点：预先下载太多东西，而且定义模块的时候写法复杂，最重要的是，它实时下载代码然后触发回调，主体代码运行。用户会有卡顿感。</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>淘宝前端 玉伯 整出来的，融各家所长，没啥缺点</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>2015 年 6 月，es6 来了，export 暴露，import 引入，编译时加载（静态加载）</p><h2 id="总结，就这点内容，还总结啥？告辞～"><a href="#总结，就这点内容，还总结啥？告辞～" class="headerlink" title="总结，就这点内容，还总结啥？告辞～"></a>总结，就这点内容，还总结啥？告辞～</h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CommonJs AMD CMD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包，老铁安排上</title>
    <link href="/2020/06/09/bi-bao/"/>
    <url>/2020/06/09/bi-bao/</url>
    
    <content type="html"><![CDATA[<p>呱呱，啥是闭包？<br>天天写闭包，但是让表达出来，还真有点懵住了，<br>这玩意我都记在心里，话说不出口，都在酒里了，干杯～</p><p>—### 闭包是啥？</p><p>来几个官方回答，可以应付面试</p><ul><li>闭包是一个有自己环境的函数，并且在该环境中至少有一个变量。</li><li>闭包是将函数与其引用的周边状态绑定在一起形成（封装）的组合</li><li>闭包函数是声明在一个函数中的函数</li><li>闭包是内部函数总是可以访问其所在的外部函数中生命的参数和变量，即使在其外部函数被返回以后</li></ul><h3 id="闭包特点（优缺点都有哈）"><a href="#闭包特点（优缺点都有哈）" class="headerlink" title="闭包特点（优缺点都有哈）"></a>闭包特点（优缺点都有哈）</h3><ul><li><p>让外部访问函数内部变量成为可能；</p></li><li><p>局部变量会常驻在内存中；</p></li><li><p>可以避免使用全局变量，防止全局变量污染；(不用担心变量名重复，不过都 2020 年了，谁还频繁用 var 声明变量啊。)</p></li><li><p>会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p><p>闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。<strong>每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。</strong>但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。所以啊，当有很多很多闭包的时候，或者闭包被调用很多很多次的时候，那么就会内存泄漏了。</p></li></ul><p><em>然后面试的时候，可能会遇见一些笔试题，面试官整一个函数，让你写输出的值，设计个圈套坑你，怎么办？不慌！有秘诀～</em></p><p><strong>秘诀在此：输出的就是同一个地址中的爸爸函数中的变量值</strong></p><p>如此简单粗暴的秘诀，喜欢吗？</p><p>光说不练假把式，下面我来表演绝活：举个栗子 🌰</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funA</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// funA的活动对象之中;</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//匿名函数的活动对象;</span>        alert(a);  &#125;&#125;<span class="hljs-keyword">var</span> b = funA();b();<span class="hljs-comment">// 10</span></code></pre><p>由浅入深，先从这个简单的开始，套入秘诀，<em>同一个地址中的爸爸函数中的变量值</em> 啥叫同一个地址呢，就是被同一个人调用，在这个栗子里面，就是这个：</p><p>var b = funA（）<br>b()</p><p>这个 b 就是个地址，如果多一个 var c = funA（） 然后调用 c（），那么这个 c 就是另一个地址。</p><p>地址就明白了吧～<br>然后找爸爸，爸爸的爸爸叫什么，爸爸的的爸爸叫爷爷。。。哈哈 ，皮一下</p><p>回到找爹的正事上来，alert（a）是儿子，他爸在外边包住了它，就是这个 funA 是它爸。也可以理解为怀孕的母亲，和肚子里的孩子。（谁在里面谁儿子）</p><p>所以找到了它爸爸里面的变量 a=10 ，所以输出 10</p><p>好的，很开心，我们看下一个栗子 🌰</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zhujunFn</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xcolaFn</span>(<span class="hljs-params"></span>)</span>&#123;      i++;      <span class="hljs-built_in">console</span>.log(i);  &#125;  <span class="hljs-keyword">return</span> xcolaFn;&#125;<span class="hljs-keyword">var</span> aaa = zhujunFn();  <span class="hljs-comment">//每次外部函数执行的时候,外部函数的地址不同，都会重新创建一个新的地址,这个aaa是个新的地址</span>aaa();aaa();aaa();<span class="hljs-keyword">var</span> bbb = zhujunFn();  <span class="hljs-comment">//  所以这也是一个新的地址，aaa和bbb 是两个不同的地址</span>bbb();bbb();bbb();<span class="hljs-comment">// 1 2 3 1 2 3</span></code></pre><p>先重复一下我们的秘诀，然后找爹</p><ul><li><p><em>同一个地址中的爸爸函数中的变量值</em></p><p>aaa 和 bbb 分别是两个地址，是独立的</p><p>然后给这个 <strong>xcolaFn</strong> 找爹，是外边这个 <strong>zhujunFn</strong>，然后找到里面的这个变量 i，每次调用 aaa（）输出 i 为 1，2，3</p><p>每次调用 bbb（）是新的地址，独立的，所以也是一样的道理 输出 i 为 1，2，3</p></li></ul><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>; <span class="hljs-built_in">i</span>&lt;=<span class="hljs-number">5</span>; <span class="hljs-built_in">i</span>++) &#123; (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(j)</span> &#123;</span>setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span><span class="hljs-params">()</span> &#123; <span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">( j )</span>;</span>             &#125;, <span class="hljs-built_in">j</span>*<span class="hljs-number">1000</span> );         &#125;)( <span class="hljs-built_in">i</span> );&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我没啥想总结了，有营养的都在上边了，如果看完了发现还是不太明白，那一定是我没说清楚，不怪你，那就再看看这个人对闭包的理解吧，会有帮助的<br>链接在此：<a href="http://blog.xcola.top/2018/05/23/%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">请点击这里</a></p><p><strong>冲鸭，奥利给</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js事件循环机制</title>
    <link href="/2020/06/08/event-loop/"/>
    <url>/2020/06/08/event-loop/</url>
    
    <content type="html"><![CDATA[<ul><li>js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。</li><li>这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）</li></ul><ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li><li>如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行</li></ul><h5 id="看不懂没关系，先往下看，回过头来就理解这些了，老铁！"><a href="#看不懂没关系，先往下看，回过头来就理解这些了，老铁！" class="headerlink" title="看不懂没关系，先往下看，回过头来就理解这些了，老铁！"></a>看不懂没关系，先往下看，回过头来就理解这些了，老铁！</h5><h3 id="js-中的异步操作"><a href="#js-中的异步操作" class="headerlink" title="js 中的异步操作"></a>js 中的异步操作</h3><ul><li>setTimeOut</li><li>setInterval</li><li>ajax</li><li>promise</li><li>I/O</li></ul><h3 id="同步任务-异步任务"><a href="#同步任务-异步任务" class="headerlink" title="同步任务 - 异步任务"></a>同步任务 - 异步任务</h3><ul><li>同步任务是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务</li><li>异步任务 不进入主线程，而是进入 任务队列 ，只有 任务队列 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务 - 微任务"></a>宏任务 - 微任务</h3><ul><li>宏任务：整体代码 script/setTimeOut 等（new Promise 会进入主线程立刻执行，是主线程任务）</li><li>微任务：promise.then/promise.nextTick (node)</li></ul><hr><p>举个栗子</p><pre><code class="hljs fortran">console.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)setTimeOut(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)&#125;,<span class="hljs-number">0</span>)console.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)</code></pre><p>执行结果 1 3 2</p><p><strong>因为 setTimeOut 是异步任务，所以哪怕是 0 秒等待，也会等主线程任务都完事了以后才执行，下边是详细解析</strong></p><p>1.console.log(1)是同步任务，直接打印 1；</p><p>2.setTimeout 是异步任务，且是宏函数，放到宏函数队列中，等待下次 Event Loop 才会执行；</p><p>3.console.log(3)是同步任务，直接打印 3；</p><p>4.主线程执行完毕，没有微任务，那么执行第二个宏任务 setTimeout，打印 2；</p><p>5.结果：1，3，2</p><p><strong>也就是说，如果有 promise，那是同步任务，等所有同步任务完事，开始执行这个 promise.then，再然后才是 setTimeOut 啥的。</strong></p><hr><p>举个栗子</p><pre><code class="hljs lisp">setTimeout(<span class="hljs-name">function</span>()&#123;    console.log(<span class="hljs-number">1</span>)&#125;)<span class="hljs-comment">;</span>new Promise(<span class="hljs-name">function</span>(<span class="hljs-name">resolve</span>)&#123;    console.log(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>    for(<span class="hljs-name">var</span> i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10000; i++)&#123;</span>        i == <span class="hljs-number">9999</span> <span class="hljs-symbol">&amp;&amp;</span> resolve()<span class="hljs-comment">;</span>    &#125;&#125;).then(<span class="hljs-name">function</span>()&#123;    console.log(<span class="hljs-number">3</span>)&#125;)<span class="hljs-comment">;</span>console.log(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span></code></pre><p>输出 2 ， 4 ， 3， 1</p><p>1.setTimeout 是异步，且是宏函数，放到宏函数队列中；</p><p>2.new Promise 是同步任务，直接执行，打印 2，并执行 for 循环；</p><p>3.promise.then 是微任务，放到微任务队列中；</p><p>4.console。log(4)同步任务，直接执行，打印 4；</p><p>5.此时主线程任务执行完毕，检查微任务队列中，有 promise.then，执行微任务，打印 3，</p><p>6.微任务执行完毕，第一次循环结束；从宏任务队列中取出第一个宏任务到主线程执行，打印 1</p><hr><p><em>再举个厉害的栗子吧</em></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer1</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)  &#125;, <span class="hljs-number">1000</span>)&#125;add();setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer2</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer3</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)  &#125;, <span class="hljs-number">100</span>)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;    i == <span class="hljs-number">99</span> &amp;&amp; resolve()  &#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer4</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)  &#125;, <span class="hljs-number">0</span>)  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>)</code></pre><p>结果 1， 4， 8， 7， 3， 6， 5， 2，<br>这就不解析了，这回弄懂了吧。</p><hr><p><strong>总结：这是个循环，第一次循环先搞定所有主线程任务，完事以后看看有没有微任务，如果有，执行，然后结束第一次循环，如果没有，就直接结束第一次循环，，，然后开始第二次循环，找到宏任务里边最先执行那个，执行，所有都执行完事，然后看有没有微任务，如果有。。。如果没有。。。。你看这句话上面也说过，这就是循环啊，然后继续循环啊，直到没有宏任务，也没有微任务。循环就完事了呗</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js运行循环机制 宏任务 微任务 同步任务 异步任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Markdown开始</title>
    <link href="/2020/06/08/my-first/"/>
    <url>/2020/06/08/my-first/</url>
    
    <content type="html"><![CDATA[<h3 id="so-what-can-i-do"><a href="#so-what-can-i-do" class="headerlink" title="so what can i do"></a>so what can i do</h3><p>先写个开头，顺便复习一下 markdown，是的，没错，我又忘记 markdown 怎么用了，为了避免再次忘记，要尽量多的使用，<br>比如</p><ul><li>1 尽量频繁的写博客</li><li>2 尽量频繁的写博客</li><li>3 还是 tmd 尽量频繁的写博客</li></ul><p>无序列表用*<br>有序列表用 1.</p><p>比如</p><ol><li>这是有序的</li><li>我是有头发的</li><li>第三条不重要</li></ol><p>加个大于号 后边是文字 展示效果是引用</p><blockquote><p>这是鲁迅说的 —— 周树人</p></blockquote><p>插入链接 <a href="就当这里有链接">xxx</a> 英文书名号加小括号</p><p>插入图片 前边有个感叹号 <img src="%E5%B0%B1%E5%BD%93%E8%BF%99%E9%87%8C%E6%9C%89%E9%93%BE%E6%8E%A5%E5%90%A7" srcset="/img/loading.gif" alt="假装有图.jpg"> 英文感叹号加书名号加小括号</p><p><strong>左右各两个星号中间夹的会加粗，请给我加粗</strong><br><em>左右各一个星号就倾斜</em></p><p>模版字符串中间可以放代码，比如<br><code>const wanghao = &#39;辣鸡&#39;</code><br>左右各三个这玩意，可以夹住代码块，let me try try<br>···不好意思，整错了···</p><pre><code class="hljs ebnf"><span class="hljs-attribute">let a</span> = 1;<span class="hljs-attribute">a</span> = 2;<span class="hljs-attribute">a</span> = b = 2;</code></pre><p>tab 可以缩进，这就是为啥现在才有缩进，我刚看到。<br>非常开心，再来几个缩进<br>三个星号是分割线</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><p>啊。。。失败的 markdown 表格，为啥表格没好使呢？(之前这里没有展示为表格，后来自动格式化，，，能成功展示了)</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><p>markdown 表格没好使的原因是 我在|后面习惯性的加了空格。导致 markdown 没能识别这种。行那我们继续，上面失败的的就不删除了</p><hr><p><strong>行，这就算复习完事，接下来我随便写写。</strong><br><strong>别问我为啥加粗，我就喜欢粗，并且不缩进，真男人从来不做缩头乌龟</strong></p><h2 id="我还能更粗"><a href="#我还能更粗" class="headerlink" title="我还能更粗"></a>我还能更粗</h2><p>最近经历了好多的事情，事情都是相对的，辩证去看，也无所谓好坏。<br>但是很多事情，我都不喜欢，不如意事常八九，可与人言无二三。<br>敲了很多字，又都删掉了。觉得没有意义。自己和自己的辩论，总归赢的也是自己。<br>自己和自己探讨人生观，价值观，也未免太无趣，还要写在这里记录下来，也未免太他妈的无趣<br>总而言之，我就一句话，我想变强。</p><hr><p><em>我没觉得喜欢这个行业，但是我喜欢自己逐渐变强的感觉。</em></p><p>开始整活！<br><strong>奥利给</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加油</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/06/05/hello-world/"/>
    <url>/2020/06/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>.</title>
    <link href="/2020/01/18/secret0818/"/>
    <url>/2020/01/18/secret0818/</url>
    
    <content type="html"><![CDATA[<p>hi，someone. this is not for anybody,but maybe this is for the future you</p><p>有人现在说喜欢小溪<br>是因为还没见过大海<br>而我已经见过了银河<br>却仍然只爱你这颗星</p><p>—《what can i hold you with? 》<br>__ Jorges Luis Borges</p><p>i offer you lean streets,desperate sunsets, the moon of the jagged suburbs<br>i offer you the bitterness of a man who has looked long and long at the lonely moon<br>i offer you my ancestors, my family<br>i offer you whatever insight my books may hold<br>whatever manliness or humour my life<br>i offer you the loyalty of a man who has never been loyal<br>i offer you explanations of yourself,theories about yourself,authentic and surprising news of yourself<br>i can give you my loneliness ,my darkness,the hunger of my heart<br>i am trying to bribe you with uncertainty,with danger,with defeat</p><p>《 爱你 就像爱生命 》 ————王小波<br>我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。</p><p>你是非常可爱的人，真应该遇见最好的人，我也真希望我就是。</p><p>“我遇见你，我记得你，这座城市天生就适合恋爱，你天生就适合我的灵魂。” ——杜拉斯</p><p>如果你给我的，和你给别人的是一样的，那我就不要了。 ———— 三毛</p><p>whereever they might be they always remember that the past was a lie, that memory has no return,<br>that every spring gone by could never be recovered,<br>and that the wildest and most tenacious love was an ephemeral truth in the end —– 《百年孤独》英文版</p><p>不管在哪里啊，都要记得。过去的都已成为过去了，永远不可能回到从前。<br>春夏秋冬再怎么轮回，回不到从前的春天。<br>就连最刻骨铭心的爱情也只是一部短暂的纪录片。</p><p>假如生活欺骗了你<br>不要悲伤，不要心急<br>忧郁的日子里需要镇静<br>相信吧，快乐的日子将会来临<br>心儿永远向往着未来<br>现在却常是忧郁<br>一切都是瞬息，一切都将会过去<br>而那过去了的，就会成为亲切的怀恋</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>.</title>
    <link href="/2020/01/17/secret0817/"/>
    <url>/2020/01/17/secret0817/</url>
    
    <content type="html"><![CDATA[<!-- 2020-11-04我不想做个好人了 --><!-- 2020-11-10郭辉今天过阴历生日， 0925，明明是阳历19951117才对刘雅慧好像是8月5号王殷19981202安荷白不知道哪天，也许是忘记了王思宇是双鱼的，但是不知道哪天，那么久了记不住的还有谁呢/周书仪好像是金牛座想不起来了，然后去看了下名单觉得也没几个人啊你们出现在我的生命里我出现在你们生命里可还能想得起来我？反正我是记不清许多了 --><!-- 2020-11-10我以为我会一直生猛下去，可是万万没有想到，身体先出了异常得早睡早起，得锻炼身体啊 -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>张爱玲</title>
    <link href="/2019/11/24/essay1124/"/>
    <url>/2019/11/24/essay1124/</url>
    
    <content type="html"><![CDATA[<p>也许每一个男子全都有过这样的两个女人，至少两个。<br>娶了红玫瑰，久而久之，红的变了墙上的一抹蚊子血，白的还是“床前明月光”；<br>娶了白玫瑰，白的便是衣服上的一粒饭粘子，红的却是心口上的一颗朱砂痣。</p><!-- 我心口有朱砂痣，我床头有白月光 得不到的永远在搔动 真的是他妈的操蛋--><p>因为爱过，所以慈悲；因为懂得，所以宽容。</p><p>人总是在接近幸福时倍感幸福，在幸福进行时却患得患失。</p><p>你还不来，我怎敢老去。</p><p>我以为爱情可以填满人生的遗憾。然而，制造更多遗憾的，却偏偏是爱情。</p><p>我要你知道，在这个世界上总有一个人是等着你的，不管在什么时候，不管在什么地方，反正你知道，总有这么个人。</p><p>生命是一袭华美的袍，爬满了虱子。</p><p>雨声潺潺，像住在溪边，宁愿天天下雨，以为你是因为下雨不来。</p><p>你问我爱你值不值得，其实你应该知道，爱就是不问值得不值得。</p><p>生在这世上，没有一样感情不是千疮百孔的。</p><p>对于中年以后的人，十年八年都好象是指顾间的事。可是对于年轻人，三年五载就可以是一生一世。</p><p>踮起脚尖，我们就能离幸福更近一点吗？</p><p>不管你的条件有多差 总会有个人在爱你。不管你的条件有多好，也总有个人不爱你。</p><p>如果你认识从前的我，那么你就会原谅现在的我。</p><p>有些傻话，不但是要背着人说，还得背着自己。让自己听见了也怪难为情的。譬如说，我爱你，我一辈子都爱你。</p><p>于千万人之中遇见你所要遇见的人，于千万年之中，时间的无涯的荒野里，<br>没有早一步，也没有晚一步，刚巧赶上了，那也没有别的话可说，<br>惟有轻轻地问一声：“噢，你也在这里吗？”</p><p>缘起缘灭，缘浓缘淡，不是我们能够控制的。我们能做到的，是在因缘际会的时侯好好的珍惜那短暂的时光。</p><pre><code class="hljs">读书读多了，事见的多了，人接触多了，会怀疑。那种至死不渝的爱情，真的有吗？梁山伯祝英台，许仙白蛇，现在这时代好像没有啊科技这么发达，通讯这么迅捷看到的消息却都是结了婚的离婚，离了婚的打官司哪里还有孔雀东南飞，自挂东南枝。乱七八糟的媒体消息，整的我都想自挂东南枝。我希望这世界有爱情我相信这世界有爱情爱一个人不难啊，两个人相爱就很难。两个人一直一直相爱就更难了。许个愿，祝我会有一段两个人一直一直相爱的爱情。我在接近幸福时候感到幸福，我在幸福进行时也会感到幸福曾经我没有珍惜，现在学会了珍惜却没有幸福的机会张爱玲说：我要你知道，在这个世界上总有一个人是等着你的，不管在什么时候，不管在什么地方，反正你知道，总有这么个人。我也希望会有人这么跟我说哈哈哈哈，但是我没有，但是我会有的，但是我不会让她说这么幽怨的话。咱们在一起了咱们好好的奔三的人了，十年八年都好象是指顾间的事。一辈子很快就过去相爱的人很快就能爱一辈子缘分这东西，还真是强求不来经历了这么多次顺理成章仔细想想那都是天大的缘分呐缘起于千奇百怪，缘灭于莫名其妙。爱情开始的时候我所能做的，是珍惜，是投入。我所不能勉强的，是另一半的想法。爱情结束的时候我所能做的，是释然，是祝福。我所不能挽留的，是决定了要离开的人。如果你认识从前的我，那么你就会原谅现在的我。我会逐渐的把过去的故事讲给你听要耐心点不要在不了解我的时候就放弃你以为的可能只是你以为我其实真的很不错于千万年之中，在千万里之内。遇见你“你好”“叫我朱军”</code></pre>]]></content>
    
    
    <categories>
      
      <category>读书心得</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试一下</title>
    <link href="/2010/10/27/essay1027/"/>
    <url>/2010/10/27/essay1027/</url>
    
    <content type="html"><![CDATA[<p>hello world</p><!-- 他想隐藏在这个世界，又想发出声音。他喜欢炽热的欢愉，也喜欢冷淡的静默。明明是炎热的 8 月，他为什么会感到冷呢真是个奇怪的人啊他在期待着什么呢？午夜他在外游荡撒野躺在草坪望着星空闻到了湖边若有若无的潮湿听见拂面温柔静谧的风嘴上与朋友谈心说笑心里又在想着什么呢？我也不知道仔细想想他也是个挺浪漫的人他做错了事情我知道他做错了我劝他戒酒又不希望他变成滴酒不沾没有情趣的人虽然现在被世界遗弃着但是他也曾经被那么多人爱着啊 --><!-- 2020-10-27尝试做些小课题，截止今日均已失败告终。对技术认知的如此缺少。脑子里没有正确的概念。导致想法思路啥的又跑偏了不可能所有想法都做的出来啊所以不能想做啥就做啥啊还是要看看大家是怎么做的然后参考出自己的思路。然后是此时此刻的糟糕情绪。我倒是不怕暂时的失败，但是一次又一次的是真的打击信心啊。。。现在是 10 点半，要拖着疲惫的身心回家了今天是不成功的一天明天一定要比今天好啊失败是成功他妈的，干干干，奥利给 --><!-- 2020-11-03：我得允许自己爬不到金字塔的顶端，我得接受自己是个茫茫人海中的普通一员。如果我的能力只能让我苟延残喘着那么苟延残喘就是我的价值wh：你是个明白人。任何人的成长，都是从接受自己的平庸开始。：接受平庸？ 我接受个🐔我可是这世界上最棒的朱军：我太他妈的棒了：我想啊，如果世界上比我惨的人都消失了我就是最惨的那个穷困潦倒无依无靠但是我心态不会崩塌wh：[狗子]总有人比你惨。：如果世界上比你差的人都消失了你心态会不会崩呢wh：不可能的。：你会：你内心的骄傲不允许这样你会想要了结自己这个时候我就会踩着7色云彩救你于水火wh：是的，我的骄傲不允许我比身边的人都辣鸡。：我这点骄傲早都被磨平了 他妈的wh：你也没沦落到比你身边的所有人都辣鸡。wh：起码你前女友的数量就遥遥领先。：谁比那个？？：不比较，就没有差异：不比较，世界都一样：山也是水，水也是山你也是我，我也还是你爹：当代哲学家，朱军《朱学》即将出版，欢迎大家购买wh：世界总是充满比较，你就是比别人沙雕，我也比你爹更像你爹。：他妈的竟然无力反驳，但是不能承认wh：无力反驳就是不能否认，这个时候的你口头上承不承认就没什么意义了。：不管有没有意义，那是我和我最后的倔强：倔强的小红军也许我在茫茫人海人海中乍一看不起眼，但是你仔细看啊，我也在闪闪发光。 --><p>2020-11-04</p><!-- # 个人信息- 朱军/男/1994- 工作年限：2 年- 手机：13072474469- Email：13072474469@163.com-# 技能清单- 编程语言：html css javascript ajax- 前端框架：react.js umi.js dva.js antd,了解 react hooks 等新特性- 前端工具：less、xlsx、axios、lodash- 版本管理、文档和自动化部署工具：Git- 熟练使用 ES5，ES6，熟悉 ES7 等之后的语法- 了解 webSocket 技术与后端完成交互# 工作经历## 北京深度制耀科技有限公司（ 2019 年 7 月 ~ 今）### Herms 项目是一个外企拜耳公司的项目—— 人类遗传资源信息管理系统为了让用户快速，准确并且合乎法规的向人类遗传资源管理办公室提供相关资料而诞生的一个系统工具。其中我负责前端的一些页面展示、页面交互及业务需要的一些组件开发，如：登录页面及相关逻辑（实现 UI 效果）、申报审批相关页面（复杂业务逻辑）、源文件管理页面（增删改查下载预览版本跟踪）、监控预警页面（数据可视化）、审计追踪页面（电子签名，操作记录）等页面。- 在线上灰度测试的时候，发现该项目线上服务器中文件无法被公网访问，导致预览组件无法使用。所以自己封装、实现了可以对 pdf、xls、xlsx、doc、docx 等文件格式预览的功能。- 在文件抓取的交互部分，由于用时较长，交互效果较差。使用了 QueueAnim 插件用动画的方式优化交互效果。- 在页面实现的过程中，发现频繁使用抽屉+表单的交互，所以封装了抽屉组件，并且支持扩展除表单外的其他组件搭配抽屉使用。- 在实现电子签名需求的时候，考虑到要配合接口、权限，多种页面交互等，封装了高阶组件。实现了快速给模块增加电子签名功能。代码变动量小，组件耦合性低。后续也很方便的应用于其他项目中。### TMS 项目**人工翻译系统**项目分为两个系统，一个是给客户使用的 TMS-client，另一个是给我们自己翻译团队使用的 TMS-pm。我负责给客户使用的 TMS-client 系统，以及 TMS-pm 系统的部分页面模块。实现了客户从下订单到订单完成的一整套工作流程生命周期。- 项目使用了 umi3 和 antd4 更新了原有代码，代码运行更高效快速。特别是表单相关部分。- 技术上遇见了一些问题，比如超过一个 G 的大文件上传，通过把文件转化为 blob 格式，使用 blob 的 slice 方法切割文件，使用 promise 方法发送并通知后端文件传送结束，实现了大文件分片上传。### 其他项目**药物警戒系统-PV** ：参与部分业务模块开发（审计追踪，信息管理，报告管理，统计分析等）- 在做统计分析遇到了 4 层数据嵌套的表格展示，涉及到单元格合并和导出 excel 的合并。在页面展示中用了 immer 调整数据结构，封装了导出 excel 组件，实现了对于合并单元格的数据导出。- 在做报告管理的过程中，业务要求要多个 tab 页面间共享数据，并且有暂存的功能。所以把 form 引用传入子组件配合各个页面的逻辑。实现了页面暂存和多 tab 页交互效果。  PV-saas：  参与原有 saas 的维护，由于增加新的产品的管理需求，原有项目无法实现。所以重做新 saas，可以实现后续产品快速融入 saas 管理中。  PV-gsk：  参与部分业务模块开发以及项目后期维护，开发过程中为匹配业务需求完成了大量的自定义校验，对用户操作不合规及时做出交互反馈。## 杭州博彦科技有限公司 - 蚂蚁金服外包（ 2018 年 7 月 ~ 2019 年 6 月 ）### 财富王者活动后台项目描述：支付宝财富王者活动(to C)需要一个管理后台(to B)来创建活动以及控制活动正常进行。我负责整个管理后台的部分。项 目 职 责 ：后台系统的开发及维护应 用 技 术 ：1. 使用蚂蚁内部框架“金蝉”进行快速开发，框架对接口、页面样式、页面逻辑分开统一管理，对工作效率有很大提升。2. 为了限制后台可操作人员及操作合理性而加入阿里权限系统，审批流。3. 为了实现多家企业活动内容的配置，开发了 repeat 组件，可以快速对 30 余企业活动的快速配置。### 蚂蚁金服基金自运营平台（财富号）项目描述：面向基金机构，银行，券商以及保险公司，帮助企业推出、营销产品。项目职责：对财富号迭代需求进行开发，主要涉及司南运营模块及服务管理模块。应用 技 术 ：1. 蚂蚁 chair 框架（融合 dva, saga, eggjs, react 等技术的 mvc 框架）。2. ui 框架主要使用 antd3. 使用 es6+，promise，async 等方法保证代码易维护性，避免回调地狱形成。4. 为了提高开发效率，使用 FromRender 框架，通过拖拽形式快速生成所需的 json-schema 数据结构，框架快速生成表单结构。并且在数据结构上与后端匹配的更好。 -->]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络协议</title>
    <link href="/2020/06/24/network-protocol/"/>
    <url>/2020/06/24/network-protocol/</url>
    
    <content type="html"><![CDATA[<h3 id="五层协议体系结构-物理层、数据链路层、网络层、运输层、应用层"><a href="#五层协议体系结构-物理层、数据链路层、网络层、运输层、应用层" class="headerlink" title="五层协议体系结构:物理层、数据链路层、网络层、运输层、应用层."></a>五层协议体系结构:物理层、数据链路层、网络层、运输层、应用层.</h3><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>物理层的主要任务是确定与传输媒体接口的特性.如机械特性、电气特性、功能特性、过程特性.</li><li>中继器：又叫转发器，功能是将信号整形放大再转发出去，以消除信号的失真和衰减，扩大网络传输的距离，其原理是信号再生，仅作用于电气部分，不管数据中是否有错误</li><li>集线器(HUB):实质上是多端口的中继器，也工作在物理层。一口接受数据信号，将其整形放大转发到其他所有(输入端除外)处于工作状态的端口上，多口输入，冲突-&gt;无效</li><li>码元:在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形.</li><li>几种通信:单工通信、半双工通信(双方交替)、全双工通信</li><li>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。</li><li>奈氏准则:在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能.</li><li>信道的极限信息传输速率 C : C = W log2(1+S/N) b/s ; W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。 ·</li><li>导引型传播媒体:双绞线(屏蔽、无屏蔽)、同轴电缆、光缆(单模光纤、双模光纤)、非导引型传输媒体:无线传输介质:无线电波、微波、红外线、激光.</li><li>频分复用:所有用户在同样的时间占用频率不同的带宽资源.</li><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙</li><li>波分复用：光的频分复用</li><li>码分复用:各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现</li><li>宽带接入技术:ADSL、HFC、FTTx</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li>数据链路层使用的信道:点对点信道 ppp 协议和广播信道.</li><li>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</li><li>一条链路只是一条通路的一个组成部分。数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li><li>数据链路的基本单位是帧.</li><li>数据链路层解决的三个问题是封装成帧、透明传输、差错控制</li><li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li><li>透明传输:原始数据中出现控制符如何转义.0 比特填充.</li><li>循环冗余检验 CRC:现在 k = 6, M = 101001。设 n = 3, 除数 P = 1101，被除数是 2nM = 101001000。 模 2 运算的结果是：商 Q = 110101，余数 R = 001。把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R 即：101001001，共 (k + n) 位。<br>在数据后面添加上的冗余码称为帧检验序列 FCS . CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法</li><li>CRC 不能实现可靠传输,需要确认和重传机制.</li><li>0 比特填充:连续五个 1 之后加入一个 0.</li><li>数据链路层的两个子层:逻辑链路控制 LLC (Logical Link Control)子层</li><li>媒体接入控制 MAC (Medium Access Control)子层.</li><li>通信适配器,也就是网卡,作用是:进行串行/并行转换。对数据进行缓存。在计算机的操作系统安装设备驱动程序。实现以太网协议。</li><li>CSMA/CD 协议: Carrier Sense Multiple Access with Collision Detection.“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。只能实现半双工通信.</li><li>退避算法:发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</li><li>在局域网中，硬件地址又称为物理地址，或 MAC 地址。</li><li>集线器的优缺点:使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信,扩大了局域网覆盖的地理范围.缺点是碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li><li>网桥:在数据链路层扩展局域网.根据 MAC 帧的目的地址对收到的帧进行转发.具有过滤帧的功能<br>网桥的优缺点: 过滤通信量。 扩大了物理范围。提高了可靠性。可互连不同物理层、不同 MAC 子层和不同速率（如 10 Mb/s 和 100 Mb/s 以太网）的局域网。缺点:存储转发增加了时延。 在 MAC 子层并没有流量控制功能。 具有不同 MAC 子层的网段桥接在一起时时延更大。网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</li><li>网桥和集线器的不同:集线器转发时不进行检查,而网桥会进行 CSMA/CD 算法.</li><li>透明网桥:“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。<br>在网桥的转发表中写入的信息除了地址和接口外，还有帧进入该网桥的时间。<br>避免产生转发的帧在网络中不断地兜圈子的方法是生成树.</li><li>以太网交换机:以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。<br>虚拟局域网:虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。<br>IP 协议.地址解析协议 ARP.(IP 地址-&gt;物理地址)逆地址解析协议 RARP.网际控制报文协议 ICMP.网际组管理协议 IGMP 都是网络层的协议,TCP、UDP 是运输层的协议.</li><li>中间设备又称为中间系统或中继(relay)系统。物理层中继系统：转发器(repeater)。数据链路层中继系统：网桥或桥接器(bridge)。网络层中继系统：路由器(router)。网桥和路由器的混合物：桥路器(brouter)。网络层以上的中继系统：网关(gateway)。</li><li>四类 IP 地址:A 类 0 开头网络号 8 位,主机号 24 位.B 类 10 开头网络号 16 位.C 类 110 开头网络号 24 位.D 类 1110 开头,多播地址.E 类 1111 开头,保留地址.</li><li>IP 分网络号和主机号:第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li><li>ARP:每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</li><li>ICMP:ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告.有两种报文种类:即 ICMP 差错报告报文和 ICMP 询问报文.Ping 和 Traceroute 指令通过 ICMP 协议,不经过 TCP 或者 UDP.</li><li>路由选择协议:内部网关协议 IGP( RIP 和 OSPF)和外部网关协议 EGP( BGP-4)</li><li>RIP:是一种分布式的基于距离向量的路由选择协议,每一个路由器都要维护从它自己到其他每一个目的网络的距离记录.RIP 允许一条路径最多只能包含 15 个路由器.</li><li>RIP 协议三个要点:仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li><li>RIP 的优缺点:优点:实现简单开销小,缺点是故障传输慢、网络规模小.</li><li>OSPF 协议:是分布式的链路状态协议.OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF 的三个要点:向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。<br>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。减少了整个网络上的通信量。<br>OSPF 的五种分组类型:问候、数据库描述、链路状态请求、链路状态更新、链路状态确认.<br>MTU(路径最大传输单元)</li><li>CIDR:无类别域间路由.缓解了地址枯竭的趋势；控制甚至缩减了路由表的开销<br>分配 IP 地址的时候不再以类别来分，而是按照可变长的地址块来分配.基于可变长子网掩码 VLSM.</li><li>拥塞控制:流量感知路由、准入控制、流量调节、负载丢弃、随机早期检测 RED.</li><li>流量整形:漏桶、令牌桶.</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul><li>应用进程之间的通信又称为端到端的通信。 运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。IP 协议提供主机之间的逻辑通信,而 TCP/UDP 提供进程之间的逻辑通信.</li><li>用户数据报协议 UDP 和 传输控制协议 TCP ,TCP 要提供可靠的、面向连接的运输服务.</li><li>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU .</li><li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能,不保证可靠交付，同时也不使用拥塞控制</li><li>TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供全双工通信。面向字节流。</li><li>TCP 连接的端点叫做套接字(socket)或插口。</li><li>ARQ:使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest), ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</li><li>连续 ARQ 和回退 NARQ.</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>DNS:同时使用 TCP 和 UDP:53<br>FTP:TCP:21<br>NFS:UDP<br>TFTP:UDP<br>TELNET:TCP:23<br>RPC:TCP<br>HTTP:TCP:80<br>SMTP:TCP:25,发邮件<br>POP3:TCP:110<br>IMAP:TCP<br>MIME:MIME 类型是一种通知客户端其接收文件的多样性的机制:<br>DHCP:UDP<br>SNMP:UDP<br>POP3 和 IMAP 的区别:POP3 协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的 3 封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。而 IMAP 提供 webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>http tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试相关</title>
    <link href="/2020/06/23/phone-interview/"/>
    <url>/2020/06/23/phone-interview/</url>
    
    <content type="html"><![CDATA[<p><a href="https://vevlins.github.io/2018/03/14/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">别人的博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>电话面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域</title>
    <link href="/2020/06/23/scope/"/>
    <url>/2020/06/23/scope/</url>
    
    <content type="html"><![CDATA[<h2 id="作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。"><a href="#作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。" class="headerlink" title="作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。"></a>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</h2><h3 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a>1. 全局作用域</h3><p>任何地方都能访问到的对象拥有全局作用域。<br>1.1 函数外面定义的变量拥有全局作用域<br>1.2 未定义直接赋值的变量自动声明为拥有全局作用域<br>1.3.window 对象的属性拥有全局作用</p><h3 id="2-局部作用域"><a href="#2-局部作用域" class="headerlink" title="2. 局部作用域"></a>2. 局部作用域</h3><p>函数内部的作用域为局部作用域</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。</p><p>1.当执行函数时，总是先从函数内部找寻局部变量</p><p>2.如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上</p><hr><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> bb = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">(bb)</span><span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">  bb = 2 ;</span></span><span class="hljs-function"><span class="hljs-comment">  alert(bb)</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">(bb)</span>;</span>alert(bb)<span class="hljs-comment">//  2,1</span><span class="hljs-keyword">var</span> bb = <span class="hljs-number">1</span> ;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">  alert(bb)</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-comment">// undefined</span></span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>作用域 作用域链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到页面渲染</title>
    <link href="/2020/06/18/hardcore-process/"/>
    <url>/2020/06/18/hardcore-process/</url>
    
    <content type="html"><![CDATA[<p>前言：不知道这玩意儿，前端也能干活。但是得进步啊。当学会了这玩意儿，对网络的理解会举头望明月，更上一层楼。<br>反正百利而无一害。嘿嘿，开始整活～</p><p>第一步，手放在键盘上敲出 url，然后回车，咔哒一敲！然后页面就出来了，是不是很简单～ 😁<br>让我们的学习气氛轻松起来～ 下面正式开始，我敲个 url：</p><p><a href="https://onepunchx.github.io/archives/" target="_blank" rel="noopener">https://onepunchx.github.io/archives/</a></p><h2 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h2><p>输入完这个网址，敲回车！浏览器做的第一件事是 解析这个 url：</p><ol><li><strong>通过 <em>DNS_（domain name system） 把域名（domain name）解析程 _IP</em> 地址</strong></li></ol><p>IP 地址这玩意儿，就相当于我们每个人的身份证号码，身份证号可以唯一、精准的匹配到一个人，那么 IP 地址就可以唯一、精准的匹配到对应的计算机。<br>但是身份证号码这玩意，你能记住几个？能记住自己的就不错了，通常你记住的都是别人的名字，那么这个域名/网址/URL 就相当于计算机的名字<br>形象一点的对应关系如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><ol start="2"><li><strong>然后应用曾生成 HTTP 请求报文</strong><br>啥是请求报文？<br>请求报文 有起始行 首部 和 主体部分，说起来太不形象具体了，直接上代码！</li></ol><p>GET <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> HTTP/1.1 （起始行）</p><p>Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>Connection: keep-alive<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8<br>X-Client-Data: CKm1yQEIhbbJAQijtskBCMG2yQEIqZ3KAQioo8oB<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8<br>（首部）</p><p>然后是主体内容，get 请求的主体内容为空，post 的请求主体内容就是请求体，body 里面的内容</p><p>这个 http 请求报文说起来里面学问很大，有机会的话单独写一次。这里给自己先挖个坑。。。</p><ol start="3"><li><p><strong>传输层建立 TCP 连接</strong><br>3 次握手，4 次挥手。<br>这里不细说，等待后续填坑</p></li><li><p><strong>网络层使用 IP 协议来选择路线</strong><br>处理来自传输层的数据段 segment，将数据段 segment 装入数据包 packet，填充包头，主要就是添加源和目的 IP 地址，然后发送数据。在数据传输的过程中，IP 协议负责选择传送的路线，称为路由功能</p></li><li><p><strong>数据链路层实现网络相邻结点间可靠的数据通信</strong><br>　　为了保证数据的可靠传输，把数据包 packet 封装成帧(Frame)，并按顺序传送各帧。由于物理线路的不可靠，发出的数据帧有可能在线路上出错或丢失，于是为每个数据分块计算出 CRC(循环冗余检验)，并把 CRC 添加到帧中，这样接收方就可以通过重新计算 CRC 来判断数据接收的正确性。一旦出错就重传</p></li></ol><p>将数据包 packet 封装成帧(Frame)，包括帧头和帧尾。帧尾是添加被称做 CRC 的循环冗余校验部分。帧头主要是添加数据链路层的地址，即数据链路层的源地址和目的地址，即网络相邻结点间的源 MAC 地址和目的 MAC 地址</p><ol start="6"><li><p><strong>数据链路层的帧(Frame)转换成二进制形式的比特(Bit)流，从网卡发送出去，再把比特转换成电子、光学或微波信号在网络中传输</strong><br>光纤，电缆啥的这时候就派上用场啦</p></li><li><p><strong>服务器处理</strong><br>通俗来说，就是先弄清楚浏览器需要什么，然后找到相关数据，然后封装这些数据，然后准备传回去。打个比方，如果我们输入了百度的网址<br><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>那么这里服务器就会把百度的首页的 html 给浏览器传过去</p></li><li><p><strong>服务器处理完事，给浏览器传回去，跟传过来的时候差不多</strong></p></li><li><p><strong>浏览器渲染</strong><br>这时候你的电脑就接收到了服务器传过来的数据，然后经过处理，准备渲染，这个过程里呢就是遇见了 html 里面需要啥，就发请求获取啥。<br>比如说<br>浏览器开始载入 html 代码，发现<head>标签内有一个<link>标签引用外部 CSS 文件<br>浏览器又发出 CSS 文件的请求，服务器返回这个 CSS 文件<br>浏览器继续载入 html 中<body>部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了<br>浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。<br>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。<br>浏览器发现了一个包含一行 Javascript 代码的 script 标签，赶快运行它。<br>Javascript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 style（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。<br>就这样，浏览器吭呲瘪肚的终于把页面鼓捣出来了！</p></li></ol><p>这就是整个过程啦，大概就是这么回事～</p><p><strong>页面渲染需要做这些事</strong></p><ul><li>解析 html，创建 dom 树</li><li>解析 css ， 给页面美容</li><li>解析 js ，给页面交互响应</li></ul><h3 id="ext-重绘和回流"><a href="#ext-重绘和回流" class="headerlink" title="ext 重绘和回流"></a>ext 重绘和回流</h3><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><p>回流是指窗口尺寸被修改、发生滚动操作，或者元素位置相关属性被更新时会触发布局过程，在布局过程中要计算所有元素的位置信息。<br>（尺寸长宽高改变，显隐就会回流啦）<br>由于 HTML 使用的是流式布局，如果页面中的一个元素的尺寸发生了变化，则其后续的元素位置都要跟着发生变化，也就是重新进行流式布局的过程，所以被称之为回流</p><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>重绘是指当与视觉相关的样式属性值被更新时会触发绘制过程，在绘制过程中要重新计算元素的视觉信息，使元素呈现新的外观<br>当一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。</p><p>回流一定重绘，重绘不一定回流。<br>只有颜色改变的时候就只会发生重绘而不会引起回流<br>当页面布局和几何属性改变时就需要回流<br>比如：添加或者删除可见的 DOM 元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</p><p>下面列举一些减少回流次数的方法（来自百度）</p><p>（1）不要一条一条地修改 DOM 样式，而是修改 className 或者修改 style.cssText</p><p>（2）在内存中多次操作节点，完成后再添加到文档中去</p><p>（3）对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示</p><p>（4）在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中</p><p>（5）不要使用 table 布局，因为一个小改动可能会造成整个 table 重新布局。而且 table 渲染通常要 3 倍于同等元素时间</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>DNS 解析 URL 地址</li><li>生成 HTTP 请求报文</li><li>构建 TCP 连接</li><li>使用 IP 协议选择传输路线</li><li>数据链路层保证数据的可靠传输</li><li>物理层将数据转换成电子、光学或微波信号进行传输</li><li>服务器处理数据，并返回浏览器所需资源</li><li>浏览器处理数据</li><li>页面渲染</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>http tcp 重绘回流 DNS IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 合成事件</title>
    <link href="/2020/06/17/react-syntheticevent/"/>
    <url>/2020/06/17/react-syntheticevent/</url>
    
    <content type="html"><![CDATA[<p>这个不是很重要，而且想真弄懂，得看源码。我看的是一头雾水。但是大概思路可以表达出来</p><h3 id="React-合成事件一套机制：React-并不是将-click-事件直接绑定在-dom-上面，而是采用事件冒泡的形式冒泡到-document-上面，当事件发生并冒泡至-document-处时，React-将事件内容封装交给中间层-SyntheticEvent（负责所有事件合成），然后-React-将事件封装给正式的函数处理运行和处理。"><a href="#React-合成事件一套机制：React-并不是将-click-事件直接绑定在-dom-上面，而是采用事件冒泡的形式冒泡到-document-上面，当事件发生并冒泡至-document-处时，React-将事件内容封装交给中间层-SyntheticEvent（负责所有事件合成），然后-React-将事件封装给正式的函数处理运行和处理。" class="headerlink" title="React 合成事件一套机制：React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SyntheticEvent（负责所有事件合成），然后 React 将事件封装给正式的函数处理运行和处理。"></a>React 合成事件一套机制：React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SyntheticEvent（负责所有事件合成），然后 React 将事件封装给正式的函数处理运行和处理。</h3><p>为啥有这种 react 合成事件 这种东西？ 存在即合理。<br>如果 dom 上绑定了特别多的事件处理函数，那指定会卡。为了不会卡，所以有了这个 react 合成事件，并且对浏览器兼容性，不用担心 ie 的坑了。</p><h3 id="注意：React-事件和原生事件最好不要混用。原生事件中如果执行了-stopPropagation-方法，则会导致其他-React-事件失效。因为所有元素的事件将无法冒泡到-document-上，导致所有的-React-事件都将无法被触发。"><a href="#注意：React-事件和原生事件最好不要混用。原生事件中如果执行了-stopPropagation-方法，则会导致其他-React-事件失效。因为所有元素的事件将无法冒泡到-document-上，导致所有的-React-事件都将无法被触发。" class="headerlink" title="注意：React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。"></a>注意：React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。</h3><p>下面留个链接，是大佬分析源码的东西。<br><a href="https://zhuanlan.zhihu.com/p/25883536" target="_blank" rel="noopener">点击跳转</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>react合成事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>event.stopPropagation()和event.preventDefault()</title>
    <link href="/2020/06/17/stoppropagation-preventDefault/"/>
    <url>/2020/06/17/stoppropagation-preventDefault/</url>
    
    <content type="html"><![CDATA[<h3 id="硬核整活。就-3-个玩意儿："><a href="#硬核整活。就-3-个玩意儿：" class="headerlink" title="硬核整活。就 3 个玩意儿："></a>硬核整活。就 3 个玩意儿：</h3><ol><li><p>event.stopPropagation() 阻止冒泡</p></li><li><p>event.preventDefault() 阻止默认事件</p></li><li><p>return false 同时阻止冒泡和默认事件</p></li></ol><h3 id="阻止事件冒泡，能咋滴？"><a href="#阻止事件冒泡，能咋滴？" class="headerlink" title="阻止事件冒泡，能咋滴？"></a>阻止事件冒泡，能咋滴？</h3><p>el.addEventListener(”click“,function(){console.log(‘xxx’)},false) 接受第二个参数是个回调函数吧？函数里有操作吧，有干活吧？<br>这个阻止冒泡，就阻止这个回调函数干活。说的是冒泡奥，捕获不阻止的奥。</p><h3 id="阻止默认事件，能咋滴？"><a href="#阻止默认事件，能咋滴？" class="headerlink" title="阻止默认事件，能咋滴？"></a>阻止默认事件，能咋滴？</h3><p>首先你得知道啥是默认事件，你知不知道？<br>不知道我告诉你呗，反正也是我百度的。职业复制粘贴工程师，给你复制一下：<br>就是浏览器通过 HTML 标签或 DOM 元素提供的一些功能性的默认行为。<br>比如在 a 标签 href 属性上的跳转，右键呼出的菜单，当你在一个 form 表单里点击提交按钮时网页会产生提交行为并刷新网页，当你网页上滚动鼠标滚轮时，网页的滚动条会动。<br>阻止默认事件就能阻止类似这些事</p><h3 id="同时阻止，能咋滴？"><a href="#同时阻止，能咋滴？" class="headerlink" title="同时阻止，能咋滴？"></a>同时阻止，能咋滴？</h3><p>不能咋滴，你 return false 🐂🍺</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就这两行玩意，不总结了奥。</p>]]></content>
    
    
    
    <tags>
      
      <tag>阻止事件冒泡 阻止默认事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dom0-dom2</title>
    <link href="/2020/06/15/dom0-dom2/"/>
    <url>/2020/06/15/dom0-dom2/</url>
    
    <content type="html"><![CDATA[<h2 id="dom0"><a href="#dom0" class="headerlink" title="dom0"></a>dom0</h2><p>或者叫 0 级 dom ，如下</p><pre><code class="hljs scilab">&lt;input id=<span class="hljs-string">"btn"</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> onclick=<span class="hljs-string">"console.log('</span>You clicked the button!<span class="hljs-string">');"</span> value=<span class="hljs-string">"Click"</span> /&gt;<span class="hljs-comment">//  或者js写法</span>document.getElementById(<span class="hljs-string">'btn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;</span>            console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Ｉ　am ｐｒｏｃｅｓｓｅｄ by dom0!'</span>);        &#125;;</code></pre><h3 id="这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。"><a href="#这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。" class="headerlink" title="这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。"></a>这种写法，后面的代码会覆盖前面的，也就是说如果多次输出，也只会输出最后一条。</h3><h2 id="dom2"><a href="#dom2" class="headerlink" title="dom2"></a>dom2</h2><p>或者叫 2 级 dom，继续如下呗</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'input'</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert('haha')"</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'fff'</span>)</span><span class="actionscript">     &#125;; <span class="hljs-comment">// 目标阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'mmm'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// 捕获阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'ooooo'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// 捕获阶段</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'pppp'</span>)</span><span class="actionscript">     &#125;, <span class="hljs-literal">false</span>)  <span class="hljs-comment">// 冒泡阶段</span></span><span class="actionscript">     <span class="hljs-comment">// 兼容低版本IE的写法</span></span><span class="javascript">     <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input'</span>).attachEvent(<span class="hljs-string">"onclick"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript">         alert(<span class="hljs-string">'pppp'</span>)</span>     &#125;); <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // mmm ooooo fff pppp</code></pre><p>dom2 把事情分为 3 步 ———— 事件捕获阶段、处于目标阶段和事件冒泡阶段</p><pre><code class="hljs actionscript">addEventListener(<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;&#125;,<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>)<span class="hljs-comment">// 第一个参数，表明是啥触发事件</span><span class="hljs-comment">// 第二个参数，事件触发以后的回调函数</span><span class="hljs-comment">// 第三个参数，true或者false ，true是第二个参数那个回调函数在捕获阶段调用 ，false在冒泡阶段 ，默认是false</span><span class="hljs-comment">// 2015年底，扩展了第三个参数</span>el.addEventListener(type, listener, &#123;    capture: <span class="hljs-literal">false</span>, <span class="hljs-comment">// useCapture</span>    once: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// 是否设置单次监听</span>    passive: <span class="hljs-literal">false</span>  <span class="hljs-comment">// 是否让阻止默认行为preventDefault()失效</span>    <span class="hljs-comment">//  由于 touchmove 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止。那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。当设置了passive为true，则会忽略代码中的preventDefault(), 因此页面会变得更流畅</span>&#125;)</code></pre><p>window =&gt; document =&gt; body =&gt; div 捕获</p><p>div =&gt; body =&gt; document =&gt; window 冒泡</p><h3 id="这种写法，不会覆盖，会依次输出所有项"><a href="#这种写法，不会覆盖，会依次输出所有项" class="headerlink" title="这种写法，不会覆盖，会依次输出所有项"></a>这种写法，不会覆盖，会依次输出所有项</h3><p>顺便提一嘴 dom3 ，增加了更多的事件类型，比如：<br>       DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，全部类型如下：</p><p>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</p><p>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</p><p>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</p><p>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</p><p>文本事件，当在文档中输入文本时触发，如：textInput</p><p>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</p><p>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</p><p>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</p><p>同时 DOM3 级事件也允许使用者自定义一些事件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>区别：dom0 会覆盖，dom2 不会覆盖。</p>]]></content>
    
    
    
    <tags>
      
      <tag>dom0 dom2 、</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高阶函数</title>
    <link href="/2020/06/15/higher-order-function/"/>
    <url>/2020/06/15/higher-order-function/</url>
    
    <content type="html"><![CDATA[<h2 id="可以接收另一个参数作为参数的函数，就叫做高阶函数。"><a href="#可以接收另一个参数作为参数的函数，就叫做高阶函数。" class="headerlink" title="可以接收另一个参数作为参数的函数，就叫做高阶函数。"></a>可以接收另一个参数作为参数的函数，就叫做高阶函数。</h2><h3 id="常见高阶函数"><a href="#常见高阶函数" class="headerlink" title="常见高阶函数"></a>常见高阶函数</h3><ol><li>Array.prototype.map,</li><li>Array.prototype.filter,</li><li>Array.prototype.reduce,</li></ol><p>既然提到了这几个数组方法，那也就顺便说一说哈</p><ul><li>map 是啥，就不在这里说了，不知道就百度去。map() 方法的回调函数接受 3 个参数。 item index arraySelf 。 item 是数组的每一个元素 ，index 是该元素的下标（数组中的第几个元素），arraySelf 是调用 map 方法的这个数组，当然了，这些参数不是固定叫 item，index 啥的，这是入参，叫啥都行，位置对的上相应的位置就行。比如：</li></ul><pre><code class="hljs stata">[1,2,3].map((<span class="hljs-keyword">one</span>,<span class="hljs-keyword">two</span>,three)=&gt;&#123;  <span class="hljs-comment">// 这里的one就对应上面我说的item ，two就是index，这样说就能明白吧？</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">one</span> + <span class="hljs-keyword">two</span> + three.length&#125;)</code></pre><p>map 有返回值，会返回一个新的数组，而类似的 forEach（）方法，就没有返回值，所以哟，用 forEach 的时候经常会搭配 Array.push() 😁 还有啊，写 jsx 的时候，map 遍历出来的玩意你得加个 key 值，通常可以是 index，比如哈，我举个栗子 🌰</p><pre><code class="hljs javascript">&lt;ul&gt;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span> = <span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&#123;item&#125;</span> &gt;</span>item<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>&#125;)&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><p>这玩意写的好像有点多余。。。好像会 map 的都能知道，不会 map 看了我这也看不懂。😂</p><pre><code class="hljs angelscript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].filter(item=&gt;item &gt; <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].reduce((x,y)=&gt;&#123;<span class="hljs-keyword">return</span> x + y&#125;)</code></pre><p>react-redux</p><p>connect 方法 嘻嘻 弄一波这个～</p><p>connect 方法做的事情是将 state 和 dispatch 绑定到 Connect 组件的参数上，然后 Connect 组件将你当前的 App 组件封装起来，使得 App 组件可以通过 props 获取到父组件 Connect 传递的 state 和 props。</p><p>这也就是为什么你可以在自己写的组件上面直接通过 this.props 访问到 state 和 action。有的人是通过 store 去读取 state 和 dispatch action，也是一样的道理。</p><p>从 connect 方法的实现，我们看到了非常多 react 组件的影子，生命周期，props 传递，context 上下文。</p><p>对比 Provider 组件：</p><p>Provider 是顶层组件的作用，将 store 作为上下文提供给全局共享，而 Connect 组件是局部组件，将某个 react 组件包装起来，传递指定的 state 和 props 给该组件访问。</p><h3 id="非常遗憾，我没有彻底看懂-connect-的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解"><a href="#非常遗憾，我没有彻底看懂-connect-的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解" class="headerlink" title="非常遗憾，我没有彻底看懂 connect 的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解"></a>非常遗憾，我没有彻底看懂 connect 的源码，所以暂时不写什么感想了，留个链接后续再试试继续理解</h3><p><a href="https://www.cnblogs.com/williamjie/p/9591826.html" target="_blank" rel="noopener">这是别人博客，connect 解析源码的</a></p><h4 id="发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个-480-行的源码还是不明白具体咋回事。"><a href="#发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个-480-行的源码还是不明白具体咋回事。" class="headerlink" title="发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个 480 行的源码还是不明白具体咋回事。"></a>发现了另一个博客，简化版的，大概的逻辑就看懂了，但是那个 480 行的源码还是不明白具体咋回事。</h4><pre><code class="hljs kotlin">export <span class="hljs-keyword">default</span> function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;) &#123;<span class="hljs-keyword">return</span> function wrapWithConnect(WrappedComponent) &#123;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connect</span> <span class="hljs-title">extends</span> <span class="hljs-title">Component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(props, context) &#123;      <span class="hljs-comment">// 从祖先Component处获得store</span>      <span class="hljs-keyword">this</span>.store = props.store || context.store      <span class="hljs-keyword">this</span>.stateProps = computeStateProps(<span class="hljs-keyword">this</span>.store, props)      <span class="hljs-keyword">this</span>.dispatchProps = computeDispatchProps(<span class="hljs-keyword">this</span>.store, props)      <span class="hljs-keyword">this</span>.state = &#123; storeState: <span class="hljs-literal">null</span> &#125;      <span class="hljs-comment">// 对stateProps、dispatchProps、parentProps进行合并</span>      <span class="hljs-keyword">this</span>.updateState()    &#125;    shouldComponentUpdate(nextProps, nextState) &#123;      <span class="hljs-comment">// 进行判断，当数据发生改变时，Component重新渲染</span>      <span class="hljs-keyword">if</span> (propsChanged || mapStateProducedChange || dispatchPropsChanged) &#123;        <span class="hljs-keyword">this</span>.updateState(nextProps)          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;      &#125;      componentDidMount() &#123;        <span class="hljs-comment">// 改变Component的state</span>        <span class="hljs-keyword">this</span>.store.subscribe(() = &#123;          <span class="hljs-keyword">this</span>.setState(&#123;            storeState: <span class="hljs-keyword">this</span>.store.getState()          &#125;)        &#125;)      &#125;      render() &#123;        <span class="hljs-comment">// 生成包裹组件Connect</span>        <span class="hljs-keyword">return</span> (          &lt;WrappedComponent &#123;...<span class="hljs-keyword">this</span>.nextState&#125; /&gt;        )      &#125;    &#125;    Connect.contextTypes = &#123;      store: storeShape    &#125;    <span class="hljs-keyword">return</span> Connect;  &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>高阶函数 react-redux connect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端路由</title>
    <link href="/2020/06/11/router-hash-history/"/>
    <url>/2020/06/11/router-hash-history/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是前端路由？"><a href="#什么是前端路由？" class="headerlink" title="什么是前端路由？"></a>什么是前端路由？</h2><p>路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p><h2 id="如何实现前端路由？"><a href="#如何实现前端路由？" class="headerlink" title="如何实现前端路由？"></a>如何实现前端路由？</h2><p>要实现前端路由，需要解决两个核心问题：</p><p>1.如何改变 URL 却不引起页面刷新？ 2.如何检测 URL 变化了？</p><h3 id="hash-实现"><a href="#hash-实现" class="headerlink" title="hash 实现"></a>hash 实现</h3><p>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新<br>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过标签改变 URL、通过 window.location 改变 URL，这几种情况改变 URL 都会触发 hashchange 事件</p><h3 id="history-实现"><a href="#history-实现" class="headerlink" title="history 实现"></a>history 实现</h3><p>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新<br>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过 pushState/replaceState 或标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState 的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</p><h2 id="hash-实现（简略版）"><a href="#hash-实现（简略版）" class="headerlink" title="hash 实现（简略版）"></a>hash 实现（简略版）</h2><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">ref=""&gt;    <span class="hljs-comment">&lt;!-- 定义路由 --&gt;</span></span><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/home"</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/about"</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>ref=<span class="hljs-string">""</span>&gt;    &lt;!-- 渲染路由对应的 UI --&gt;    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"routeView"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  &lt;/ul&gt;&lt;/body&gt;// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件<span class="hljs-keyword">window</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, onLoad)// 监听路由变化<span class="hljs-keyword">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, onHashChange)// 路由视图var routerView = null<span class="hljs-keyword">function</span> onLoad () &#123;  routerView =<span class="hljs-built_in"> document</span>.querySelector(<span class="hljs-string">'#routeView'</span>)  onHashChange()&#125;// 路由变化时，根据路由渲染对应 UI<span class="hljs-keyword">function</span> onHashChange () &#123;  <span class="hljs-keyword">switch</span> (location.hash) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">'#/home'</span>:      routerView.innerHTML = <span class="hljs-string">'Home'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">case</span> <span class="hljs-string">'#/about'</span>:      routerView.innerHTML = <span class="hljs-string">'About'</span>      <span class="hljs-keyword">return</span>    default:      <span class="hljs-keyword">return</span>  &#125;&#125;</code></pre><h2 id="history-实现（简略版）"><a href="#history-实现（简略版）" class="headerlink" title="history 实现（简略版）"></a>history 实现（简略版）</h2><pre><code class="hljs php">&lt;body&gt;  &lt;ul&gt;    &lt;li&gt;&lt;a href=<span class="hljs-string">'/home'</span>&gt;home&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=<span class="hljs-string">'/about'</span>&gt;about&lt;/a&gt;&lt;/li&gt;    &lt;div id=<span class="hljs-string">"routeView"</span>&gt;&lt;/div&gt;  &lt;/ul&gt;&lt;/body&gt;<span class="hljs-comment">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span>window.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, onLoad)<span class="hljs-comment">// 监听路由变化</span>window.addEventListener(<span class="hljs-string">'popstate'</span>, onPopState)<span class="hljs-comment">// 路由视图</span><span class="hljs-keyword">var</span> routerView = <span class="hljs-keyword">null</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLoad</span> <span class="hljs-params">()</span> </span>&#123;  routerView = document.querySelector(<span class="hljs-string">'#routeView'</span>)  onPopState() href=<span class="hljs-string">""</span>&gt;  <span class="hljs-comment">// 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。</span>  <span class="hljs-keyword">var</span> linkList = document.querySelectorAll(<span class="hljs-string">'a[href]'</span>)  linkList.<span class="hljs-keyword">forEach</span>(el =&gt; el.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>&#123;    e.preventDefault()    history.pushState(<span class="hljs-keyword">null</span>, <span class="hljs-string">''</span>, el.getAttribute(<span class="hljs-string">'href'</span>))    onPopState()  &#125;))&#125;<span class="hljs-comment">// 路由变化时，根据路由渲染对应 UI</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onPopState</span> <span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">switch</span> (location.pathname) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">'/home'</span>:      routerView.innerHTML = <span class="hljs-string">'Home'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">case</span> <span class="hljs-string">'/about'</span>:      routerView.innerHTML = <span class="hljs-string">'About'</span>      <span class="hljs-keyword">return</span>    <span class="hljs-keyword">default</span>:      <span class="hljs-keyword">return</span>  &#125;&#125;</code></pre><h2 id="总结：前端路由，在-SPA-单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。"><a href="#总结：前端路由，在-SPA-单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。" class="headerlink" title="总结：前端路由，在 SPA 单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。"></a>总结：前端路由，在 SPA 单页面应用中，非常重要。路由对应组件渲染，不用发请求。远古时代路由跳转可是要发请求，后端返回页面的鸭。。。</h2>]]></content>
    
    
    
    <tags>
      
      <tag>前端路由 Hash History</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS模块化的发展历程</title>
    <link href="/2020/06/10/commonjs-amd-cmd/"/>
    <url>/2020/06/10/commonjs-amd-cmd/</url>
    
    <content type="html"><![CDATA[<p><strong>随便写点 js 模块化发展历史，面试有问这玩意的，随便看看到时候能答出来几句就 ok，顺便咱也了解一下 js 的这方面历史。</strong></p><p>1.js 的诞生：由 Brendan Eich 花了不到十天时间发明，用来在网页上进行表单校验、实现简单的动画效果等等，你可以回想一下那个网页上到处有公告块飘来飘去的时代。<br>2.2006 年 ajax 出现，js 开始发展。全局变量开始让人头疼了，函数命名开始冲突了 3.所以 js 需要，也必须要整模块化</p><p>需要解决的问题是：</p><ul><li>如何安全的包装一个模块的代码？（不污染模块外的任何代码）</li><li>如何唯一标识一个模块？</li><li>如何优雅的把模块的 API 暴漏出去？（不能增加全局变量）</li><li>如何方便的使用所依赖的模块？</li></ul><p>2009 年，node.js 诞生，这下模块化必须马上整了，要不然服务端没法弄了 所以 当当当当～ CommonJs 闪亮登场</p><h2 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h2><p>简单来说呢，commonJs 就是，exports 暴露 API，require 引入该 API 的模块，</p><p>缺点，得发请求啊 这玩意就不太好了</p><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>异步加载所需的模块，然后在回调函数中执行主逻辑。</p><p>缺点：预先下载太多东西，而且定义模块的时候写法复杂，最重要的是，它实时下载代码然后触发回调，主体代码运行。用户会有卡顿感。</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>淘宝前端 玉伯 整出来的，融各家所长，没啥缺点</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>2015 年 6 月，es6 来了，export 暴露，import 引入，编译时加载（静态加载）</p><h2 id="总结，就这点内容，还总结啥？告辞～"><a href="#总结，就这点内容，还总结啥？告辞～" class="headerlink" title="总结，就这点内容，还总结啥？告辞～"></a>总结，就这点内容，还总结啥？告辞～</h2>]]></content>
    
    
    
    <tags>
      
      <tag>CommonJs AMD CMD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包，老铁安排上</title>
    <link href="/2020/06/09/bi-bao/"/>
    <url>/2020/06/09/bi-bao/</url>
    
    <content type="html"><![CDATA[<p>呱呱，啥是闭包？<br>天天写闭包，但是让表达出来，还真有点懵住了，<br>这玩意我都记在心里，话说不出口，都在酒里了，干杯～</p><hr><h3 id="闭包是啥？"><a href="#闭包是啥？" class="headerlink" title="闭包是啥？"></a>闭包是啥？</h3><p>来几个官方回答，可以应付面试</p><ul><li>闭包是一个有自己环境的函数，并且在该环境中至少有一个变量。</li><li>闭包是将函数与其引用的周边状态绑定在一起形成（封装）的组合</li><li>闭包函数是声明在一个函数中的函数</li><li>闭包是内部函数总是可以访问其所在的外部函数中生命的参数和变量，即使在其外部函数被返回以后</li></ul><h3 id="闭包特点（优缺点都有哈）"><a href="#闭包特点（优缺点都有哈）" class="headerlink" title="闭包特点（优缺点都有哈）"></a>闭包特点（优缺点都有哈）</h3><ul><li><p>让外部访问函数内部变量成为可能；</p></li><li><p>局部变量会常驻在内存中；</p></li><li><p>可以避免使用全局变量，防止全局变量污染；(不用担心变量名重复，不过都 2020 年了，谁还频繁用 var 声明变量啊。)</p></li><li><p>会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p><p>闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。<strong>每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。</strong>但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。所以啊，当有很多很多闭包的时候，或者闭包被调用很多很多次的时候，那么就会内存泄漏了。</p></li></ul><p><em>然后面试的时候，可能会遇见一些笔试题，面试官整一个函数，让你写输出的值，设计个圈套坑你，怎么办？不慌！有秘诀～</em></p><p><strong>秘诀在此：输出的就是同一个地址中的爸爸函数中的变量值</strong></p><p>如此简单粗暴的秘诀，喜欢吗？</p><p>光说不练假把式，下面我来表演绝活：举个栗子 🌰</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funA</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// funA的活动对象之中;</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">//匿名函数的活动对象;</span>        alert(a);  &#125;&#125;<span class="hljs-keyword">var</span> b = funA();b();<span class="hljs-comment">// 10</span></code></pre><p>由浅入深，先从这个简单的开始，套入秘诀，<em>同一个地址中的爸爸函数中的变量值</em> 啥叫同一个地址呢，就是被同一个人调用，在这个栗子里面，就是这个：</p><p>var b = funA（）<br>b()</p><p>这个 b 就是个地址，如果多一个 var c = funA（） 然后调用 c（），那么这个 c 就是另一个地址。</p><p>地址就明白了吧～<br>然后找爸爸，爸爸的爸爸叫什么，爸爸的的爸爸叫爷爷。。。哈哈 ，皮一下</p><p>回到找爹的正事上来，alert（a）是儿子，他爸在外边包住了它，就是这个 funA 是它爸。也可以理解为怀孕的母亲，和肚子里的孩子。（谁在里面谁儿子）</p><p>所以找到了它爸爸里面的变量 a=10 ，所以输出 10</p><p>好的，很开心，我们看下一个栗子 🌰</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zhujunFn</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xcolaFn</span>(<span class="hljs-params"></span>)</span>&#123;      i++;      <span class="hljs-built_in">console</span>.log(i);  &#125;  <span class="hljs-keyword">return</span> xcolaFn;&#125;<span class="hljs-keyword">var</span> aaa = zhujunFn();  <span class="hljs-comment">//每次外部函数执行的时候,外部函数的地址不同，都会重新创建一个新的地址,这个aaa是个新的地址</span>aaa();aaa();aaa();<span class="hljs-keyword">var</span> bbb = zhujunFn();  <span class="hljs-comment">//  所以这也是一个新的地址，aaa和bbb 是两个不同的地址</span>bbb();bbb();bbb();<span class="hljs-comment">// 1 2 3 1 2 3</span></code></pre><p>先重复一下我们的秘诀，然后找爹</p><ul><li><p><em>同一个地址中的爸爸函数中的变量值</em></p><p>aaa 和 bbb 分别是两个地址，是独立的</p><p>然后给这个 <strong>xcolaFn</strong> 找爹，是外边这个 <strong>zhujunFn</strong>，然后找到里面的这个变量 i，每次调用 aaa（）输出 i 为 1，2，3</p><p>每次调用 bbb（）是新的地址，独立的，所以也是一样的道理 输出 i 为 1，2，3</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我没啥想总结了，有营养的都在上边了，如果看完了发现还是不太明白，那一定是我没说清楚，不怪你，那就再看看这个人对闭包的理解吧，会有帮助的<br>链接在此：<a href="http://blog.xcola.top/2018/05/23/%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">请点击这里</a></p><p><strong>冲鸭，奥利给</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js事件循环机制</title>
    <link href="/2020/06/08/event-loop/"/>
    <url>/2020/06/08/event-loop/</url>
    
    <content type="html"><![CDATA[<ul><li>js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。</li><li>这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）</li></ul><ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li><li>如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行</li></ul><h5 id="看不懂没关系，先往下看，回过头来就理解这些了，老铁！"><a href="#看不懂没关系，先往下看，回过头来就理解这些了，老铁！" class="headerlink" title="看不懂没关系，先往下看，回过头来就理解这些了，老铁！"></a>看不懂没关系，先往下看，回过头来就理解这些了，老铁！</h5><h3 id="js-中的异步操作"><a href="#js-中的异步操作" class="headerlink" title="js 中的异步操作"></a>js 中的异步操作</h3><ul><li>setTimeOut</li><li>setInterval</li><li>ajax</li><li>promise</li><li>I/O</li></ul><h3 id="同步任务-异步任务"><a href="#同步任务-异步任务" class="headerlink" title="同步任务 - 异步任务"></a>同步任务 - 异步任务</h3><ul><li>同步任务是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务</li><li>异步任务 不进入主线程，而是进入 任务队列 ，只有 任务队列 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务 - 微任务"></a>宏任务 - 微任务</h3><ul><li>宏任务：整体代码 script/setTimeOut 等（new Promise 会进入主线程立刻执行，是主线程任务）</li><li>微任务：promise.then/promise.nextTick (node)</li></ul><hr><p>举个栗子</p><pre><code class="hljs fortran">console.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)setTimeOut(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)&#125;,<span class="hljs-number">0</span>)console.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)</code></pre><p>执行结果 1 3 2</p><p><strong>因为 setTimeOut 是异步任务，所以哪怕是 0 秒等待，也会等主线程任务都完事了以后才执行，下边是详细解析</strong></p><p>1.console.log(1)是同步任务，直接打印 1；</p><p>2.setTimeout 是异步任务，且是宏函数，放到宏函数队列中，等待下次 Event Loop 才会执行；</p><p>3.console.log(3)是同步任务，直接打印 3；</p><p>4.主线程执行完毕，没有微任务，那么执行第二个宏任务 setTimeout，打印 2；</p><p>5.结果：1，3，2</p><p><strong>也就是说，如果有 promise，那是同步任务，等所有同步任务完事，开始执行这个 promise.then，再然后才是 setTimeOut 啥的。</strong></p><hr><p>举个栗子</p><pre><code class="hljs lisp">setTimeout(<span class="hljs-name">function</span>()&#123;    console.log(<span class="hljs-number">1</span>)&#125;)<span class="hljs-comment">;</span>new Promise(<span class="hljs-name">function</span>(<span class="hljs-name">resolve</span>)&#123;    console.log(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>    for(<span class="hljs-name">var</span> i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10000; i++)&#123;</span>        i == <span class="hljs-number">9999</span> <span class="hljs-symbol">&amp;&amp;</span> resolve()<span class="hljs-comment">;</span>    &#125;&#125;).then(<span class="hljs-name">function</span>()&#123;    console.log(<span class="hljs-number">3</span>)&#125;)<span class="hljs-comment">;</span>console.log(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span></code></pre><p>输出 2 ， 4 ， 3， 1</p><p>1.setTimeout 是异步，且是宏函数，放到宏函数队列中；</p><p>2.new Promise 是同步任务，直接执行，打印 2，并执行 for 循环；</p><p>3.promise.then 是微任务，放到微任务队列中；</p><p>4.console。log(4)同步任务，直接执行，打印 4；</p><p>5.此时主线程任务执行完毕，检查微任务队列中，有 promise.then，执行微任务，打印 3，</p><p>6.微任务执行完毕，第一次循环结束；从宏任务队列中取出第一个宏任务到主线程执行，打印 1</p><hr><p><em>再举个厉害的栗子吧</em></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer1</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)  &#125;, <span class="hljs-number">1000</span>)&#125;add();setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer2</span>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer3</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)  &#125;, <span class="hljs-number">100</span>)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;    i == <span class="hljs-number">99</span> &amp;&amp; resolve()  &#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer4</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)  &#125;, <span class="hljs-number">0</span>)  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>)</code></pre><p>结果 1， 4， 8， 7， 3， 6， 5， 2，<br>这就不解析了，这回弄懂了吧。</p><hr><p><strong>总结：这是个循环，第一次循环先搞定所有主线程任务，完事以后看看有没有微任务，如果有，执行，然后结束第一次循环，如果没有，就直接结束第一次循环，，，然后开始第二次循环，找到宏任务里边最先执行那个，执行，所有都执行完事，然后看有没有微任务，如果有。。。如果没有。。。。你看这句话上面也说过，这就是循环啊，然后继续循环啊，直到没有宏任务，也没有微任务。循环就完事了呗</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>js运行循环机制 宏任务 微任务 同步任务 异步任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好的开始，我只是想变强</title>
    <link href="/2020/06/08/my-first/"/>
    <url>/2020/06/08/my-first/</url>
    
    <content type="html"><![CDATA[<h3 id="so-what-can-i-do"><a href="#so-what-can-i-do" class="headerlink" title="so what can i do"></a>so what can i do</h3><p>先写个开头，顺便复习一下 markdown，是的，没错，我又忘记 markdown 怎么用了，为了避免再次忘记，要尽量多的使用，<br>比如</p><ul><li>1 尽量频繁的写博客</li><li>2 尽量频繁的写博客</li><li>3 还是 tmd 尽量频繁的写博客</li></ul><p>无序列表用*<br>有序列表用 1.</p><p>比如</p><ol><li>这是有序的</li><li>我是有头发的</li><li>第三条不重要</li></ol><p>加个大于号 后边是文字 展示效果是引用</p><blockquote><p>这是鲁迅说的 —— 周树人</p></blockquote><p>插入链接 <a href="就当这里有链接">xxx</a> 英文书名号加小括号</p><p>插入图片 前边有个感叹号 <img src="%E5%B0%B1%E5%BD%93%E8%BF%99%E9%87%8C%E6%9C%89%E9%93%BE%E6%8E%A5%E5%90%A7" srcset="/img/loading.gif" alt="假装有图.jpg"> 英文感叹号加书名号加小括号</p><p><strong>左右各两个星号中间夹的会加粗，请给我加粗</strong><br><em>左右各一个星号就倾斜</em></p><p>模版字符串中间可以放代码，比如<br><code>const wanghao = &#39;辣鸡&#39;</code><br>左右各三个这玩意，可以夹住代码块，let me try try<br>···不好意思，整错了···</p><pre><code class="hljs ebnf"><span class="hljs-attribute">let a</span> = 1;<span class="hljs-attribute">a</span> = 2;<span class="hljs-attribute">a</span> = b = 2;</code></pre><p>tab 可以缩进，这就是为啥现在才有缩进，我刚看到。<br>非常开心，再来几个缩进<br>三个星号是分割线</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><p>啊。。。失败的 markdown 表格，为啥表格没好使呢？</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>名字</td><td>身份证号码</td></tr><tr><td>王昊</td><td>211232199608135438</td></tr><tr><td>域名</td><td>IP</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td><td>220.181.111.188</td></tr></tbody></table><p>markdown 表格没好使的原因是 我在|后面习惯性的加了空格。导致 markdown 没能识别这种。行那我们继续，上面失败的的就不删除了</p><hr><p><strong>行，这就算复习完事，接下来我随便写写。</strong><br><strong>别问我为啥加粗，我就喜欢粗，并且不缩进，真男人从来不做缩头乌龟</strong></p><h2 id="我还能更粗"><a href="#我还能更粗" class="headerlink" title="我还能更粗"></a>我还能更粗</h2><p>最近经历了好多的事情，事情都是相对的，辩证去看，也无所谓好坏。<br>但是很多事情，我都不喜欢，不如意事常八九，可与人言无二三。<br>敲了很多字，又都删掉了。觉得没有意义。自己和自己的辩论，总归赢的也是自己。<br>自己和自己探讨人生观，价值观，也未免太无趣，还要写在这里记录下来，也未免太他妈的无趣<br>总而言之，我就一句话，我想变强。</p><hr><p><em>我没觉得喜欢这个行业，但是我喜欢自己变强的感觉。</em></p><p>开始整活！<br><strong>奥利给</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>加油</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/06/05/hello-world/"/>
    <url>/2020/06/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
